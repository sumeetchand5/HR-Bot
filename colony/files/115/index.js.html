<h1>index.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> Stream = require(<span class="string">'stream'</span>)

<span class="comment">// through</span>
<span class="comment">//</span>
<span class="comment">// a stream that does nothing but re-emit the input.</span>
<span class="comment">// useful for aggregating a series of changing but not ending streams into one stream)</span>

exports = module.exports = through
through.through = through

<span class="comment">//create a readable writable stream.</span>

<span class="function"><span class="keyword">function</span> <span class="title">through</span> <span class="params">(write, end, opts)</span> {</span>
  write = write || <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span> <span class="keyword">this</span>.queue(data) }
  end = end || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">this</span>.queue(<span class="literal">null</span>) }

  <span class="keyword">var</span> ended = <span class="literal">false</span>, destroyed = <span class="literal">false</span>, buffer = [], _ended = <span class="literal">false</span>
  <span class="keyword">var</span> stream = <span class="keyword">new</span> Stream()
  stream.readable = stream.writable = <span class="literal">true</span>
  stream.paused = <span class="literal">false</span>

<span class="comment">//  stream.autoPause   = !(opts &amp;&amp; opts.autoPause   === false)</span>
  stream.autoDestroy = !(opts &amp;&amp; opts.autoDestroy === <span class="literal">false</span>)

  stream.write = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
    write.call(<span class="keyword">this</span>, data)
    <span class="keyword">return</span> !stream.paused
  }

  <span class="function"><span class="keyword">function</span> <span class="title">drain</span><span class="params">()</span> {</span>
    <span class="keyword">while</span>(buffer.length &amp;&amp; !stream.paused) {
      <span class="keyword">var</span> data = buffer.shift()
      <span class="keyword">if</span>(<span class="literal">null</span> === data)
        <span class="keyword">return</span> stream.emit(<span class="string">'end'</span>)
      <span class="keyword">else</span>
        stream.emit(<span class="string">'data'</span>, data)
    }
  }

  stream.queue = stream.push = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
<span class="comment">//    console.error(ended)</span>
    <span class="keyword">if</span>(_ended) <span class="keyword">return</span> stream
    <span class="keyword">if</span>(data === <span class="literal">null</span>) _ended = <span class="literal">true</span>
    buffer.push(data)
    drain()
    <span class="keyword">return</span> stream
  }

  <span class="comment">//this will be registered as the first 'end' listener</span>
  <span class="comment">//must call destroy next tick, to make sure we're after any</span>
  <span class="comment">//stream piped from here.</span>
  <span class="comment">//this is only a problem if end is not emitted synchronously.</span>
  <span class="comment">//a nicer way to do this is to make sure this is the last listener for 'end'</span>

  stream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    stream.readable = <span class="literal">false</span>
    <span class="keyword">if</span>(!stream.writable &amp;&amp; stream.autoDestroy)
      process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        stream.destroy()
      })
  })

  <span class="function"><span class="keyword">function</span> <span class="title">_end</span> <span class="params">()</span> {</span>
    stream.writable = <span class="literal">false</span>
    end.call(stream)
    <span class="keyword">if</span>(!stream.readable &amp;&amp; stream.autoDestroy)
      stream.destroy()
  }

  stream.end = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
    <span class="keyword">if</span>(ended) <span class="keyword">return</span>
    ended = <span class="literal">true</span>
    <span class="keyword">if</span>(arguments.length) stream.write(data)
    _end() <span class="comment">// will emit or queue</span>
    <span class="keyword">return</span> stream
  }

  stream.destroy = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span>(destroyed) <span class="keyword">return</span>
    destroyed = <span class="literal">true</span>
    ended = <span class="literal">true</span>
    buffer.length = <span class="number">0</span>
    stream.writable = stream.readable = <span class="literal">false</span>
    stream.emit(<span class="string">'close'</span>)
    <span class="keyword">return</span> stream
  }

  stream.pause = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span>(stream.paused) <span class="keyword">return</span>
    stream.paused = <span class="literal">true</span>
    <span class="keyword">return</span> stream
  }

  stream.resume = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span>(stream.paused) {
      stream.paused = <span class="literal">false</span>
      stream.emit(<span class="string">'resume'</span>)
    }
    drain()
    <span class="comment">//may have become paused again,</span>
    <span class="comment">//as drain emits 'data'.</span>
    <span class="keyword">if</span>(!stream.paused)
      stream.emit(<span class="string">'drain'</span>)
    <span class="keyword">return</span> stream
  }
  <span class="keyword">return</span> stream
}

</code></pre>