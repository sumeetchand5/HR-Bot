<h1>publicEncrypt.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> parseKeys = require(<span class="string">'parse-asn1'</span>)
<span class="keyword">var</span> randomBytes = require(<span class="string">'randombytes'</span>)
<span class="keyword">var</span> createHash = require(<span class="string">'create-hash'</span>)
<span class="keyword">var</span> mgf = require(<span class="string">'./mgf'</span>)
<span class="keyword">var</span> xor = require(<span class="string">'./xor'</span>)
<span class="keyword">var</span> BN = require(<span class="string">'bn.js'</span>)
<span class="keyword">var</span> withPublic = require(<span class="string">'./withPublic'</span>)
<span class="keyword">var</span> crt = require(<span class="string">'browserify-rsa'</span>)
<span class="keyword">var</span> Buffer = require(<span class="string">'safe-buffer'</span>).Buffer

module.exports = <span class="function"><span class="keyword">function</span> <span class="title">publicEncrypt</span> <span class="params">(publicKey, msg, reverse)</span> {</span>
  <span class="keyword">var</span> padding
  <span class="keyword">if</span> (publicKey.padding) {
    padding = publicKey.padding
  } <span class="keyword">else</span> <span class="keyword">if</span> (reverse) {
    padding = <span class="number">1</span>
  } <span class="keyword">else</span> {
    padding = <span class="number">4</span>
  }
  <span class="keyword">var</span> key = parseKeys(publicKey)
  <span class="keyword">var</span> paddedMsg
  <span class="keyword">if</span> (padding === <span class="number">4</span>) {
    paddedMsg = oaep(key, msg)
  } <span class="keyword">else</span> <span class="keyword">if</span> (padding === <span class="number">1</span>) {
    paddedMsg = pkcs1(key, msg, reverse)
  } <span class="keyword">else</span> <span class="keyword">if</span> (padding === <span class="number">3</span>) {
    paddedMsg = <span class="keyword">new</span> BN(msg)
    <span class="keyword">if</span> (paddedMsg.cmp(key.modulus) >= <span class="number">0</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'data too long for modulus'</span>)
    }
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'unknown padding'</span>)
  }
  <span class="keyword">if</span> (reverse) {
    <span class="keyword">return</span> crt(paddedMsg, key)
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> withPublic(paddedMsg, key)
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">oaep</span> <span class="params">(key, msg)</span> {</span>
  <span class="keyword">var</span> k = key.modulus.byteLength()
  <span class="keyword">var</span> mLen = msg.length
  <span class="keyword">var</span> iHash = createHash(<span class="string">'sha1'</span>).update(Buffer.alloc(<span class="number">0</span>)).digest()
  <span class="keyword">var</span> hLen = iHash.length
  <span class="keyword">var</span> hLen2 = <span class="number">2</span> * hLen
  <span class="keyword">if</span> (mLen > k - hLen2 - <span class="number">2</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'message too long'</span>)
  }
  <span class="keyword">var</span> ps = Buffer.alloc(k - mLen - hLen2 - <span class="number">2</span>)
  <span class="keyword">var</span> dblen = k - hLen - <span class="number">1</span>
  <span class="keyword">var</span> seed = randomBytes(hLen)
  <span class="keyword">var</span> maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(<span class="number">1</span>, <span class="number">1</span>), msg], dblen), mgf(seed, dblen))
  <span class="keyword">var</span> maskedSeed = xor(seed, mgf(maskedDb, hLen))
  <span class="keyword">return</span> <span class="keyword">new</span> BN(Buffer.concat([Buffer.alloc(<span class="number">1</span>), maskedSeed, maskedDb], k))
}
<span class="function"><span class="keyword">function</span> <span class="title">pkcs1</span> <span class="params">(key, msg, reverse)</span> {</span>
  <span class="keyword">var</span> mLen = msg.length
  <span class="keyword">var</span> k = key.modulus.byteLength()
  <span class="keyword">if</span> (mLen > k - <span class="number">11</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'message too long'</span>)
  }
  <span class="keyword">var</span> ps
  <span class="keyword">if</span> (reverse) {
    ps = Buffer.alloc(k - mLen - <span class="number">3</span>, <span class="number">0xff</span>)
  } <span class="keyword">else</span> {
    ps = nonZero(k - mLen - <span class="number">3</span>)
  }
  <span class="keyword">return</span> <span class="keyword">new</span> BN(Buffer.concat([Buffer.from([<span class="number">0</span>, reverse ? <span class="number">1</span> : <span class="number">2</span>]), ps, Buffer.alloc(<span class="number">1</span>), msg], k))
}
<span class="function"><span class="keyword">function</span> <span class="title">nonZero</span> <span class="params">(len)</span> {</span>
  <span class="keyword">var</span> out = Buffer.allocUnsafe(len)
  <span class="keyword">var</span> i = <span class="number">0</span>
  <span class="keyword">var</span> cache = randomBytes(len * <span class="number">2</span>)
  <span class="keyword">var</span> cur = <span class="number">0</span>
  <span class="keyword">var</span> num
  <span class="keyword">while</span> (i &lt; len) {
    <span class="keyword">if</span> (cur === cache.length) {
      cache = randomBytes(len * <span class="number">2</span>)
      cur = <span class="number">0</span>
    }
    num = cache[cur++]
    <span class="keyword">if</span> (num) {
      out[i++] = num
    }
  }
  <span class="keyword">return</span> out
}
</code></pre>