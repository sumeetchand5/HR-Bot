<h1>index.js</h1>
<pre><code class="lang-js"><span class="comment">/* Generated by `npm run build`, do not edit! */</span>

<span class="string">"use strict"</span>

<span class="keyword">var</span> acorn = require(<span class="string">"acorn"</span>)
<span class="keyword">if</span> (<span class="literal">false</span>) {
  <span class="keyword">throw</span> <span class="keyword">new</span> Error((<span class="string">"acorn-private-class-elements requires acorn@^6.1.0, not "</span> + (acorn.version)))
}
<span class="keyword">var</span> tt = acorn.tokTypes
<span class="keyword">var</span> TokenType = acorn.TokenType

module.exports = <span class="keyword">function</span>(Parser) {
  <span class="comment">// Only load this plugin once.</span>
  <span class="keyword">if</span> (Parser.prototype.parsePrivateName) {
    <span class="keyword">return</span> Parser
  }

  <span class="comment">// Make sure `Parser` comes from the same acorn as our `tt`,</span>
  <span class="comment">// otherwise the comparisons fail.</span>
  <span class="keyword">var</span> cur = Parser
  <span class="keyword">while</span> (cur &amp;&amp; cur !== acorn.Parser) {
    cur = cur.__proto__
  }
  <span class="keyword">if</span> (cur !== acorn.Parser) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"acorn-private-class-elements does not support mixing different acorn copies"</span>)
  }

  Parser = <span class="comment">/*@__PURE__*/</span>(<span class="function"><span class="keyword">function</span> <span class="params">(Parser)</span> {</span>
    <span class="function"><span class="keyword">function</span> <span class="title">Parser_</span> <span class="params">()</span> {</span>
      Parser.apply(<span class="keyword">this</span>, arguments);
    }

    <span class="keyword">if</span> ( Parser ) Parser_.__proto__ = Parser;
    Parser_.prototype = Object.create( Parser &amp;&amp; Parser.prototype );
    Parser_.prototype.constructor = Parser_;

    Parser_.prototype._branch = <span class="function"><span class="keyword">function</span> <span class="title">_branch</span> <span class="params">()</span> {</span>
      <span class="keyword">this</span>.__branch = <span class="keyword">this</span>.__branch || <span class="keyword">new</span> Parser({ecmaVersion: <span class="keyword">this</span>.options.ecmaVersion}, <span class="keyword">this</span>.input)
      <span class="keyword">this</span>.__branch.end = <span class="keyword">this</span>.end
      <span class="keyword">this</span>.__branch.pos = <span class="keyword">this</span>.pos
      <span class="keyword">this</span>.__branch.type = <span class="keyword">this</span>.type
      <span class="keyword">this</span>.__branch.value = <span class="keyword">this</span>.value
      <span class="keyword">this</span>.__branch.containsEsc = <span class="keyword">this</span>.containsEsc
      <span class="keyword">return</span> <span class="keyword">this</span>.__branch
    };

    Parser_.prototype.parsePrivateClassElementName = <span class="function"><span class="keyword">function</span> <span class="title">parsePrivateClassElementName</span> <span class="params">(element)</span> {</span>
      element.computed = <span class="literal">false</span>
      element.key = <span class="keyword">this</span>.parsePrivateName()
      <span class="keyword">if</span> (element.key.name == <span class="string">"constructor"</span>) { <span class="keyword">this</span>.raise(element.key.start, <span class="string">"Classes may not have a private element named constructor"</span>) }
      <span class="keyword">var</span> accept = {get: <span class="string">"set"</span>, set: <span class="string">"get"</span>}[element.kind]
      <span class="keyword">var</span> privateBoundNames = <span class="keyword">this</span>._privateBoundNamesStack[<span class="keyword">this</span>._privateBoundNamesStack.length - <span class="number">1</span>]
      <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) &amp;&amp; privateBoundNames[element.key.name] !== accept) {
        <span class="keyword">this</span>.raise(element.start, <span class="string">"Duplicate private element"</span>)
      }
      privateBoundNames[element.key.name] = element.kind || <span class="literal">true</span>
      <span class="keyword">delete</span> <span class="keyword">this</span>._unresolvedPrivateNamesStack[<span class="keyword">this</span>._unresolvedPrivateNamesStack.length - <span class="number">1</span>][element.key.name]
      <span class="keyword">return</span> element.key
    };

    Parser_.prototype.parsePrivateName = <span class="function"><span class="keyword">function</span> <span class="title">parsePrivateName</span> <span class="params">()</span> {</span>
      <span class="keyword">var</span> node = <span class="keyword">this</span>.startNode()
      node.name = <span class="keyword">this</span>.value
      <span class="keyword">this</span>.next()
      <span class="keyword">this</span>.finishNode(node, <span class="string">"PrivateName"</span>)
      <span class="keyword">if</span> (<span class="keyword">this</span>.options.allowReserved == <span class="string">"never"</span>) { <span class="keyword">this</span>.checkUnreserved(node) }
      <span class="keyword">return</span> node
    };

    <span class="comment">// Parse # token</span>
    Parser_.prototype.getTokenFromCode = <span class="function"><span class="keyword">function</span> <span class="title">getTokenFromCode</span> <span class="params">(code)</span> {</span>
      <span class="keyword">if</span> (code === <span class="number">35</span>) {
        ++<span class="keyword">this</span>.pos
        <span class="keyword">var</span> word = <span class="keyword">this</span>.readWord1()
        <span class="keyword">return</span> <span class="keyword">this</span>.finishToken(<span class="keyword">this</span>.privateNameToken, word)
      }
      <span class="keyword">return</span> Parser.prototype.getTokenFromCode.call(<span class="keyword">this</span>, code)
    };

    <span class="comment">// Manage stacks and check for undeclared private names</span>
    Parser_.prototype.parseClass = <span class="function"><span class="keyword">function</span> <span class="title">parseClass</span> <span class="params">(node, isStatement)</span> {</span>
      <span class="keyword">this</span>._privateBoundNamesStack = <span class="keyword">this</span>._privateBoundNamesStack || []
      <span class="keyword">var</span> privateBoundNames = Object.create(<span class="keyword">this</span>._privateBoundNamesStack[<span class="keyword">this</span>._privateBoundNamesStack.length - <span class="number">1</span>] || <span class="literal">null</span>)
      <span class="keyword">this</span>._privateBoundNamesStack.push(privateBoundNames)
      <span class="keyword">this</span>._unresolvedPrivateNamesStack = <span class="keyword">this</span>._unresolvedPrivateNamesStack || []
      <span class="keyword">var</span> unresolvedPrivateNames = Object.create(<span class="literal">null</span>)
      <span class="keyword">this</span>._unresolvedPrivateNamesStack.push(unresolvedPrivateNames)
      <span class="keyword">var</span> _<span class="keyword">return</span> = Parser.prototype.parseClass.call(<span class="keyword">this</span>, node, isStatement)
      <span class="keyword">this</span>._privateBoundNamesStack.pop()
      <span class="keyword">this</span>._unresolvedPrivateNamesStack.pop()
      <span class="keyword">if</span> (!<span class="keyword">this</span>._unresolvedPrivateNamesStack.length) {
        <span class="keyword">var</span> names = Object.keys(unresolvedPrivateNames)
        <span class="keyword">if</span> (names.length) {
          names.sort(<span class="function"><span class="keyword">function</span> <span class="params">(n1, n2)</span> {</span> <span class="keyword">return</span> unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2]; })
          <span class="keyword">this</span>.raise(unresolvedPrivateNames[names[<span class="number">0</span>]], <span class="string">"Usage of undeclared private name"</span>)
        }
      } <span class="keyword">else</span> { Object.assign(<span class="keyword">this</span>._unresolvedPrivateNamesStack[<span class="keyword">this</span>._unresolvedPrivateNamesStack.length - <span class="number">1</span>], unresolvedPrivateNames) }
      <span class="keyword">return</span> _<span class="keyword">return</span>
    };

    <span class="comment">// Parse private element access</span>
    Parser_.prototype.parseSubscript = <span class="function"><span class="keyword">function</span> <span class="title">parseSubscript</span> <span class="params">(base, startPos, startLoc, noCalls, maybeAsyncArrow)</span> {</span>
      <span class="keyword">if</span> (!<span class="keyword">this</span>.eat(tt.dot)) {
        <span class="keyword">return</span> Parser.prototype.parseSubscript.call(<span class="keyword">this</span>, base, startPos, startLoc, noCalls, maybeAsyncArrow)
      }
      <span class="keyword">var</span> node = <span class="keyword">this</span>.startNodeAt(startPos, startLoc)
      node.object = base
      node.computed = <span class="literal">false</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>.type == <span class="keyword">this</span>.privateNameToken) {
        node.property = <span class="keyword">this</span>.parsePrivateName()
        <span class="keyword">if</span> (!<span class="keyword">this</span>._privateBoundNamesStack.length || !<span class="keyword">this</span>._privateBoundNamesStack[<span class="keyword">this</span>._privateBoundNamesStack.length - <span class="number">1</span>][node.property.name]) {
          <span class="keyword">this</span>._unresolvedPrivateNamesStack[<span class="keyword">this</span>._unresolvedPrivateNamesStack.length - <span class="number">1</span>][node.property.name] = node.property.start
        }
      } <span class="keyword">else</span> {
        node.property = <span class="keyword">this</span>.parseIdent(<span class="literal">true</span>)
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.finishNode(node, <span class="string">"MemberExpression"</span>)
    };

    <span class="comment">// Prohibit delete of private class elements</span>
    Parser_.prototype.parseMaybeUnary = <span class="function"><span class="keyword">function</span> <span class="title">parseMaybeUnary</span> <span class="params">(refDestructuringErrors, sawUnary)</span> {</span>
      <span class="keyword">var</span> _<span class="keyword">return</span> = Parser.prototype.parseMaybeUnary.call(<span class="keyword">this</span>, refDestructuringErrors, sawUnary)
      <span class="keyword">if</span> (_<span class="keyword">return</span>.operator == <span class="string">"delete"</span>) {
        <span class="keyword">if</span> (_<span class="keyword">return</span>.argument.type == <span class="string">"MemberExpression"</span> &amp;&amp; _<span class="keyword">return</span>.argument.property.type == <span class="string">"PrivateName"</span>) {
          <span class="keyword">this</span>.raise(_<span class="keyword">return</span>.start, <span class="string">"Private elements may not be deleted"</span>)
        }
      }
      <span class="keyword">return</span> _<span class="keyword">return</span>
    };

    <span class="keyword">return</span> Parser_;
  }(Parser))
  Parser.prototype.privateNameToken = <span class="keyword">new</span> TokenType(<span class="string">"privateName"</span>)
  <span class="keyword">return</span> Parser
}
</code></pre>