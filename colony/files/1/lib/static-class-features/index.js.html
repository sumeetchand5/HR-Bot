<h1>index.js</h1>
<pre><code class="lang-js"><span class="comment">/* Generated by `npm run build`, do not edit! */</span>

<span class="string">"use strict"</span>

<span class="keyword">var</span> skipWhiteSpace = <span class="regexp">/(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g</span>

<span class="keyword">var</span> acorn = require(<span class="string">"acorn"</span>)
<span class="keyword">var</span> tt = acorn.tokTypes

<span class="function"><span class="keyword">function</span> <span class="title">maybeParseFieldValue</span><span class="params">(field)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.eat(tt.eq)) {
    <span class="keyword">var</span> oldInFieldValue = <span class="keyword">this</span>._inStaticFieldValue
    <span class="keyword">this</span>._inStaticFieldValue = <span class="literal">true</span>
    field.value = <span class="keyword">this</span>.parseExpression()
    <span class="keyword">this</span>._inStaticFieldValue = oldInFieldValue
  } <span class="keyword">else</span> { field.value = <span class="literal">null</span> }
}

<span class="keyword">var</span> privateClassElements = require(<span class="string">"../private-class-elements"</span>)

module.exports = <span class="keyword">function</span>(Parser) {
  <span class="keyword">var</span> ExtendedParser = privateClassElements(Parser)

  <span class="keyword">return</span> <span class="comment">/*@__PURE__*/</span>(<span class="function"><span class="keyword">function</span> <span class="params">(ExtendedParser)</span> {</span>
    <span class="function"><span class="keyword">function</span> <span class="title">anonymous</span> <span class="params">()</span> {</span>
      ExtendedParser.apply(<span class="keyword">this</span>, arguments);
    }

    <span class="keyword">if</span> ( ExtendedParser ) anonymous.__proto__ = ExtendedParser;
    anonymous.prototype = Object.create( ExtendedParser &amp;&amp; ExtendedParser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype.parseClassElement = <span class="function"><span class="keyword">function</span> <span class="title">parseClassElement</span> <span class="params">(_constructorAllowsSuper)</span> {</span>
      <span class="keyword">var</span> <span class="keyword">this</span>$<span class="number">1</span> = <span class="keyword">this</span>;

      <span class="keyword">if</span> (<span class="keyword">this</span>.eat(tt.semi)) { <span class="keyword">return</span> <span class="literal">null</span> }

      <span class="keyword">var</span> node = <span class="keyword">this</span>.startNode()

      <span class="keyword">var</span> tryContextual = <span class="function"><span class="keyword">function</span> <span class="params">(k, noLineBreak)</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> noLineBreak == <span class="string">"undefined"</span>) { noLineBreak = <span class="literal">false</span> }
        <span class="keyword">var</span> start = <span class="keyword">this</span>$<span class="number">1.</span>start, startLoc = <span class="keyword">this</span>$<span class="number">1.</span>startLoc
        <span class="keyword">if</span> (!<span class="keyword">this</span>$<span class="number">1.</span>eatContextual(k)) { <span class="keyword">return</span> <span class="literal">false</span> }
        <span class="keyword">if</span> (<span class="keyword">this</span>$<span class="number">1.</span>type !== tt.parenL &amp;&amp; (!noLineBreak || !<span class="keyword">this</span>$<span class="number">1.</span>canInsertSemicolon())) { <span class="keyword">return</span> <span class="literal">true</span> }
        <span class="keyword">if</span> (node.key) { <span class="keyword">this</span>$<span class="number">1.</span>unexpected() }
        node.computed = <span class="literal">false</span>
        node.key = <span class="keyword">this</span>$<span class="number">1.</span>startNodeAt(start, startLoc)
        node.key.name = k
        <span class="keyword">this</span>$<span class="number">1.</span>finishNode(node.key, <span class="string">"Identifier"</span>)
        <span class="keyword">return</span> <span class="literal">false</span>
      }

      node.static = tryContextual(<span class="string">"static"</span>)
      <span class="keyword">if</span> (!node.static) { <span class="keyword">return</span> ExtendedParser.prototype.parseClassElement.apply(<span class="keyword">this</span>, arguments) }

      <span class="keyword">var</span> isGenerator = <span class="keyword">this</span>.eat(tt.star)
      <span class="keyword">var</span> isAsync = <span class="literal">false</span>
      <span class="keyword">if</span> (!isGenerator) {
        <span class="comment">// Special-case for `async`, since `parseClassMember` currently looks</span>
        <span class="comment">// for `(` to determine whether `async` is a method name</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.options.ecmaVersion >= <span class="number">8</span> &amp;&amp; <span class="keyword">this</span>.isContextual(<span class="string">"async"</span>)) {
          skipWhiteSpace.lastIndex = <span class="keyword">this</span>.pos
          <span class="keyword">var</span> skip = skipWhiteSpace.exec(<span class="keyword">this</span>.input)
          <span class="keyword">var</span> next = <span class="keyword">this</span>.input.charAt(<span class="keyword">this</span>.pos + skip[<span class="number">0</span>].length)
          <span class="keyword">if</span> (next === <span class="string">";"</span> || next === <span class="string">"="</span>) {
            node.key = <span class="keyword">this</span>.parseIdent(<span class="literal">true</span>)
            node.computed = <span class="literal">false</span>
            maybeParseFieldValue.call(<span class="keyword">this</span>, node)
            <span class="keyword">this</span>.finishNode(node, <span class="string">"FieldDefinition"</span>)
            <span class="keyword">this</span>.semicolon()
            <span class="keyword">return</span> node
          } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.options.ecmaVersion >= <span class="number">8</span> &amp;&amp; tryContextual(<span class="string">"async"</span>, <span class="literal">true</span>)) {
            isAsync = <span class="literal">true</span>
            isGenerator = <span class="keyword">this</span>.options.ecmaVersion >= <span class="number">9</span> &amp;&amp; <span class="keyword">this</span>.eat(tt.star)
          }
        } <span class="keyword">else</span> <span class="keyword">if</span> (tryContextual(<span class="string">"get"</span>)) {
          node.kind = <span class="string">"get"</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (tryContextual(<span class="string">"set"</span>)) {
          node.kind = <span class="string">"set"</span>
        }
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="keyword">this</span>.privateNameToken) {
        <span class="keyword">this</span>.parsePrivateClassElementName(node)
        <span class="keyword">if</span> (<span class="keyword">this</span>.type !== tt.parenL) {
          <span class="keyword">if</span> (node.key.name === <span class="string">"prototype"</span>) {
            <span class="keyword">this</span>.raise(node.key.start, <span class="string">"Classes may not have a private static property named prototype"</span>)
          }
          maybeParseFieldValue.call(<span class="keyword">this</span>, node)
          <span class="keyword">this</span>.finishNode(node, <span class="string">"FieldDefinition"</span>)
          <span class="keyword">this</span>.semicolon()
          <span class="keyword">return</span> node
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (!node.key) {
        <span class="keyword">this</span>.parsePropertyName(node)
        <span class="keyword">if</span> ((node.key.name || node.key.value) === <span class="string">"prototype"</span> &amp;&amp; !node.computed) {
          <span class="keyword">this</span>.raise(node.key.start, <span class="string">"Classes may not have a static property named prototype"</span>)
        }
      }
      <span class="keyword">if</span> (!node.kind) { node.kind = <span class="string">"method"</span> }
      <span class="keyword">this</span>.parseClassMethod(node, isGenerator, isAsync)
      <span class="keyword">if</span> (!node.kind &amp;&amp; (node.key.name || node.key.value) === <span class="string">"constructor"</span> &amp;&amp; !node.computed) {
        <span class="keyword">this</span>.raise(node.key.start, <span class="string">"Classes may not have a static field named constructor"</span>)
      }
      <span class="keyword">if</span> (node.kind === <span class="string">"get"</span> &amp;&amp; node.value.params.length !== <span class="number">0</span>) {
        <span class="keyword">this</span>.raiseRecoverable(node.value.start, <span class="string">"getter should have no params"</span>)
      }
      <span class="keyword">if</span> (node.kind === <span class="string">"set"</span> &amp;&amp; node.value.params.length !== <span class="number">1</span>) {
        <span class="keyword">this</span>.raiseRecoverable(node.value.start, <span class="string">"setter should have exactly one param"</span>)
      }
      <span class="keyword">if</span> (node.kind === <span class="string">"set"</span> &amp;&amp; node.value.params[<span class="number">0</span>].type === <span class="string">"RestElement"</span>) {
        <span class="keyword">this</span>.raiseRecoverable(node.value.params[<span class="number">0</span>].start, <span class="string">"Setter cannot use rest params"</span>)
      }

      <span class="keyword">return</span> node

    };

    <span class="comment">// Parse public static fields</span>
    anonymous.prototype.parseClassMethod = <span class="function"><span class="keyword">function</span> <span class="title">parseClassMethod</span> <span class="params">(method, isGenerator, isAsync, _allowsDirectSuper)</span> {</span>
      <span class="keyword">if</span> (isGenerator || isAsync || method.kind != <span class="string">"method"</span> || !method.static || <span class="keyword">this</span>.options.ecmaVersion &lt; <span class="number">8</span> || <span class="keyword">this</span>.type == tt.parenL) {
        <span class="keyword">return</span> ExtendedParser.prototype.parseClassMethod.apply(<span class="keyword">this</span>, arguments)
      }
      maybeParseFieldValue.call(<span class="keyword">this</span>, method)
      <span class="keyword">delete</span> method.kind
      method = <span class="keyword">this</span>.finishNode(method, <span class="string">"FieldDefinition"</span>)
      <span class="keyword">this</span>.semicolon()
      <span class="keyword">return</span> method
    };

    <span class="comment">// Prohibit arguments in class field initializers</span>
    anonymous.prototype.parseIdent = <span class="function"><span class="keyword">function</span> <span class="title">parseIdent</span> <span class="params">(liberal, isBinding)</span> {</span>
      <span class="keyword">var</span> ident = ExtendedParser.prototype.parseIdent.call(<span class="keyword">this</span>, liberal, isBinding)
      <span class="keyword">if</span> (<span class="keyword">this</span>._inStaticFieldValue &amp;&amp; ident.name == <span class="string">"arguments"</span>) { <span class="keyword">this</span>.raise(ident.start, <span class="string">"A static class field initializer may not contain arguments"</span>) }
      <span class="keyword">return</span> ident
    };

    <span class="keyword">return</span> anonymous;
  }(ExtendedParser))
}
</code></pre>