<h1>index.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> fs = require(<span class="string">'fs'</span>);
<span class="keyword">var</span> path = require(<span class="string">'path'</span>);
<span class="keyword">var</span> relativePath = require(<span class="string">'cached-path-relative'</span>);

<span class="keyword">var</span> browserResolve = require(<span class="string">'browser-resolve'</span>);
<span class="keyword">var</span> nodeResolve = require(<span class="string">'resolve'</span>);
<span class="keyword">var</span> detective = require(<span class="string">'detective'</span>);
<span class="keyword">var</span> through = require(<span class="string">'through2'</span>);
<span class="keyword">var</span> concat = require(<span class="string">'concat-stream'</span>);
<span class="keyword">var</span> parents = require(<span class="string">'parents'</span>);
<span class="keyword">var</span> combine = require(<span class="string">'stream-combiner2'</span>);
<span class="keyword">var</span> duplexer = require(<span class="string">'duplexer2'</span>);
<span class="keyword">var</span> xtend = require(<span class="string">'xtend'</span>);
<span class="keyword">var</span> defined = require(<span class="string">'defined'</span>);

<span class="keyword">var</span> inherits = require(<span class="string">'inherits'</span>);
<span class="keyword">var</span> Transform = require(<span class="string">'readable-stream'</span>).Transform;

module.exports = Deps;
inherits(Deps, Transform);

<span class="function"><span class="keyword">function</span> <span class="title">Deps</span> <span class="params">(opts)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Deps)) <span class="keyword">return</span> <span class="keyword">new</span> Deps(opts);
    Transform.call(<span class="keyword">this</span>, { objectMode: <span class="literal">true</span> });
    
    <span class="keyword">if</span> (!opts) opts = {};
    
    <span class="keyword">this</span>.basedir = opts.basedir || process.cwd();
    <span class="keyword">this</span>.persistentCache = opts.persistentCache || <span class="function"><span class="keyword">function</span> <span class="params">(file, id, pkg, fallback, cb)</span> {</span>
        process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
            fallback(<span class="literal">null</span>, cb);
        });
    };
    <span class="keyword">this</span>.cache = opts.cache;
    <span class="keyword">this</span>.fileCache = opts.fileCache;
    <span class="keyword">this</span>.pkgCache = opts.packageCache || {};
    <span class="keyword">this</span>.pkgFileCache = {};
    <span class="keyword">this</span>.pkgFileCachePending = {};
    <span class="keyword">this</span>._emittedPkg = {};
    <span class="keyword">this</span>._transformDeps = {};
    <span class="keyword">this</span>.visited = {};
    <span class="keyword">this</span>.walking = {};
    <span class="keyword">this</span>.entries = [];
    <span class="keyword">this</span>._input = [];
    
    <span class="keyword">this</span>.paths = opts.paths || process.env.NODE_PATH || <span class="string">''</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.paths === <span class="string">'string'</span>) {
        <span class="keyword">var</span> delimiter = path.delimiter || (process.platform === <span class="string">'win32'</span> ? <span class="string">';'</span> : <span class="string">':'</span>);
        <span class="keyword">this</span>.paths = <span class="keyword">this</span>.paths.split(delimiter);
    }
    <span class="keyword">this</span>.paths = <span class="keyword">this</span>.paths
        .filter(Boolean)
        .map(<span class="function"><span class="keyword">function</span> <span class="params">(p)</span> {</span>
            <span class="keyword">return</span> path.resolve(self.basedir, p);
        });
    
    <span class="keyword">this</span>.transforms = [].concat(opts.transform).filter(Boolean);
    <span class="keyword">this</span>.globalTransforms = [].concat(opts.globalTransform).filter(Boolean);
    <span class="keyword">this</span>.resolver = opts.resolve || browserResolve;
    <span class="keyword">this</span>.detective = opts.detect || detective;
    <span class="keyword">this</span>.options = xtend(opts);
    <span class="keyword">if</span> (!<span class="keyword">this</span>.options.modules) <span class="keyword">this</span>.options.modules = {};

    <span class="comment">// If the caller passes options.expose, store resolved pathnames for exposed</span>
    <span class="comment">// modules in it. If not, set it anyway so it's defined later.</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.options.expose) <span class="keyword">this</span>.options.expose = {};
    <span class="keyword">this</span>.pending = <span class="number">0</span>;
    <span class="keyword">this</span>.inputPending = <span class="number">0</span>;
    
    <span class="keyword">var</span> topfile = path.join(<span class="keyword">this</span>.basedir, <span class="string">'__fake.js'</span>);
    <span class="keyword">this</span>.top = {
        id: topfile,
        filename: topfile,
        paths: <span class="keyword">this</span>.paths,
        basedir: <span class="keyword">this</span>.basedir
    };
}

Deps.prototype._isTopLevel = <span class="function"><span class="keyword">function</span> <span class="params">(file)</span> {</span>
    <span class="keyword">var</span> isTopLevel = <span class="keyword">this</span>.entries.some(<span class="function"><span class="keyword">function</span> <span class="params">(main)</span> {</span>
        <span class="keyword">var</span> m = relativePath(path.dirname(main), file);
        <span class="keyword">return</span> m.split(<span class="regexp">/[\\\/]/</span>).indexOf(<span class="string">'node_modules'</span>) &lt; <span class="number">0</span>;
    });
    <span class="keyword">if</span> (!isTopLevel) {
        <span class="keyword">var</span> m = relativePath(<span class="keyword">this</span>.basedir, file);
        isTopLevel = m.split(<span class="regexp">/[\\\/]/</span>).indexOf(<span class="string">'node_modules'</span>) &lt; <span class="number">0</span>;
    }
    <span class="keyword">return</span> isTopLevel;
};

Deps.prototype._transform = <span class="function"><span class="keyword">function</span> <span class="params">(row, enc, next)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> row === <span class="string">'string'</span>) {
        row = { file: row };
    }
    <span class="keyword">if</span> (row.transform &amp;&amp; row.global) {
        <span class="keyword">this</span>.globalTransforms.push([ row.transform, row.options ]);
        <span class="keyword">return</span> next();
    }
    <span class="keyword">else</span> <span class="keyword">if</span> (row.transform) {
        <span class="keyword">this</span>.transforms.push([ row.transform, row.options ]);
        <span class="keyword">return</span> next();
    }
    
    self.pending ++;
    <span class="keyword">var</span> basedir = defined(row.basedir, self.basedir);
    
    <span class="keyword">if</span> (row.entry !== <span class="literal">false</span>) {
        self.entries.push(path.resolve(basedir, row.file || row.id));
    }
    
    self.lookupPackage(row.file, <span class="function"><span class="keyword">function</span> <span class="params">(err, pkg)</span> {</span>
        <span class="keyword">if</span> (err &amp;&amp; self.options.ignoreMissing) {
            self.emit(<span class="string">'missing'</span>, row.file, self.top);
            self.pending --;
            <span class="keyword">return</span> next();
        }
        <span class="keyword">if</span> (err) <span class="keyword">return</span> self.emit(<span class="string">'error'</span>, err)
        self.pending --;
        self._input.push({ row: row, pkg: pkg });
        next();
    });
};

Deps.prototype._flush = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">var</span> files = {};
    self._input.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(r)</span> {</span>
        <span class="keyword">var</span> w = r.row, f = files[w.file || w.id];
        <span class="keyword">if</span> (f) {
            f.row.entry = f.row.entry || w.entry;
            <span class="keyword">var</span> ex = f.row.expose || w.expose;
            f.row.expose = ex;
            <span class="keyword">if</span> (ex &amp;&amp; f.row.file === f.row.id &amp;&amp; w.file !== w.id) {
                f.row.id = w.id;
            }
        }
        <span class="keyword">else</span> files[w.file || w.id] = r;
    });
    
    Object.keys(files).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span>
        <span class="keyword">var</span> r = files[key];
        <span class="keyword">var</span> pkg = r.pkg || {};
        <span class="keyword">var</span> dir = r.row.file ? path.dirname(r.row.file) : self.basedir;
        <span class="keyword">if</span> (!pkg.__dirname) pkg.__dirname = dir;
        self.walk(r.row, xtend(self.top, {
            filename: path.join(dir, <span class="string">'_fake.js'</span>)
        }));
    });
    <span class="keyword">if</span> (<span class="keyword">this</span>.pending === <span class="number">0</span>) <span class="keyword">this</span>.push(<span class="literal">null</span>);
    <span class="keyword">this</span>._ended = <span class="literal">true</span>;
};

Deps.prototype.resolve = <span class="function"><span class="keyword">function</span> <span class="params">(id, parent, cb)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">var</span> opts = self.options;
    
    <span class="keyword">if</span> (xhas(self.cache, parent.id, <span class="string">'deps'</span>, id)
    &amp;&amp; self.cache[parent.id].deps[id]) {
        <span class="keyword">var</span> file = self.cache[parent.id].deps[id];
        <span class="keyword">var</span> pkg = self.pkgCache[file];
        <span class="keyword">if</span> (pkg) <span class="keyword">return</span> cb(<span class="literal">null</span>, file, pkg);
        <span class="keyword">return</span> self.lookupPackage(file, <span class="function"><span class="keyword">function</span> <span class="params">(err, pkg)</span> {</span>
            cb(<span class="literal">null</span>, file, pkg);
        });
    }
    
    parent.packageFilter = <span class="function"><span class="keyword">function</span> <span class="params">(p, x)</span> {</span>
        <span class="keyword">var</span> pkgdir = path.dirname(x);
        <span class="keyword">if</span> (opts.packageFilter) p = opts.packageFilter(p, x);
        p.__dirname = pkgdir;

        <span class="keyword">return</span> p;
    };
    
    <span class="keyword">if</span> (opts.extensions) parent.extensions = opts.extensions;
    <span class="keyword">if</span> (opts.modules) parent.modules = opts.modules;
    
    self.resolver(id, parent, <span class="function"><span class="keyword">function</span> <span class="title">onresolve</span> <span class="params">(err, file, pkg, fakePath)</span> {</span>
        <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);
        <span class="keyword">if</span> (!file) <span class="keyword">return</span> cb(<span class="keyword">new</span> Error(
            <span class="string">'module not found: "'</span> + id + <span class="string">'" from file '</span>
            + parent.filename
        ));
        
        <span class="keyword">if</span> (!pkg || !pkg.__dirname) {
            self.lookupPackage(file, <span class="function"><span class="keyword">function</span> <span class="params">(err, p)</span> {</span>
                <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);
                <span class="keyword">if</span> (!p) p = {};
                <span class="keyword">if</span> (!p.__dirname) p.__dirname = path.dirname(file);
                self.pkgCache[file] = p;
                onresolve(err, file, opts.packageFilter
                    ? opts.packageFilter(p, p.__dirname) : p,
                    fakePath
                );
            });
        }
        <span class="keyword">else</span> cb(err, file, pkg, fakePath);
    });
};

Deps.prototype.readFile = <span class="function"><span class="keyword">function</span> <span class="params">(file, id, pkg)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (xhas(<span class="keyword">this</span>.fileCache, file)) {
        <span class="keyword">return</span> toStream(<span class="keyword">this</span>.fileCache[file]);
    }
    <span class="keyword">var</span> rs = fs.createReadStream(file, {
        encoding: <span class="string">'utf8'</span>
    });
    <span class="keyword">return</span> rs;
};

Deps.prototype.getTransforms = <span class="function"><span class="keyword">function</span> <span class="params">(file, pkg, opts)</span> {</span>
    <span class="keyword">if</span> (!opts) opts = {};
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    
    <span class="keyword">var</span> isTopLevel;
    <span class="keyword">if</span> (opts.builtin || opts.inNodeModules) isTopLevel = <span class="literal">false</span>;
    <span class="keyword">else</span> isTopLevel = <span class="keyword">this</span>._isTopLevel(file);
    
    <span class="keyword">var</span> transforms = [].concat(isTopLevel ? <span class="keyword">this</span>.transforms : [])
        .concat(getTransforms(pkg, {
            globalTransform: <span class="keyword">this</span>.globalTransforms,
            transformKey: <span class="keyword">this</span>.options.transformKey
        }))
    ;
    <span class="keyword">if</span> (transforms.length === <span class="number">0</span>) <span class="keyword">return</span> through();
    
    <span class="keyword">var</span> pending = transforms.length;
    <span class="keyword">var</span> streams = [];
    <span class="keyword">var</span> input = through();
    <span class="keyword">var</span> output = through();
    <span class="keyword">var</span> dup = duplexer(input, output);
    
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; transforms.length; i++) (<span class="function"><span class="keyword">function</span> <span class="params">(i)</span> {</span>
        makeTransform(transforms[i], <span class="function"><span class="keyword">function</span> <span class="params">(err, trs)</span> {</span>
            <span class="keyword">if</span> (err) {
                <span class="keyword">return</span> dup.emit(<span class="string">'error'</span>, err);
            }
            streams[i] = trs;
            <span class="keyword">if</span> (-- pending === <span class="number">0</span>) done();
        });
    })(i);
    <span class="keyword">return</span> dup;
    
    <span class="function"><span class="keyword">function</span> <span class="title">done</span> <span class="params">()</span> {</span>
        <span class="keyword">var</span> middle = combine.apply(<span class="literal">null</span>, streams);
        middle.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
            err.message += <span class="string">' while parsing file: '</span> + file;
            <span class="keyword">if</span> (!err.filename) err.filename = file;
            dup.emit(<span class="string">'error'</span>, err);
        });
        input.pipe(middle).pipe(output);
    }
    
    <span class="function"><span class="keyword">function</span> <span class="title">makeTransform</span> <span class="params">(tr, cb)</span> {</span>
        <span class="keyword">var</span> trOpts = {};
        <span class="keyword">if</span> (Array.isArray(tr)) {
            trOpts = tr[<span class="number">1</span>] || {};
            tr = tr[<span class="number">0</span>];
        }
        trOpts._flags = trOpts.hasOwnProperty(<span class="string">'_flags'</span>) ? trOpts._flags : self.options;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> tr === <span class="string">'function'</span>) {
            <span class="keyword">var</span> t = tr(file, trOpts);
            <span class="comment">// allow transforms to `stream.emit('dep', path)` to add dependencies for this file</span>
            t.on(<span class="string">'dep'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(dep)</span> {</span>
                <span class="keyword">if</span> (!self._transformDeps[file]) self._transformDeps[file] = [];
                self._transformDeps[file].push(dep);
            });
            self.emit(<span class="string">'transform'</span>, t, file);
            nextTick(cb, <span class="literal">null</span>, wrapTransform(t));
        }
        <span class="keyword">else</span> {
            loadTransform(tr, trOpts, <span class="function"><span class="keyword">function</span> <span class="params">(err, trs)</span> {</span>
                <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);
                cb(<span class="literal">null</span>, wrapTransform(trs));
            });
        }
    }
    
    <span class="function"><span class="keyword">function</span> <span class="title">loadTransform</span> <span class="params">(id, trOpts, cb)</span> {</span>
        <span class="keyword">var</span> params = {
            basedir: path.dirname(file),
            preserveSymlinks: <span class="literal">false</span>
        };
        nodeResolve(id, params, <span class="function"><span class="keyword">function</span> <span class="title">nr</span> <span class="params">(err, res, again)</span> {</span>
            <span class="keyword">if</span> (err &amp;&amp; again) <span class="keyword">return</span> cb &amp;&amp; cb(err);
            
            <span class="keyword">if</span> (err) {
                params.basedir = pkg.__dirname;
                <span class="keyword">return</span> nodeResolve(id, params, <span class="function"><span class="keyword">function</span> <span class="params">(e, r)</span> {</span>
                    nr(e, r, <span class="literal">true</span>);
                });
            }
            
            <span class="keyword">if</span> (!res) <span class="keyword">return</span> cb(<span class="keyword">new</span> Error(
                <span class="string">'cannot find transform module '</span> + tr
                + <span class="string">' while transforming '</span> + file
            ));
            
            <span class="keyword">var</span> r = require(res);
            <span class="keyword">if</span> (<span class="keyword">typeof</span> r !== <span class="string">'function'</span>) {
                <span class="keyword">return</span> cb(<span class="keyword">new</span> Error(
                    <span class="string">'Unexpected '</span> + <span class="keyword">typeof</span> r + <span class="string">' exported by the '</span>
                    + JSON.stringify(res) + <span class="string">' package. '</span>
                    + <span class="string">'Expected a transform function.'</span>
                ));
            }
            
            <span class="keyword">var</span> trs = r(file, trOpts);
            <span class="comment">// allow transforms to `stream.emit('dep', path)` to add dependencies for this file</span>
            trs.on(<span class="string">'dep'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(dep)</span> {</span>
                <span class="keyword">if</span> (!self._transformDeps[file]) self._transformDeps[file] = [];
                self._transformDeps[file].push(dep);
            });
            self.emit(<span class="string">'transform'</span>, trs, file);
            cb(<span class="literal">null</span>, trs);
        });
    }
};

Deps.prototype.walk = <span class="function"><span class="keyword">function</span> <span class="params">(id, parent, cb)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">var</span> opts = self.options;
    <span class="keyword">this</span>.pending ++;
    
    <span class="keyword">var</span> rec = {};
    <span class="keyword">var</span> input;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">'object'</span>) {
        rec = xtend(id);
        <span class="keyword">if</span> (rec.entry === <span class="literal">false</span>) <span class="keyword">delete</span> rec.entry;
        id = rec.file || rec.id;
        input = <span class="literal">true</span>;
        <span class="keyword">this</span>.inputPending ++;
    }
    
    self.resolve(id, parent, <span class="function"><span class="keyword">function</span> <span class="params">(err, file, pkg, fakePath)</span> {</span>
        <span class="comment">// this is checked early because parent.modules is also modified</span>
        <span class="comment">// by this function.</span>
        <span class="keyword">var</span> builtin = has(parent.modules, id);

        <span class="keyword">if</span> (rec.expose) {
            <span class="comment">// Set options.expose to make the resolved pathname available to the</span>
            <span class="comment">// caller. They may or may not have requested it, but it's harmless</span>
            <span class="comment">// to set this if they didn't.</span>
            self.options.expose[rec.expose] =
                self.options.modules[rec.expose] = file;
        }
        <span class="keyword">if</span> (pkg &amp;&amp; !self._emittedPkg[pkg.__dirname]) {
            self._emittedPkg[pkg.__dirname] = <span class="literal">true</span>;
            self.emit(<span class="string">'package'</span>, pkg);
        }
        
        <span class="keyword">if</span> (opts.postFilter &amp;&amp; !opts.postFilter(id, file, pkg)) {
            <span class="keyword">if</span> (--self.pending === <span class="number">0</span>) self.push(<span class="literal">null</span>);
            <span class="keyword">if</span> (input) --self.inputPending;
            <span class="keyword">return</span> cb &amp;&amp; cb(<span class="literal">null</span>, <span class="literal">undefined</span>);
        }
        <span class="keyword">if</span> (err &amp;&amp; rec.source) {
            file = rec.file;
            
            <span class="keyword">var</span> ts = self.getTransforms(file, pkg);
            ts.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                self.emit(<span class="string">'error'</span>, err);
            });
            ts.pipe(concat(<span class="function"><span class="keyword">function</span> <span class="params">(body)</span> {</span>
                rec.source = body.toString(<span class="string">'utf8'</span>);
                fromSource(file, rec.source, pkg);
            }));
            <span class="keyword">return</span> ts.end(rec.source);
        }
        <span class="keyword">if</span> (err &amp;&amp; self.options.ignoreMissing) {
            <span class="keyword">if</span> (--self.pending === <span class="number">0</span>) self.push(<span class="literal">null</span>);
            <span class="keyword">if</span> (input) --self.inputPending;
            self.emit(<span class="string">'missing'</span>, id, parent);
            <span class="keyword">return</span> cb &amp;&amp; cb(<span class="literal">null</span>, <span class="literal">undefined</span>);
        }
        <span class="keyword">if</span> (err) <span class="keyword">return</span> self.emit(<span class="string">'error'</span>, err);
        <span class="keyword">if</span> (self.visited[file]) {
            <span class="keyword">if</span> (-- self.pending === <span class="number">0</span>) self.push(<span class="literal">null</span>);
            <span class="keyword">if</span> (input) --self.inputPending;
            <span class="keyword">return</span> cb &amp;&amp; cb(<span class="literal">null</span>, file);
        }
        self.visited[file] = <span class="literal">true</span>;
        
        <span class="keyword">if</span> (rec.source) {
            <span class="keyword">var</span> ts = self.getTransforms(file, pkg);
            ts.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
                self.emit(<span class="string">'error'</span>, err);
            });
            ts.pipe(concat(<span class="function"><span class="keyword">function</span> <span class="params">(body)</span> {</span>
                rec.source = body.toString(<span class="string">'utf8'</span>);
                fromSource(file, rec.source, pkg);
            }));
            <span class="keyword">return</span> ts.end(rec.source);
        }
        
        <span class="keyword">var</span> c = self.cache &amp;&amp; self.cache[file];
        <span class="keyword">if</span> (c) <span class="keyword">return</span> fromDeps(file, c.source, c.package, fakePath, Object.keys(c.deps));
        
        self.persistentCache(file, id, pkg, persistentCacheFallback, <span class="function"><span class="keyword">function</span> <span class="params">(err, c)</span> {</span>
            self.emit(<span class="string">'file'</span>, file, id);
            <span class="keyword">if</span> (err) {
                self.emit(<span class="string">'error'</span>, err);
                <span class="keyword">return</span>;
            }
            fromDeps(file, c.source, c.package, fakePath, Object.keys(c.deps));
        });

        <span class="function"><span class="keyword">function</span> <span class="title">persistentCacheFallback</span> <span class="params">(dataAsString, cb)</span> {</span>
            <span class="keyword">var</span> stream = dataAsString ? toStream(dataAsString) : self.readFile(file, id, pkg).on(<span class="string">'error'</span>, cb);
            stream
                .pipe(self.getTransforms(fakePath || file, pkg, {
                    builtin: builtin,
                    inNodeModules: parent.inNodeModules
                }))
                .on(<span class="string">'error'</span>, cb)
                .pipe(concat(<span class="function"><span class="keyword">function</span> <span class="params">(body)</span> {</span>
                    <span class="keyword">var</span> src = body.toString(<span class="string">'utf8'</span>);
                    <span class="keyword">try</span> { <span class="keyword">var</span> deps = getDeps(file, src); }
                    <span class="keyword">catch</span> (err) { cb(err); }
                    <span class="keyword">if</span> (deps) {
                        cb(<span class="literal">null</span>, {
                            source: src,
                            package: pkg,
                            deps: deps.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(deps, dep)</span> {</span>
                                deps[dep] = <span class="literal">true</span>;
                                <span class="keyword">return</span> deps;
                            }, {})
                        });
                    }
                }));
        }
    });

    <span class="function"><span class="keyword">function</span> <span class="title">getDeps</span> <span class="params">(file, src)</span> {</span>
        <span class="keyword">var</span> deps = rec.noparse ? [] : self.parseDeps(file, src);
        <span class="comment">// dependencies emitted by transforms</span>
        <span class="keyword">if</span> (self._transformDeps[file]) deps = deps.concat(self._transformDeps[file]);
        <span class="keyword">return</span> deps;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">fromSource</span> <span class="params">(file, src, pkg, fakePath)</span> {</span>
        <span class="keyword">var</span> deps = getDeps(file, src);
        <span class="keyword">if</span> (deps) fromDeps(file, src, pkg, fakePath, deps);
    }
    
    <span class="function"><span class="keyword">function</span> <span class="title">fromDeps</span> <span class="params">(file, src, pkg, fakePath, deps)</span> {</span>
        <span class="keyword">var</span> p = deps.length;
        <span class="keyword">var</span> resolved = {};
        
        <span class="keyword">if</span> (input) --self.inputPending;
        
        (<span class="function"><span class="keyword">function</span> <span class="title">resolve</span> <span class="params">()</span> {</span>
            <span class="keyword">if</span> (self.inputPending > <span class="number">0</span>) <span class="keyword">return</span> setTimeout(resolve);
            deps.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(id)</span> {</span>
                <span class="keyword">if</span> (opts.filter &amp;&amp; !opts.filter(id)) {
                    resolved[id] = <span class="literal">false</span>;
                    <span class="keyword">if</span> (--p === <span class="number">0</span>) done();
                    <span class="keyword">return</span>;
                }
                <span class="keyword">var</span> isTopLevel = self._isTopLevel(fakePath || file);
                <span class="keyword">var</span> current = {
                    id: file,
                    filename: file,
                    basedir: path.dirname(file),
                    paths: self.paths,
                    package: pkg,
                    inNodeModules: parent.inNodeModules || !isTopLevel
                };
                self.walk(id, current, <span class="function"><span class="keyword">function</span> <span class="params">(err, r)</span> {</span>
                    resolved[id] = r;
                    <span class="keyword">if</span> (--p === <span class="number">0</span>) done();
                });
            });
            <span class="keyword">if</span> (deps.length === <span class="number">0</span>) done();
        })();
        
        <span class="function"><span class="keyword">function</span> <span class="title">done</span> <span class="params">()</span> {</span>
            <span class="keyword">if</span> (!rec.id) rec.id = file;
            <span class="keyword">if</span> (!rec.source) rec.source = src;
            <span class="keyword">if</span> (!rec.deps) rec.deps = resolved;
            <span class="keyword">if</span> (!rec.file) rec.file = file;
            
            <span class="keyword">if</span> (self.entries.indexOf(file) >= <span class="number">0</span>) {
                rec.entry = <span class="literal">true</span>;
            }
            self.push(rec);
            
            <span class="keyword">if</span> (cb) cb(<span class="literal">null</span>, file);
            <span class="keyword">if</span> (-- self.pending === <span class="number">0</span>) self.push(<span class="literal">null</span>);
        }
    }
};

Deps.prototype.parseDeps = <span class="function"><span class="keyword">function</span> <span class="params">(file, src, cb)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">if</span> (<span class="keyword">this</span>.options.noParse === <span class="literal">true</span>) <span class="keyword">return</span> [];
    <span class="keyword">if</span> (<span class="regexp">/\.json$/</span>.test(file)) <span class="keyword">return</span> [];
    
    <span class="keyword">if</span> (Array.isArray(<span class="keyword">this</span>.options.noParse)
    &amp;&amp; <span class="keyword">this</span>.options.noParse.indexOf(file) >= <span class="number">0</span>) {
        <span class="keyword">return</span> [];
    }
    
    <span class="keyword">try</span> { <span class="keyword">var</span> deps = self.detective(src) }
    <span class="keyword">catch</span> (ex) {
        <span class="keyword">var</span> message = ex &amp;&amp; ex.message ? ex.message : ex;
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(
            <span class="string">'Parsing file '</span> + file + <span class="string">': '</span> + message
        );
    }
    <span class="keyword">return</span> deps;
};

Deps.prototype.lookupPackage = <span class="function"><span class="keyword">function</span> <span class="params">(file, cb)</span> {</span>
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    
    <span class="keyword">var</span> cached = <span class="keyword">this</span>.pkgCache[file];
    <span class="keyword">if</span> (cached) <span class="keyword">return</span> nextTick(cb, <span class="literal">null</span>, cached);
    <span class="keyword">if</span> (cached === <span class="literal">false</span>) <span class="keyword">return</span> nextTick(cb, <span class="literal">null</span>, <span class="literal">undefined</span>);
    
    <span class="keyword">var</span> dirs = parents(file ? path.dirname(file) : self.basedir);
    
    (<span class="function"><span class="keyword">function</span> <span class="title">next</span> <span class="params">()</span> {</span>
        <span class="keyword">if</span> (dirs.length === <span class="number">0</span>) {
            self.pkgCache[file] = <span class="literal">false</span>;
            <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">undefined</span>);
        }
        <span class="keyword">var</span> dir = dirs.shift();
        <span class="keyword">if</span> (dir.split(<span class="regexp">/[\\\/]/</span>).slice(-<span class="number">1</span>)[<span class="number">0</span>] === <span class="string">'node_modules'</span>) {
            <span class="keyword">return</span> cb(<span class="literal">null</span>, <span class="literal">undefined</span>);
        }
        
        <span class="keyword">var</span> pkgfile = path.join(dir, <span class="string">'package.json'</span>);
        
        <span class="keyword">var</span> cached = self.pkgCache[pkgfile];
        <span class="keyword">if</span> (cached) <span class="keyword">return</span> nextTick(cb, <span class="literal">null</span>, cached);
        <span class="keyword">else</span> <span class="keyword">if</span> (cached === <span class="literal">false</span>) <span class="keyword">return</span> next();
        
        <span class="keyword">var</span> pcached = self.pkgFileCachePending[pkgfile];
        <span class="keyword">if</span> (pcached) <span class="keyword">return</span> pcached.push(onpkg);
        pcached = self.pkgFileCachePending[pkgfile] = [];
        
        fs.readFile(pkgfile, <span class="function"><span class="keyword">function</span> <span class="params">(err, src)</span> {</span>
            <span class="keyword">if</span> (err) <span class="keyword">return</span> onpkg();
            <span class="keyword">try</span> { <span class="keyword">var</span> pkg = JSON.parse(src) }
            <span class="keyword">catch</span> (err) {
                <span class="keyword">return</span> onpkg(<span class="keyword">new</span> Error([
                    err + <span class="string">' while parsing json file '</span> + pkgfile
                ].join(<span class="string">''</span>)));
            }
            pkg.__dirname = dir;
            
            self.pkgCache[pkgfile] = pkg;
            self.pkgCache[file] = pkg;
            onpkg(<span class="literal">null</span>, pkg);
        });
        
        <span class="function"><span class="keyword">function</span> <span class="title">onpkg</span> <span class="params">(err, pkg)</span> {</span>
            <span class="keyword">if</span> (self.pkgFileCachePending[pkgfile]) {
                <span class="keyword">var</span> fns = self.pkgFileCachePending[pkgfile];
                <span class="keyword">delete</span> self.pkgFileCachePending[pkgfile];
                fns.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(f)</span> {</span> f(err, pkg) });
            }
            <span class="keyword">if</span> (err) cb(err);
            <span class="keyword">else</span> <span class="keyword">if</span> (pkg &amp;&amp; <span class="keyword">typeof</span> pkg === <span class="string">'object'</span>) cb(<span class="literal">null</span>, pkg);
            <span class="keyword">else</span> {
                self.pkgCache[pkgfile] = <span class="literal">false</span>;
                next();
            }
        }
    })();
};
 
<span class="function"><span class="keyword">function</span> <span class="title">getTransforms</span> <span class="params">(pkg, opts)</span> {</span>
    <span class="keyword">var</span> trx = [];
    <span class="keyword">if</span> (opts.transformKey) {
        <span class="keyword">var</span> n = pkg;
        <span class="keyword">var</span> keys = opts.transformKey;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) {
            <span class="keyword">if</span> (n &amp;&amp; <span class="keyword">typeof</span> n === <span class="string">'object'</span>) n = n[keys[i]];
            <span class="keyword">else</span> <span class="keyword">break</span>;
        }
        <span class="keyword">if</span> (i === keys.length) {
            trx = [].concat(n).filter(Boolean);
        }
    }
    <span class="keyword">return</span> trx.concat(opts.globalTransform || []);
}

<span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> <span class="params">(cb)</span> {</span>
    <span class="keyword">var</span> args = [].slice.call(arguments, <span class="number">1</span>);
    process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> cb.apply(<span class="literal">null</span>, args) });
}

<span class="function"><span class="keyword">function</span> <span class="title">xhas</span> <span class="params">(obj)</span> {</span>
    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arguments.length; i++) {
        <span class="keyword">var</span> key = arguments[i];
        <span class="keyword">if</span> (!has(obj, key)) <span class="keyword">return</span> <span class="literal">false</span>;
        obj = obj[key];
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">toStream</span> <span class="params">(dataAsString)</span> {</span>
    <span class="keyword">var</span> tr = through();
    tr.push(dataAsString);
    tr.push(<span class="literal">null</span>);
    <span class="keyword">return</span> tr;
}

<span class="function"><span class="keyword">function</span> <span class="title">has</span> <span class="params">(obj, key)</span> {</span>
    <span class="keyword">return</span> obj &amp;&amp; Object.prototype.hasOwnProperty.call(obj, key);
}

<span class="function"><span class="keyword">function</span> <span class="title">wrapTransform</span> <span class="params">(tr)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> tr.read === <span class="string">'function'</span>) <span class="keyword">return</span> tr;
    <span class="keyword">var</span> input = through(), output = through();
    input.pipe(tr).pipe(output);
    <span class="keyword">var</span> wrapper = duplexer(input, output);
    tr.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span> wrapper.emit(<span class="string">'error'</span>, err) });
    <span class="keyword">return</span> wrapper;
}
</code></pre>