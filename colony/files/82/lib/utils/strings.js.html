<h1>strings.js</h1>
<pre><code class="lang-js"><span class="comment">// String encode/decode helpers</span>
<span class="string">'use strict'</span>;


<span class="keyword">var</span> utils = require(<span class="string">'./common'</span>);


<span class="comment">// Quick check if we can use fast array to bin string conversion</span>
<span class="comment">//</span>
<span class="comment">// - apply(Array) can fail on Android 2.2</span>
<span class="comment">// - apply(Uint8Array) can fail on iOS 5.1 Safari</span>
<span class="comment">//</span>
<span class="keyword">var</span> STR_APPLY_OK = <span class="literal">true</span>;
<span class="keyword">var</span> STR_APPLY_UIA_OK = <span class="literal">true</span>;

<span class="keyword">try</span> { String.fromCharCode.apply(<span class="literal">null</span>, [ <span class="number">0</span> ]); } <span class="keyword">catch</span> (__) { STR_APPLY_OK = <span class="literal">false</span>; }
<span class="keyword">try</span> { String.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> Uint8Array(<span class="number">1</span>)); } <span class="keyword">catch</span> (__) { STR_APPLY_UIA_OK = <span class="literal">false</span>; }


<span class="comment">// Table with utf8 lengths (calculated by first byte of sequence)</span>
<span class="comment">// Note, that 5 &amp; 6-byte values and some 4-byte values can not be represented in JS,</span>
<span class="comment">// because max possible codepoint is 0x10ffff</span>
<span class="keyword">var</span> _utf8len = <span class="keyword">new</span> utils.Buf8(<span class="number">256</span>);
<span class="keyword">for</span> (<span class="keyword">var</span> q = <span class="number">0</span>; q &lt; <span class="number">256</span>; q++) {
  _utf8len[q] = (q >= <span class="number">252</span> ? <span class="number">6</span> : q >= <span class="number">248</span> ? <span class="number">5</span> : q >= <span class="number">240</span> ? <span class="number">4</span> : q >= <span class="number">224</span> ? <span class="number">3</span> : q >= <span class="number">192</span> ? <span class="number">2</span> : <span class="number">1</span>);
}
_utf8len[<span class="number">254</span>] = _utf8len[<span class="number">254</span>] = <span class="number">1</span>; <span class="comment">// Invalid sequence start</span>


<span class="comment">// convert string to array (typed, when possible)</span>
exports.string2buf = <span class="function"><span class="keyword">function</span> <span class="params">(str)</span> {</span>
  <span class="keyword">var</span> buf, c, c2, m_pos, i, str_len = str.length, buf_len = <span class="number">0</span>;

  <span class="comment">// count binary size</span>
  <span class="keyword">for</span> (m_pos = <span class="number">0</span>; m_pos &lt; str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    <span class="keyword">if</span> ((c &amp; <span class="number">0xfc00</span>) === <span class="number">0xd800</span> &amp;&amp; (m_pos + <span class="number">1</span> &lt; str_len)) {
      c2 = str.charCodeAt(m_pos + <span class="number">1</span>);
      <span class="keyword">if</span> ((c2 &amp; <span class="number">0xfc00</span>) === <span class="number">0xdc00</span>) {
        c = <span class="number">0x10000</span> + ((c - <span class="number">0xd800</span>) &lt;&lt; <span class="number">10</span>) + (c2 - <span class="number">0xdc00</span>);
        m_pos++;
      }
    }
    buf_len += c &lt; <span class="number">0x80</span> ? <span class="number">1</span> : c &lt; <span class="number">0x800</span> ? <span class="number">2</span> : c &lt; <span class="number">0x10000</span> ? <span class="number">3</span> : <span class="number">4</span>;
  }

  <span class="comment">// allocate buffer</span>
  buf = <span class="keyword">new</span> utils.Buf8(buf_len);

  <span class="comment">// convert</span>
  <span class="keyword">for</span> (i = <span class="number">0</span>, m_pos = <span class="number">0</span>; i &lt; buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    <span class="keyword">if</span> ((c &amp; <span class="number">0xfc00</span>) === <span class="number">0xd800</span> &amp;&amp; (m_pos + <span class="number">1</span> &lt; str_len)) {
      c2 = str.charCodeAt(m_pos + <span class="number">1</span>);
      <span class="keyword">if</span> ((c2 &amp; <span class="number">0xfc00</span>) === <span class="number">0xdc00</span>) {
        c = <span class="number">0x10000</span> + ((c - <span class="number">0xd800</span>) &lt;&lt; <span class="number">10</span>) + (c2 - <span class="number">0xdc00</span>);
        m_pos++;
      }
    }
    <span class="keyword">if</span> (c &lt; <span class="number">0x80</span>) {
      <span class="comment">/* one byte */</span>
      buf[i++] = c;
    } <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">0x800</span>) {
      <span class="comment">/* two bytes */</span>
      buf[i++] = <span class="number">0xC0</span> | (c >>> <span class="number">6</span>);
      buf[i++] = <span class="number">0x80</span> | (c &amp; <span class="number">0x3f</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="number">0x10000</span>) {
      <span class="comment">/* three bytes */</span>
      buf[i++] = <span class="number">0xE0</span> | (c >>> <span class="number">12</span>);
      buf[i++] = <span class="number">0x80</span> | (c >>> <span class="number">6</span> &amp; <span class="number">0x3f</span>);
      buf[i++] = <span class="number">0x80</span> | (c &amp; <span class="number">0x3f</span>);
    } <span class="keyword">else</span> {
      <span class="comment">/* four bytes */</span>
      buf[i++] = <span class="number">0xf0</span> | (c >>> <span class="number">18</span>);
      buf[i++] = <span class="number">0x80</span> | (c >>> <span class="number">12</span> &amp; <span class="number">0x3f</span>);
      buf[i++] = <span class="number">0x80</span> | (c >>> <span class="number">6</span> &amp; <span class="number">0x3f</span>);
      buf[i++] = <span class="number">0x80</span> | (c &amp; <span class="number">0x3f</span>);
    }
  }

  <span class="keyword">return</span> buf;
};

<span class="comment">// Helper (used in 2 places)</span>
<span class="function"><span class="keyword">function</span> <span class="title">buf2binstring</span><span class="params">(buf, len)</span> {</span>
  <span class="comment">// On Chrome, the arguments in a function call that are allowed is `65534`.</span>
  <span class="comment">// If the length of the buffer is smaller than that, we can use this optimization,</span>
  <span class="comment">// otherwise we will take a slower path.</span>
  <span class="keyword">if</span> (len &lt; <span class="number">65534</span>) {
    <span class="keyword">if</span> ((buf.subarray &amp;&amp; STR_APPLY_UIA_OK) || (!buf.subarray &amp;&amp; STR_APPLY_OK)) {
      <span class="keyword">return</span> String.fromCharCode.apply(<span class="literal">null</span>, utils.shrinkBuf(buf, len));
    }
  }

  <span class="keyword">var</span> result = <span class="string">''</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  <span class="keyword">return</span> result;
}


<span class="comment">// Convert byte array to binary string</span>
exports.buf2binstring = <span class="function"><span class="keyword">function</span> <span class="params">(buf)</span> {</span>
  <span class="keyword">return</span> buf2binstring(buf, buf.length);
};


<span class="comment">// Convert binary string (typed, when possible)</span>
exports.binstring2buf = <span class="function"><span class="keyword">function</span> <span class="params">(str)</span> {</span>
  <span class="keyword">var</span> buf = <span class="keyword">new</span> utils.Buf8(str.length);
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = buf.length; i &lt; len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  <span class="keyword">return</span> buf;
};


<span class="comment">// convert array to string</span>
exports.buf2string = <span class="function"><span class="keyword">function</span> <span class="params">(buf, max)</span> {</span>
  <span class="keyword">var</span> i, out, c, c_len;
  <span class="keyword">var</span> len = max || buf.length;

  <span class="comment">// Reserve max possible length (2 words per char)</span>
  <span class="comment">// NB: by unknown reasons, Array is significantly faster for</span>
  <span class="comment">//     String.fromCharCode.apply than Uint16Array.</span>
  <span class="keyword">var</span> utf16buf = <span class="keyword">new</span> Array(len * <span class="number">2</span>);

  <span class="keyword">for</span> (out = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; len;) {
    c = buf[i++];
    <span class="comment">// quick process ascii</span>
    <span class="keyword">if</span> (c &lt; <span class="number">0x80</span>) { utf16buf[out++] = c; <span class="keyword">continue</span>; }

    c_len = _utf8len[c];
    <span class="comment">// skip 5 &amp; 6 byte codes</span>
    <span class="keyword">if</span> (c_len > <span class="number">4</span>) { utf16buf[out++] = <span class="number">0xfffd</span>; i += c_len - <span class="number">1</span>; <span class="keyword">continue</span>; }

    <span class="comment">// apply mask on first byte</span>
    c &amp;= c_len === <span class="number">2</span> ? <span class="number">0x1f</span> : c_len === <span class="number">3</span> ? <span class="number">0x0f</span> : <span class="number">0x07</span>;
    <span class="comment">// join the rest</span>
    <span class="keyword">while</span> (c_len > <span class="number">1</span> &amp;&amp; i &lt; len) {
      c = (c &lt;&lt; <span class="number">6</span>) | (buf[i++] &amp; <span class="number">0x3f</span>);
      c_len--;
    }

    <span class="comment">// terminated by end of string?</span>
    <span class="keyword">if</span> (c_len > <span class="number">1</span>) { utf16buf[out++] = <span class="number">0xfffd</span>; <span class="keyword">continue</span>; }

    <span class="keyword">if</span> (c &lt; <span class="number">0x10000</span>) {
      utf16buf[out++] = c;
    } <span class="keyword">else</span> {
      c -= <span class="number">0x10000</span>;
      utf16buf[out++] = <span class="number">0xd800</span> | ((c >> <span class="number">10</span>) &amp; <span class="number">0x3ff</span>);
      utf16buf[out++] = <span class="number">0xdc00</span> | (c &amp; <span class="number">0x3ff</span>);
    }
  }

  <span class="keyword">return</span> buf2binstring(utf16buf, out);
};


<span class="comment">// Calculate max possible position in utf8 buffer,</span>
<span class="comment">// that will not break sequence. If that's not possible</span>
<span class="comment">// - (very small limits) return max size as is.</span>
<span class="comment">//</span>
<span class="comment">// buf[] - utf8 bytes array</span>
<span class="comment">// max   - length limit (mandatory);</span>
exports.utf8border = <span class="function"><span class="keyword">function</span> <span class="params">(buf, max)</span> {</span>
  <span class="keyword">var</span> pos;

  max = max || buf.length;
  <span class="keyword">if</span> (max > buf.length) { max = buf.length; }

  <span class="comment">// go back from last position, until start of sequence found</span>
  pos = max - <span class="number">1</span>;
  <span class="keyword">while</span> (pos >= <span class="number">0</span> &amp;&amp; (buf[pos] &amp; <span class="number">0xC0</span>) === <span class="number">0x80</span>) { pos--; }

  <span class="comment">// Very small and broken sequence,</span>
  <span class="comment">// return max, because we should return something anyway.</span>
  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) { <span class="keyword">return</span> max; }

  <span class="comment">// If we came to start of buffer - that means buffer is too small,</span>
  <span class="comment">// return max too.</span>
  <span class="keyword">if</span> (pos === <span class="number">0</span>) { <span class="keyword">return</span> max; }

  <span class="keyword">return</span> (pos + _utf8len[buf[pos]] > max) ? pos : max;
};
</code></pre>