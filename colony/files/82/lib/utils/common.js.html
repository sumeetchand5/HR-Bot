<h1>common.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;


<span class="keyword">var</span> TYPED_OK =  (<span class="keyword">typeof</span> Uint8Array !== <span class="string">'undefined'</span>) &amp;&amp;
                (<span class="keyword">typeof</span> Uint16Array !== <span class="string">'undefined'</span>) &amp;&amp;
                (<span class="keyword">typeof</span> Int32Array !== <span class="string">'undefined'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">_has</span><span class="params">(obj, key)</span> {</span>
  <span class="keyword">return</span> Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = <span class="function"><span class="keyword">function</span> <span class="params">(obj <span class="comment">/*from1, from2, from3, ...*/</span>)</span> {</span>
  <span class="keyword">var</span> sources = Array.prototype.slice.call(arguments, <span class="number">1</span>);
  <span class="keyword">while</span> (sources.length) {
    <span class="keyword">var</span> source = sources.shift();
    <span class="keyword">if</span> (!source) { <span class="keyword">continue</span>; }

    <span class="keyword">if</span> (<span class="keyword">typeof</span> source !== <span class="string">'object'</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(source + <span class="string">'must be non-object'</span>);
    }

    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> source) {
      <span class="keyword">if</span> (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  <span class="keyword">return</span> obj;
};


<span class="comment">// reduce buffer size, avoiding mem copy</span>
exports.shrinkBuf = <span class="function"><span class="keyword">function</span> <span class="params">(buf, size)</span> {</span>
  <span class="keyword">if</span> (buf.length === size) { <span class="keyword">return</span> buf; }
  <span class="keyword">if</span> (buf.subarray) { <span class="keyword">return</span> buf.subarray(<span class="number">0</span>, size); }
  buf.length = size;
  <span class="keyword">return</span> buf;
};


<span class="keyword">var</span> fnTyped = {
  arraySet: <span class="function"><span class="keyword">function</span> <span class="params">(dest, src, src_offs, len, dest_offs)</span> {</span>
    <span class="keyword">if</span> (src.subarray &amp;&amp; dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      <span class="keyword">return</span>;
    }
    <span class="comment">// Fallback to ordinary array</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  <span class="comment">// Join array of chunks to single array.</span>
  flattenChunks: <span class="function"><span class="keyword">function</span> <span class="params">(chunks)</span> {</span>
    <span class="keyword">var</span> i, l, len, pos, chunk, result;

    <span class="comment">// calculate data length</span>
    len = <span class="number">0</span>;
    <span class="keyword">for</span> (i = <span class="number">0</span>, l = chunks.length; i &lt; l; i++) {
      len += chunks[i].length;
    }

    <span class="comment">// join chunks</span>
    result = <span class="keyword">new</span> Uint8Array(len);
    pos = <span class="number">0</span>;
    <span class="keyword">for</span> (i = <span class="number">0</span>, l = chunks.length; i &lt; l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    <span class="keyword">return</span> result;
  }
};

<span class="keyword">var</span> fnUntyped = {
  arraySet: <span class="function"><span class="keyword">function</span> <span class="params">(dest, src, src_offs, len, dest_offs)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  <span class="comment">// Join array of chunks to single array.</span>
  flattenChunks: <span class="function"><span class="keyword">function</span> <span class="params">(chunks)</span> {</span>
    <span class="keyword">return</span> [].concat.apply([], chunks);
  }
};


<span class="comment">// Enable/Disable typed arrays use, for testing</span>
<span class="comment">//</span>
exports.setTyped = <span class="function"><span class="keyword">function</span> <span class="params">(on)</span> {</span>
  <span class="keyword">if</span> (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } <span class="keyword">else</span> {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);
</code></pre>