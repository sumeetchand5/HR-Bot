<h1>pako/lib/zlib/deflate.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="comment">// (C) 1995-2013 Jean-loup Gailly and Mark Adler</span>
<span class="comment">// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin</span>
<span class="comment">//</span>
<span class="comment">// This software is provided 'as-is', without any express or implied</span>
<span class="comment">// warranty. In no event will the authors be held liable for any damages</span>
<span class="comment">// arising from the use of this software.</span>
<span class="comment">//</span>
<span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<span class="comment">// including commercial applications, and to alter it and redistribute it</span>
<span class="comment">// freely, subject to the following restrictions:</span>
<span class="comment">//</span>
<span class="comment">// 1. The origin of this software must not be misrepresented; you must not</span>
<span class="comment">//   claim that you wrote the original software. If you use this software</span>
<span class="comment">//   in a product, an acknowledgment in the product documentation would be</span>
<span class="comment">//   appreciated but is not required.</span>
<span class="comment">// 2. Altered source versions must be plainly marked as such, and must not be</span>
<span class="comment">//   misrepresented as being the original software.</span>
<span class="comment">// 3. This notice may not be removed or altered from any source distribution.</span>

<span class="keyword">var</span> utils   = require(<span class="string">'../utils/common'</span>);
<span class="keyword">var</span> trees   = require(<span class="string">'./trees'</span>);
<span class="keyword">var</span> adler32 = require(<span class="string">'./adler32'</span>);
<span class="keyword">var</span> crc32   = require(<span class="string">'./crc32'</span>);
<span class="keyword">var</span> msg     = require(<span class="string">'./messages'</span>);

<span class="comment">/* Public constants ==========================================================*/</span>
<span class="comment">/* ===========================================================================*/</span>


<span class="comment">/* Allowed flush values; see deflate() and inflate() below for details */</span>
<span class="keyword">var</span> Z_NO_FLUSH      = <span class="number">0</span>;
<span class="keyword">var</span> Z_PARTIAL_FLUSH = <span class="number">1</span>;
<span class="comment">//var Z_SYNC_FLUSH    = 2;</span>
<span class="keyword">var</span> Z_FULL_FLUSH    = <span class="number">3</span>;
<span class="keyword">var</span> Z_FINISH        = <span class="number">4</span>;
<span class="keyword">var</span> Z_BLOCK         = <span class="number">5</span>;
<span class="comment">//var Z_TREES         = 6;</span>


<span class="comment">/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */</span>
<span class="keyword">var</span> Z_OK            = <span class="number">0</span>;
<span class="keyword">var</span> Z_STREAM_END    = <span class="number">1</span>;
<span class="comment">//var Z_NEED_DICT     = 2;</span>
<span class="comment">//var Z_ERRNO         = -1;</span>
<span class="keyword">var</span> Z_STREAM_ERROR  = -<span class="number">2</span>;
<span class="keyword">var</span> Z_DATA_ERROR    = -<span class="number">3</span>;
<span class="comment">//var Z_MEM_ERROR     = -4;</span>
<span class="keyword">var</span> Z_BUF_ERROR     = -<span class="number">5</span>;
<span class="comment">//var Z_VERSION_ERROR = -6;</span>


<span class="comment">/* compression levels */</span>
<span class="comment">//var Z_NO_COMPRESSION      = 0;</span>
<span class="comment">//var Z_BEST_SPEED          = 1;</span>
<span class="comment">//var Z_BEST_COMPRESSION    = 9;</span>
<span class="keyword">var</span> Z_DEFAULT_COMPRESSION = -<span class="number">1</span>;


<span class="keyword">var</span> Z_FILTERED            = <span class="number">1</span>;
<span class="keyword">var</span> Z_HUFFMAN_ONLY        = <span class="number">2</span>;
<span class="keyword">var</span> Z_RLE                 = <span class="number">3</span>;
<span class="keyword">var</span> Z_FIXED               = <span class="number">4</span>;
<span class="keyword">var</span> Z_DEFAULT_STRATEGY    = <span class="number">0</span>;

<span class="comment">/* Possible values of the data_type field (though see inflate()) */</span>
<span class="comment">//var Z_BINARY              = 0;</span>
<span class="comment">//var Z_TEXT                = 1;</span>
<span class="comment">//var Z_ASCII               = 1; // = Z_TEXT</span>
<span class="keyword">var</span> Z_UNKNOWN             = <span class="number">2</span>;


<span class="comment">/* The deflate compression method */</span>
<span class="keyword">var</span> Z_DEFLATED  = <span class="number">8</span>;

<span class="comment">/*============================================================================*/</span>


<span class="keyword">var</span> MAX_MEM_LEVEL = <span class="number">9</span>;
<span class="comment">/* Maximum value for memLevel in deflateInit2 */</span>
<span class="keyword">var</span> MAX_WBITS = <span class="number">15</span>;
<span class="comment">/* 32K LZ77 window */</span>
<span class="keyword">var</span> DEF_MEM_LEVEL = <span class="number">8</span>;


<span class="keyword">var</span> LENGTH_CODES  = <span class="number">29</span>;
<span class="comment">/* number of length codes, not counting the special END_BLOCK code */</span>
<span class="keyword">var</span> LITERALS      = <span class="number">256</span>;
<span class="comment">/* number of literal bytes 0..255 */</span>
<span class="keyword">var</span> L_CODES       = LITERALS + <span class="number">1</span> + LENGTH_CODES;
<span class="comment">/* number of Literal or Length codes, including the END_BLOCK code */</span>
<span class="keyword">var</span> D_CODES       = <span class="number">30</span>;
<span class="comment">/* number of distance codes */</span>
<span class="keyword">var</span> BL_CODES      = <span class="number">19</span>;
<span class="comment">/* number of codes used to transfer the bit lengths */</span>
<span class="keyword">var</span> HEAP_SIZE     = <span class="number">2</span> * L_CODES + <span class="number">1</span>;
<span class="comment">/* maximum heap size */</span>
<span class="keyword">var</span> MAX_BITS  = <span class="number">15</span>;
<span class="comment">/* All codes must not exceed MAX_BITS bits */</span>

<span class="keyword">var</span> MIN_MATCH = <span class="number">3</span>;
<span class="keyword">var</span> MAX_MATCH = <span class="number">258</span>;
<span class="keyword">var</span> MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + <span class="number">1</span>);

<span class="keyword">var</span> PRESET_DICT = <span class="number">0x20</span>;

<span class="keyword">var</span> INIT_STATE = <span class="number">42</span>;
<span class="keyword">var</span> EXTRA_STATE = <span class="number">69</span>;
<span class="keyword">var</span> NAME_STATE = <span class="number">73</span>;
<span class="keyword">var</span> COMMENT_STATE = <span class="number">91</span>;
<span class="keyword">var</span> HCRC_STATE = <span class="number">103</span>;
<span class="keyword">var</span> BUSY_STATE = <span class="number">113</span>;
<span class="keyword">var</span> FINISH_STATE = <span class="number">666</span>;

<span class="keyword">var</span> BS_NEED_MORE      = <span class="number">1</span>; <span class="comment">/* block not completed, need more input or more output */</span>
<span class="keyword">var</span> BS_BLOCK_DONE     = <span class="number">2</span>; <span class="comment">/* block flush performed */</span>
<span class="keyword">var</span> BS_FINISH_STARTED = <span class="number">3</span>; <span class="comment">/* finish started, need only more output at next deflate */</span>
<span class="keyword">var</span> BS_FINISH_DONE    = <span class="number">4</span>; <span class="comment">/* finish done, accept no more input or output */</span>

<span class="keyword">var</span> OS_CODE = <span class="number">0x03</span>; <span class="comment">// Unix :) . Don't detect, use this default.</span>

<span class="function"><span class="keyword">function</span> <span class="title">err</span><span class="params">(strm, errorCode)</span> {</span>
  strm.msg = msg[errorCode];
  <span class="keyword">return</span> errorCode;
}

<span class="function"><span class="keyword">function</span> <span class="title">rank</span><span class="params">(f)</span> {</span>
  <span class="keyword">return</span> ((f) &lt;&lt; <span class="number">1</span>) - ((f) > <span class="number">4</span> ? <span class="number">9</span> : <span class="number">0</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">zero</span><span class="params">(buf)</span> {</span> <span class="keyword">var</span> len = buf.length; <span class="keyword">while</span> (--len >= <span class="number">0</span>) { buf[len] = <span class="number">0</span>; } }


<span class="comment">/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">flush_pending</span><span class="params">(strm)</span> {</span>
  <span class="keyword">var</span> s = strm.state;

  <span class="comment">//_tr_flush_bits(s);</span>
  <span class="keyword">var</span> len = s.pending;
  <span class="keyword">if</span> (len > strm.avail_out) {
    len = strm.avail_out;
  }
  <span class="keyword">if</span> (len === <span class="number">0</span>) { <span class="keyword">return</span>; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  <span class="keyword">if</span> (s.pending === <span class="number">0</span>) {
    s.pending_out = <span class="number">0</span>;
  }
}


<span class="function"><span class="keyword">function</span> <span class="title">flush_block_only</span><span class="params">(s, last)</span> {</span>
  trees._tr_flush_block(s, (s.block_start >= <span class="number">0</span> ? s.block_start : -<span class="number">1</span>), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


<span class="function"><span class="keyword">function</span> <span class="title">put_byte</span><span class="params">(s, b)</span> {</span>
  s.pending_buf[s.pending++] = b;
}


<span class="comment">/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">putShortMSB</span><span class="params">(s, b)</span> {</span>
<span class="comment">//  put_byte(s, (Byte)(b >> 8));</span>
<span class="comment">//  put_byte(s, (Byte)(b &amp; 0xff));</span>
  s.pending_buf[s.pending++] = (b >>> <span class="number">8</span>) &amp; <span class="number">0xff</span>;
  s.pending_buf[s.pending++] = b &amp; <span class="number">0xff</span>;
}


<span class="comment">/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">read_buf</span><span class="params">(strm, buf, start, size)</span> {</span>
  <span class="keyword">var</span> len = strm.avail_in;

  <span class="keyword">if</span> (len > size) { len = size; }
  <span class="keyword">if</span> (len === <span class="number">0</span>) { <span class="keyword">return</span> <span class="number">0</span>; }

  strm.avail_in -= len;

  <span class="comment">// zmemcpy(buf, strm->next_in, len);</span>
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  <span class="keyword">if</span> (strm.state.wrap === <span class="number">1</span>) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  <span class="keyword">else</span> <span class="keyword">if</span> (strm.state.wrap === <span class="number">2</span>) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  <span class="keyword">return</span> len;
}


<span class="comment">/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">longest_match</span><span class="params">(s, cur_match)</span> {</span>
  <span class="keyword">var</span> chain_length = s.max_chain_length;      <span class="comment">/* max hash chain length */</span>
  <span class="keyword">var</span> scan = s.strstart; <span class="comment">/* current string */</span>
  <span class="keyword">var</span> match;                       <span class="comment">/* matched string */</span>
  <span class="keyword">var</span> len;                           <span class="comment">/* length of current match */</span>
  <span class="keyword">var</span> best_len = s.prev_length;              <span class="comment">/* best match length so far */</span>
  <span class="keyword">var</span> nice_match = s.nice_match;             <span class="comment">/* stop if match long enough */</span>
  <span class="keyword">var</span> limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : <span class="number">0</span><span class="comment">/*NIL*/</span>;

  <span class="keyword">var</span> _win = s.window; <span class="comment">// shortcut</span>

  <span class="keyword">var</span> wmask = s.w_mask;
  <span class="keyword">var</span> prev  = s.prev;

  <span class="comment">/* Stop when cur_match becomes &lt;= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */</span>

  <span class="keyword">var</span> strend = s.strstart + MAX_MATCH;
  <span class="keyword">var</span> scan_end1  = _win[scan + best_len - <span class="number">1</span>];
  <span class="keyword">var</span> scan_end   = _win[scan + best_len];

  <span class="comment">/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */</span>
  <span class="comment">// Assert(s->hash_bits >= 8 &amp;&amp; MAX_MATCH == 258, "Code too clever");</span>

  <span class="comment">/* Do not waste too much time if we already have a good match: */</span>
  <span class="keyword">if</span> (s.prev_length >= s.good_match) {
    chain_length >>= <span class="number">2</span>;
  }
  <span class="comment">/* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */</span>
  <span class="keyword">if</span> (nice_match > s.lookahead) { nice_match = s.lookahead; }

  <span class="comment">// Assert((ulg)s->strstart &lt;= s->window_size-MIN_LOOKAHEAD, "need lookahead");</span>

  <span class="keyword">do</span> {
    <span class="comment">// Assert(cur_match &lt; s->strstart, "no future");</span>
    match = cur_match;

    <span class="comment">/* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */</span>

    <span class="keyword">if</span> (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - <span class="number">1</span>] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + <span class="number">1</span>]) {
      <span class="keyword">continue</span>;
    }

    <span class="comment">/* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */</span>
    scan += <span class="number">2</span>;
    match++;
    <span class="comment">// Assert(*scan == *match, "match[2]?");</span>

    <span class="comment">/* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */</span>
    <span class="keyword">do</span> {
      <span class="comment">/*jshint noempty:false*/</span>
    } <span class="keyword">while</span> (_win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             _win[++scan] === _win[++match] &amp;&amp; _win[++scan] === _win[++match] &amp;&amp;
             scan &lt; strend);

    <span class="comment">// Assert(scan &lt;= s->window+(unsigned)(s->window_size-1), "wild scan");</span>

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    <span class="keyword">if</span> (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      <span class="keyword">if</span> (len >= nice_match) {
        <span class="keyword">break</span>;
      }
      scan_end1  = _win[scan + best_len - <span class="number">1</span>];
      scan_end   = _win[scan + best_len];
    }
  } <span class="keyword">while</span> ((cur_match = prev[cur_match &amp; wmask]) > limit &amp;&amp; --chain_length !== <span class="number">0</span>);

  <span class="keyword">if</span> (best_len &lt;= s.lookahead) {
    <span class="keyword">return</span> best_len;
  }
  <span class="keyword">return</span> s.lookahead;
}


<span class="comment">/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead &lt; MIN_LOOKAHEAD
 * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">fill_window</span><span class="params">(s)</span> {</span>
  <span class="keyword">var</span> _w_size = s.w_size;
  <span class="keyword">var</span> p, n, m, more, str;

  <span class="comment">//Assert(s->lookahead &lt; MIN_LOOKAHEAD, "already enough lookahead");</span>

  <span class="keyword">do</span> {
    more = s.window_size - s.lookahead - s.strstart;

    <span class="comment">// JS ints have 32 bit, block below not needed</span>
    <span class="comment">/* Deal with !@#$% 64K limit: */</span>
    <span class="comment">//if (sizeof(int) &lt;= 2) {</span>
    <span class="comment">//    if (more == 0 &amp;&amp; s->strstart == 0 &amp;&amp; s->lookahead == 0) {</span>
    <span class="comment">//        more = wsize;</span>
    <span class="comment">//</span>
    <span class="comment">//  } else if (more == (unsigned)(-1)) {</span>
    <span class="comment">//        /* Very unlikely, but possible on 16 bit machine if</span>
    <span class="comment">//         * strstart == 0 &amp;&amp; lookahead == 1 (input done a byte at time)</span>
    <span class="comment">//         */</span>
    <span class="comment">//        more--;</span>
    <span class="comment">//    }</span>
    <span class="comment">//}</span>


    <span class="comment">/* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */</span>
    <span class="keyword">if</span> (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, <span class="number">0</span>);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      <span class="comment">/* we now have strstart >= MAX_DIST */</span>
      s.block_start -= _w_size;

      <span class="comment">/* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */</span>

      n = s.hash_size;
      p = n;
      <span class="keyword">do</span> {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : <span class="number">0</span>);
      } <span class="keyword">while</span> (--n);

      n = _w_size;
      p = n;
      <span class="keyword">do</span> {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : <span class="number">0</span>);
        <span class="comment">/* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */</span>
      } <span class="keyword">while</span> (--n);

      more += _w_size;
    }
    <span class="keyword">if</span> (s.strm.avail_in === <span class="number">0</span>) {
      <span class="keyword">break</span>;
    }

    <span class="comment">/* If there was no sliding:
     *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;
     *   strstart + s->lookahead &lt;= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */</span>
    <span class="comment">//Assert(more >= 2, "more &lt; 2");</span>
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    <span class="comment">/* Initialize the hash value now that we have some input: */</span>
    <span class="keyword">if</span> (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      <span class="comment">/* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */</span>
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + <span class="number">1</span>]) &amp; s.hash_mask;
<span class="comment">//#if MIN_MATCH != 3</span>
<span class="comment">//        Call update_hash() MIN_MATCH-3 more times</span>
<span class="comment">//#endif</span>
      <span class="keyword">while</span> (s.insert) {
        <span class="comment">/* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */</span>
        s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + MIN_MATCH - <span class="number">1</span>]) &amp; s.hash_mask;

        s.prev[str &amp; s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        <span class="keyword">if</span> (s.lookahead + s.insert &lt; MIN_MATCH) {
          <span class="keyword">break</span>;
        }
      }
    }
    <span class="comment">/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */</span>

  } <span class="keyword">while</span> (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; s.strm.avail_in !== <span class="number">0</span>);

  <span class="comment">/* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */</span>
<span class="comment">//  if (s.high_water &lt; s.window_size) {</span>
<span class="comment">//    var curr = s.strstart + s.lookahead;</span>
<span class="comment">//    var init = 0;</span>
<span class="comment">//</span>
<span class="comment">//    if (s.high_water &lt; curr) {</span>
<span class="comment">//      /* Previous high water mark below current data -- zero WIN_INIT</span>
<span class="comment">//       * bytes or up to end of window, whichever is less.</span>
<span class="comment">//       */</span>
<span class="comment">//      init = s.window_size - curr;</span>
<span class="comment">//      if (init > WIN_INIT)</span>
<span class="comment">//        init = WIN_INIT;</span>
<span class="comment">//      zmemzero(s->window + curr, (unsigned)init);</span>
<span class="comment">//      s->high_water = curr + init;</span>
<span class="comment">//    }</span>
<span class="comment">//    else if (s->high_water &lt; (ulg)curr + WIN_INIT) {</span>
<span class="comment">//      /* High water mark at or above current data, but below current data</span>
<span class="comment">//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up</span>
<span class="comment">//       * to end of window, whichever is less.</span>
<span class="comment">//       */</span>
<span class="comment">//      init = (ulg)curr + WIN_INIT - s->high_water;</span>
<span class="comment">//      if (init > s->window_size - s->high_water)</span>
<span class="comment">//        init = s->window_size - s->high_water;</span>
<span class="comment">//      zmemzero(s->window + s->high_water, (unsigned)init);</span>
<span class="comment">//      s->high_water += init;</span>
<span class="comment">//    }</span>
<span class="comment">//  }</span>
<span class="comment">//</span>
<span class="comment">//  Assert((ulg)s->strstart &lt;= s->window_size - MIN_LOOKAHEAD,</span>
<span class="comment">//    "not enough room for search");</span>
}

<span class="comment">/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflate_stored</span><span class="params">(s, flush)</span> {</span>
  <span class="comment">/* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */</span>
  <span class="keyword">var</span> max_block_size = <span class="number">0xffff</span>;

  <span class="keyword">if</span> (max_block_size > s.pending_buf_size - <span class="number">5</span>) {
    max_block_size = s.pending_buf_size - <span class="number">5</span>;
  }

  <span class="comment">/* Copy as much as possible from input to output: */</span>
  <span class="keyword">for</span> (;;) {
    <span class="comment">/* Fill the window as much as possible: */</span>
    <span class="keyword">if</span> (s.lookahead &lt;= <span class="number">1</span>) {

      <span class="comment">//Assert(s->strstart &lt; s->w_size+MAX_DIST(s) ||</span>
      <span class="comment">//  s->block_start >= (long)s->w_size, "slide too late");</span>
<span class="comment">//      if (!(s.strstart &lt; s.w_size + (s.w_size - MIN_LOOKAHEAD) ||</span>
<span class="comment">//        s.block_start >= s.w_size)) {</span>
<span class="comment">//        throw  new Error("slide too late");</span>
<span class="comment">//      }</span>

      fill_window(s);
      <span class="keyword">if</span> (s.lookahead === <span class="number">0</span> &amp;&amp; flush === Z_NO_FLUSH) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }

      <span class="keyword">if</span> (s.lookahead === <span class="number">0</span>) {
        <span class="keyword">break</span>;
      }
      <span class="comment">/* flush the current block */</span>
    }
    <span class="comment">//Assert(s->block_start >= 0L, "block gone");</span>
<span class="comment">//    if (s.block_start &lt; 0) throw new Error("block gone");</span>

    s.strstart += s.lookahead;
    s.lookahead = <span class="number">0</span>;

    <span class="comment">/* Emit a stored block if pending_buf will be full: */</span>
    <span class="keyword">var</span> max_start = s.block_start + max_block_size;

    <span class="keyword">if</span> (s.strstart === <span class="number">0</span> || s.strstart >= max_start) {
      <span class="comment">/* strstart == 0 is possible when wraparound on 16-bit machine */</span>
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
      flush_block_only(s, <span class="literal">false</span>);
      <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="comment">/***/</span>


    }
    <span class="comment">/* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */</span>
    <span class="keyword">if</span> (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
      flush_block_only(s, <span class="literal">false</span>);
      <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="comment">/***/</span>
    }
  }

  s.insert = <span class="number">0</span>;

  <span class="keyword">if</span> (flush === Z_FINISH) {
    <span class="comment">/*** FLUSH_BLOCK(s, 1); ***/</span>
    flush_block_only(s, <span class="literal">true</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_FINISH_STARTED;
    }
    <span class="comment">/***/</span>
    <span class="keyword">return</span> BS_FINISH_DONE;
  }

  <span class="keyword">if</span> (s.strstart > s.block_start) {
    <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
    flush_block_only(s, <span class="literal">false</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_NEED_MORE;
    }
    <span class="comment">/***/</span>
  }

  <span class="keyword">return</span> BS_NEED_MORE;
}

<span class="comment">/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflate_fast</span><span class="params">(s, flush)</span> {</span>
  <span class="keyword">var</span> hash_head;        <span class="comment">/* head of the hash chain */</span>
  <span class="keyword">var</span> bflush;           <span class="comment">/* set if current block must be flushed */</span>

  <span class="keyword">for</span> (;;) {
    <span class="comment">/* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */</span>
    <span class="keyword">if</span> (s.lookahead &lt; MIN_LOOKAHEAD) {
      fill_window(s);
      <span class="keyword">if</span> (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush === Z_NO_FLUSH) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="keyword">if</span> (s.lookahead === <span class="number">0</span>) {
        <span class="keyword">break</span>; <span class="comment">/* flush the current block */</span>
      }
    }

    <span class="comment">/* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */</span>
    hash_head = <span class="number">0</span><span class="comment">/*NIL*/</span>;
    <span class="keyword">if</span> (s.lookahead >= MIN_MATCH) {
      <span class="comment">/*** INSERT_STRING(s, s.strstart, hash_head); ***/</span>
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - <span class="number">1</span>]) &amp; s.hash_mask;
      hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      <span class="comment">/***/</span>
    }

    <span class="comment">/* Find the longest match, discarding those &lt;= prev_length.
     * At this point we have always match_length &lt; MIN_MATCH
     */</span>
    <span class="keyword">if</span> (hash_head !== <span class="number">0</span><span class="comment">/*NIL*/</span> &amp;&amp; ((s.strstart - hash_head) &lt;= (s.w_size - MIN_LOOKAHEAD))) {
      <span class="comment">/* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */</span>
      s.match_length = longest_match(s, hash_head);
      <span class="comment">/* longest_match() sets match_start */</span>
    }
    <span class="keyword">if</span> (s.match_length >= MIN_MATCH) {
      <span class="comment">// check_match(s, s.strstart, s.match_start, s.match_length); // for debug only</span>

      <span class="comment">/*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/</span>
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      <span class="comment">/* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */</span>
      <span class="keyword">if</span> (s.match_length &lt;= s.max_lazy_match<span class="comment">/*max_insert_length*/</span> &amp;&amp; s.lookahead >= MIN_MATCH) {
        s.match_length--; <span class="comment">/* string at strstart already in table */</span>
        <span class="keyword">do</span> {
          s.strstart++;
          <span class="comment">/*** INSERT_STRING(s, s.strstart, hash_head); ***/</span>
          s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - <span class="number">1</span>]) &amp; s.hash_mask;
          hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          <span class="comment">/***/</span>
          <span class="comment">/* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */</span>
        } <span class="keyword">while</span> (--s.match_length !== <span class="number">0</span>);
        s.strstart++;
      } <span class="keyword">else</span>
      {
        s.strstart += s.match_length;
        s.match_length = <span class="number">0</span>;
        s.ins_h = s.window[s.strstart];
        <span class="comment">/* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */</span>
        s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + <span class="number">1</span>]) &amp; s.hash_mask;

<span class="comment">//#if MIN_MATCH != 3</span>
<span class="comment">//                Call UPDATE_HASH() MIN_MATCH-3 more times</span>
<span class="comment">//#endif</span>
        <span class="comment">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */</span>
      }
    } <span class="keyword">else</span> {
      <span class="comment">/* No match, output a literal byte */</span>
      <span class="comment">//Tracevv((stderr,"%c", s.window[s.strstart]));</span>
      <span class="comment">/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/</span>
      bflush = trees._tr_tally(s, <span class="number">0</span>, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    <span class="keyword">if</span> (bflush) {
      <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
      flush_block_only(s, <span class="literal">false</span>);
      <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="comment">/***/</span>
    }
  }
  s.insert = ((s.strstart &lt; (MIN_MATCH - <span class="number">1</span>)) ? s.strstart : MIN_MATCH - <span class="number">1</span>);
  <span class="keyword">if</span> (flush === Z_FINISH) {
    <span class="comment">/*** FLUSH_BLOCK(s, 1); ***/</span>
    flush_block_only(s, <span class="literal">true</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_FINISH_STARTED;
    }
    <span class="comment">/***/</span>
    <span class="keyword">return</span> BS_FINISH_DONE;
  }
  <span class="keyword">if</span> (s.last_lit) {
    <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
    flush_block_only(s, <span class="literal">false</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_NEED_MORE;
    }
    <span class="comment">/***/</span>
  }
  <span class="keyword">return</span> BS_BLOCK_DONE;
}

<span class="comment">/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflate_slow</span><span class="params">(s, flush)</span> {</span>
  <span class="keyword">var</span> hash_head;          <span class="comment">/* head of hash chain */</span>
  <span class="keyword">var</span> bflush;              <span class="comment">/* set if current block must be flushed */</span>

  <span class="keyword">var</span> max_insert;

  <span class="comment">/* Process the input block. */</span>
  <span class="keyword">for</span> (;;) {
    <span class="comment">/* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */</span>
    <span class="keyword">if</span> (s.lookahead &lt; MIN_LOOKAHEAD) {
      fill_window(s);
      <span class="keyword">if</span> (s.lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush === Z_NO_FLUSH) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="keyword">if</span> (s.lookahead === <span class="number">0</span>) { <span class="keyword">break</span>; } <span class="comment">/* flush the current block */</span>
    }

    <span class="comment">/* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */</span>
    hash_head = <span class="number">0</span><span class="comment">/*NIL*/</span>;
    <span class="keyword">if</span> (s.lookahead >= MIN_MATCH) {
      <span class="comment">/*** INSERT_STRING(s, s.strstart, hash_head); ***/</span>
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - <span class="number">1</span>]) &amp; s.hash_mask;
      hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      <span class="comment">/***/</span>
    }

    <span class="comment">/* Find the longest match, discarding those &lt;= prev_length.
     */</span>
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - <span class="number">1</span>;

    <span class="keyword">if</span> (hash_head !== <span class="number">0</span><span class="comment">/*NIL*/</span> &amp;&amp; s.prev_length &lt; s.max_lazy_match &amp;&amp;
        s.strstart - hash_head &lt;= (s.w_size - MIN_LOOKAHEAD)<span class="comment">/*MAX_DIST(s)*/</span>) {
      <span class="comment">/* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */</span>
      s.match_length = longest_match(s, hash_head);
      <span class="comment">/* longest_match() sets match_start */</span>

      <span class="keyword">if</span> (s.match_length &lt;= <span class="number">5</span> &amp;&amp;
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH &amp;&amp; s.strstart - s.match_start > <span class="number">4096</span><span class="comment">/*TOO_FAR*/</span>))) {

        <span class="comment">/* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */</span>
        s.match_length = MIN_MATCH - <span class="number">1</span>;
      }
    }
    <span class="comment">/* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */</span>
    <span class="keyword">if</span> (s.prev_length >= MIN_MATCH &amp;&amp; s.match_length &lt;= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      <span class="comment">/* Do not insert strings in hash table beyond this. */</span>

      <span class="comment">//check_match(s, s.strstart-1, s.prev_match, s.prev_length);</span>

      <span class="comment">/***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/</span>
      bflush = trees._tr_tally(s, s.strstart - <span class="number">1</span> - s.prev_match, s.prev_length - MIN_MATCH);
      <span class="comment">/* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */</span>
      s.lookahead -= s.prev_length - <span class="number">1</span>;
      s.prev_length -= <span class="number">2</span>;
      <span class="keyword">do</span> {
        <span class="keyword">if</span> (++s.strstart &lt;= max_insert) {
          <span class="comment">/*** INSERT_STRING(s, s.strstart, hash_head); ***/</span>
          s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - <span class="number">1</span>]) &amp; s.hash_mask;
          hash_head = s.prev[s.strstart &amp; s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          <span class="comment">/***/</span>
        }
      } <span class="keyword">while</span> (--s.prev_length !== <span class="number">0</span>);
      s.match_available = <span class="number">0</span>;
      s.match_length = MIN_MATCH - <span class="number">1</span>;
      s.strstart++;

      <span class="keyword">if</span> (bflush) {
        <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
        flush_block_only(s, <span class="literal">false</span>);
        <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
          <span class="keyword">return</span> BS_NEED_MORE;
        }
        <span class="comment">/***/</span>
      }

    } <span class="keyword">else</span> <span class="keyword">if</span> (s.match_available) {
      <span class="comment">/* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */</span>
      <span class="comment">//Tracevv((stderr,"%c", s->window[s->strstart-1]));</span>
      <span class="comment">/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/</span>
      bflush = trees._tr_tally(s, <span class="number">0</span>, s.window[s.strstart - <span class="number">1</span>]);

      <span class="keyword">if</span> (bflush) {
        <span class="comment">/*** FLUSH_BLOCK_ONLY(s, 0) ***/</span>
        flush_block_only(s, <span class="literal">false</span>);
        <span class="comment">/***/</span>
      }
      s.strstart++;
      s.lookahead--;
      <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
    } <span class="keyword">else</span> {
      <span class="comment">/* There is no previous match to compare with, wait for
       * the next step to decide.
       */</span>
      s.match_available = <span class="number">1</span>;
      s.strstart++;
      s.lookahead--;
    }
  }
  <span class="comment">//Assert (flush != Z_NO_FLUSH, "no flush?");</span>
  <span class="keyword">if</span> (s.match_available) {
    <span class="comment">//Tracevv((stderr,"%c", s->window[s->strstart-1]));</span>
    <span class="comment">/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/</span>
    bflush = trees._tr_tally(s, <span class="number">0</span>, s.window[s.strstart - <span class="number">1</span>]);

    s.match_available = <span class="number">0</span>;
  }
  s.insert = s.strstart &lt; MIN_MATCH - <span class="number">1</span> ? s.strstart : MIN_MATCH - <span class="number">1</span>;
  <span class="keyword">if</span> (flush === Z_FINISH) {
    <span class="comment">/*** FLUSH_BLOCK(s, 1); ***/</span>
    flush_block_only(s, <span class="literal">true</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_FINISH_STARTED;
    }
    <span class="comment">/***/</span>
    <span class="keyword">return</span> BS_FINISH_DONE;
  }
  <span class="keyword">if</span> (s.last_lit) {
    <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
    flush_block_only(s, <span class="literal">false</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_NEED_MORE;
    }
    <span class="comment">/***/</span>
  }

  <span class="keyword">return</span> BS_BLOCK_DONE;
}


<span class="comment">/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflate_rle</span><span class="params">(s, flush)</span> {</span>
  <span class="keyword">var</span> bflush;            <span class="comment">/* set if current block must be flushed */</span>
  <span class="keyword">var</span> prev;              <span class="comment">/* byte at distance one to match */</span>
  <span class="keyword">var</span> scan, strend;      <span class="comment">/* scan goes up to strend for length of run */</span>

  <span class="keyword">var</span> _win = s.window;

  <span class="keyword">for</span> (;;) {
    <span class="comment">/* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */</span>
    <span class="keyword">if</span> (s.lookahead &lt;= MAX_MATCH) {
      fill_window(s);
      <span class="keyword">if</span> (s.lookahead &lt;= MAX_MATCH &amp;&amp; flush === Z_NO_FLUSH) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="keyword">if</span> (s.lookahead === <span class="number">0</span>) { <span class="keyword">break</span>; } <span class="comment">/* flush the current block */</span>
    }

    <span class="comment">/* See how many times the previous byte repeats */</span>
    s.match_length = <span class="number">0</span>;
    <span class="keyword">if</span> (s.lookahead >= MIN_MATCH &amp;&amp; s.strstart > <span class="number">0</span>) {
      scan = s.strstart - <span class="number">1</span>;
      prev = _win[scan];
      <span class="keyword">if</span> (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp; prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        <span class="keyword">do</span> {
          <span class="comment">/*jshint noempty:false*/</span>
        } <span class="keyword">while</span> (prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 prev === _win[++scan] &amp;&amp; prev === _win[++scan] &amp;&amp;
                 scan &lt; strend);
        s.match_length = MAX_MATCH - (strend - scan);
        <span class="keyword">if</span> (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      <span class="comment">//Assert(scan &lt;= s->window+(uInt)(s->window_size-1), "wild scan");</span>
    }

    <span class="comment">/* Emit match if have run of MIN_MATCH or longer, else emit literal */</span>
    <span class="keyword">if</span> (s.match_length >= MIN_MATCH) {
      <span class="comment">//check_match(s, s.strstart, s.strstart - 1, s.match_length);</span>

      <span class="comment">/*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/</span>
      bflush = trees._tr_tally(s, <span class="number">1</span>, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = <span class="number">0</span>;
    } <span class="keyword">else</span> {
      <span class="comment">/* No match, output a literal byte */</span>
      <span class="comment">//Tracevv((stderr,"%c", s->window[s->strstart]));</span>
      <span class="comment">/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/</span>
      bflush = trees._tr_tally(s, <span class="number">0</span>, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    <span class="keyword">if</span> (bflush) {
      <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
      flush_block_only(s, <span class="literal">false</span>);
      <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="comment">/***/</span>
    }
  }
  s.insert = <span class="number">0</span>;
  <span class="keyword">if</span> (flush === Z_FINISH) {
    <span class="comment">/*** FLUSH_BLOCK(s, 1); ***/</span>
    flush_block_only(s, <span class="literal">true</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_FINISH_STARTED;
    }
    <span class="comment">/***/</span>
    <span class="keyword">return</span> BS_FINISH_DONE;
  }
  <span class="keyword">if</span> (s.last_lit) {
    <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
    flush_block_only(s, <span class="literal">false</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_NEED_MORE;
    }
    <span class="comment">/***/</span>
  }
  <span class="keyword">return</span> BS_BLOCK_DONE;
}

<span class="comment">/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflate_huff</span><span class="params">(s, flush)</span> {</span>
  <span class="keyword">var</span> bflush;             <span class="comment">/* set if current block must be flushed */</span>

  <span class="keyword">for</span> (;;) {
    <span class="comment">/* Make sure that we have a literal to write. */</span>
    <span class="keyword">if</span> (s.lookahead === <span class="number">0</span>) {
      fill_window(s);
      <span class="keyword">if</span> (s.lookahead === <span class="number">0</span>) {
        <span class="keyword">if</span> (flush === Z_NO_FLUSH) {
          <span class="keyword">return</span> BS_NEED_MORE;
        }
        <span class="keyword">break</span>;      <span class="comment">/* flush the current block */</span>
      }
    }

    <span class="comment">/* Output a literal byte */</span>
    s.match_length = <span class="number">0</span>;
    <span class="comment">//Tracevv((stderr,"%c", s->window[s->strstart]));</span>
    <span class="comment">/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/</span>
    bflush = trees._tr_tally(s, <span class="number">0</span>, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    <span class="keyword">if</span> (bflush) {
      <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
      flush_block_only(s, <span class="literal">false</span>);
      <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
        <span class="keyword">return</span> BS_NEED_MORE;
      }
      <span class="comment">/***/</span>
    }
  }
  s.insert = <span class="number">0</span>;
  <span class="keyword">if</span> (flush === Z_FINISH) {
    <span class="comment">/*** FLUSH_BLOCK(s, 1); ***/</span>
    flush_block_only(s, <span class="literal">true</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_FINISH_STARTED;
    }
    <span class="comment">/***/</span>
    <span class="keyword">return</span> BS_FINISH_DONE;
  }
  <span class="keyword">if</span> (s.last_lit) {
    <span class="comment">/*** FLUSH_BLOCK(s, 0); ***/</span>
    flush_block_only(s, <span class="literal">false</span>);
    <span class="keyword">if</span> (s.strm.avail_out === <span class="number">0</span>) {
      <span class="keyword">return</span> BS_NEED_MORE;
    }
    <span class="comment">/***/</span>
  }
  <span class="keyword">return</span> BS_BLOCK_DONE;
}

<span class="comment">/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">Config</span><span class="params">(good_length, max_lazy, nice_length, max_chain, func)</span> {</span>
  <span class="keyword">this</span>.good_length = good_length;
  <span class="keyword">this</span>.max_lazy = max_lazy;
  <span class="keyword">this</span>.nice_length = nice_length;
  <span class="keyword">this</span>.max_chain = max_chain;
  <span class="keyword">this</span>.func = func;
}

<span class="keyword">var</span> configuration_table;

configuration_table = [
  <span class="comment">/*      good lazy nice chain */</span>
  <span class="keyword">new</span> Config(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, deflate_stored),          <span class="comment">/* 0 store only */</span>
  <span class="keyword">new</span> Config(<span class="number">4</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">4</span>, deflate_fast),            <span class="comment">/* 1 max speed, no lazy matches */</span>
  <span class="keyword">new</span> Config(<span class="number">4</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">8</span>, deflate_fast),           <span class="comment">/* 2 */</span>
  <span class="keyword">new</span> Config(<span class="number">4</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">32</span>, deflate_fast),          <span class="comment">/* 3 */</span>

  <span class="keyword">new</span> Config(<span class="number">4</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">16</span>, deflate_slow),          <span class="comment">/* 4 lazy matches */</span>
  <span class="keyword">new</span> Config(<span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">32</span>, deflate_slow),         <span class="comment">/* 5 */</span>
  <span class="keyword">new</span> Config(<span class="number">8</span>, <span class="number">16</span>, <span class="number">128</span>, <span class="number">128</span>, deflate_slow),       <span class="comment">/* 6 */</span>
  <span class="keyword">new</span> Config(<span class="number">8</span>, <span class="number">32</span>, <span class="number">128</span>, <span class="number">256</span>, deflate_slow),       <span class="comment">/* 7 */</span>
  <span class="keyword">new</span> Config(<span class="number">32</span>, <span class="number">128</span>, <span class="number">258</span>, <span class="number">1024</span>, deflate_slow),    <span class="comment">/* 8 */</span>
  <span class="keyword">new</span> Config(<span class="number">32</span>, <span class="number">258</span>, <span class="number">258</span>, <span class="number">4096</span>, deflate_slow)     <span class="comment">/* 9 max compression */</span>
];


<span class="comment">/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">lm_init</span><span class="params">(s)</span> {</span>
  s.window_size = <span class="number">2</span> * s.w_size;

  <span class="comment">/*** CLEAR_HASH(s); ***/</span>
  zero(s.head); <span class="comment">// Fill with NIL (= 0);</span>

  <span class="comment">/* Set the default configuration parameters:
   */</span>
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = <span class="number">0</span>;
  s.block_start = <span class="number">0</span>;
  s.lookahead = <span class="number">0</span>;
  s.insert = <span class="number">0</span>;
  s.match_length = s.prev_length = MIN_MATCH - <span class="number">1</span>;
  s.match_available = <span class="number">0</span>;
  s.ins_h = <span class="number">0</span>;
}


<span class="function"><span class="keyword">function</span> <span class="title">DeflateState</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.strm = <span class="literal">null</span>;            <span class="comment">/* pointer back to this zlib stream */</span>
  <span class="keyword">this</span>.status = <span class="number">0</span>;            <span class="comment">/* as the name implies */</span>
  <span class="keyword">this</span>.pending_buf = <span class="literal">null</span>;      <span class="comment">/* output still pending */</span>
  <span class="keyword">this</span>.pending_buf_size = <span class="number">0</span>;  <span class="comment">/* size of pending_buf */</span>
  <span class="keyword">this</span>.pending_out = <span class="number">0</span>;       <span class="comment">/* next pending byte to output to the stream */</span>
  <span class="keyword">this</span>.pending = <span class="number">0</span>;           <span class="comment">/* nb of bytes in the pending buffer */</span>
  <span class="keyword">this</span>.wrap = <span class="number">0</span>;              <span class="comment">/* bit 0 true for zlib, bit 1 true for gzip */</span>
  <span class="keyword">this</span>.gzhead = <span class="literal">null</span>;         <span class="comment">/* gzip header information to write */</span>
  <span class="keyword">this</span>.gzindex = <span class="number">0</span>;           <span class="comment">/* where in extra, name, or comment */</span>
  <span class="keyword">this</span>.method = Z_DEFLATED; <span class="comment">/* can only be DEFLATED */</span>
  <span class="keyword">this</span>.last_flush = -<span class="number">1</span>;   <span class="comment">/* value of flush param for previous deflate call */</span>

  <span class="keyword">this</span>.w_size = <span class="number">0</span>;  <span class="comment">/* LZ77 window size (32K by default) */</span>
  <span class="keyword">this</span>.w_bits = <span class="number">0</span>;  <span class="comment">/* log2(w_size)  (8..16) */</span>
  <span class="keyword">this</span>.w_mask = <span class="number">0</span>;  <span class="comment">/* w_size - 1 */</span>

  <span class="keyword">this</span>.window = <span class="literal">null</span>;
  <span class="comment">/* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */</span>

  <span class="keyword">this</span>.window_size = <span class="number">0</span>;
  <span class="comment">/* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */</span>

  <span class="keyword">this</span>.prev = <span class="literal">null</span>;
  <span class="comment">/* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */</span>

  <span class="keyword">this</span>.head = <span class="literal">null</span>;   <span class="comment">/* Heads of the hash chains or NIL. */</span>

  <span class="keyword">this</span>.ins_h = <span class="number">0</span>;       <span class="comment">/* hash index of string to be inserted */</span>
  <span class="keyword">this</span>.hash_size = <span class="number">0</span>;   <span class="comment">/* number of elements in hash table */</span>
  <span class="keyword">this</span>.hash_bits = <span class="number">0</span>;   <span class="comment">/* log2(hash_size) */</span>
  <span class="keyword">this</span>.hash_mask = <span class="number">0</span>;   <span class="comment">/* hash_size-1 */</span>

  <span class="keyword">this</span>.hash_shift = <span class="number">0</span>;
  <span class="comment">/* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */</span>

  <span class="keyword">this</span>.block_start = <span class="number">0</span>;
  <span class="comment">/* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */</span>

  <span class="keyword">this</span>.match_length = <span class="number">0</span>;      <span class="comment">/* length of best match */</span>
  <span class="keyword">this</span>.prev_match = <span class="number">0</span>;        <span class="comment">/* previous match */</span>
  <span class="keyword">this</span>.match_available = <span class="number">0</span>;   <span class="comment">/* set if previous match exists */</span>
  <span class="keyword">this</span>.strstart = <span class="number">0</span>;          <span class="comment">/* start of string to insert */</span>
  <span class="keyword">this</span>.match_start = <span class="number">0</span>;       <span class="comment">/* start of matching string */</span>
  <span class="keyword">this</span>.lookahead = <span class="number">0</span>;         <span class="comment">/* number of valid bytes ahead in window */</span>

  <span class="keyword">this</span>.prev_length = <span class="number">0</span>;
  <span class="comment">/* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */</span>

  <span class="keyword">this</span>.max_chain_length = <span class="number">0</span>;
  <span class="comment">/* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */</span>

  <span class="keyword">this</span>.max_lazy_match = <span class="number">0</span>;
  <span class="comment">/* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */</span>
  <span class="comment">// That's alias to max_lazy_match, don't use directly</span>
  <span class="comment">//this.max_insert_length = 0;</span>
  <span class="comment">/* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels &lt;= 3.
   */</span>

  <span class="keyword">this</span>.level = <span class="number">0</span>;     <span class="comment">/* compression level (1..9) */</span>
  <span class="keyword">this</span>.strategy = <span class="number">0</span>;  <span class="comment">/* favor or force Huffman coding*/</span>

  <span class="keyword">this</span>.good_match = <span class="number">0</span>;
  <span class="comment">/* Use a faster search when the previous match is longer than this */</span>

  <span class="keyword">this</span>.nice_match = <span class="number">0</span>; <span class="comment">/* Stop searching when current match exceeds this */</span>

              <span class="comment">/* used by trees.c: */</span>

  <span class="comment">/* Didn't use ct_data typedef below to suppress compiler warning */</span>

  <span class="comment">// struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */</span>
  <span class="comment">// struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */</span>
  <span class="comment">// struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */</span>

  <span class="comment">// Use flat array of DOUBLE size, with interleaved fata,</span>
  <span class="comment">// because JS does not support effective</span>
  <span class="keyword">this</span>.dyn_ltree  = <span class="keyword">new</span> utils.Buf16(HEAP_SIZE * <span class="number">2</span>);
  <span class="keyword">this</span>.dyn_dtree  = <span class="keyword">new</span> utils.Buf16((<span class="number">2</span> * D_CODES + <span class="number">1</span>) * <span class="number">2</span>);
  <span class="keyword">this</span>.bl_tree    = <span class="keyword">new</span> utils.Buf16((<span class="number">2</span> * BL_CODES + <span class="number">1</span>) * <span class="number">2</span>);
  zero(<span class="keyword">this</span>.dyn_ltree);
  zero(<span class="keyword">this</span>.dyn_dtree);
  zero(<span class="keyword">this</span>.bl_tree);

  <span class="keyword">this</span>.l_desc   = <span class="literal">null</span>;         <span class="comment">/* desc. for literal tree */</span>
  <span class="keyword">this</span>.d_desc   = <span class="literal">null</span>;         <span class="comment">/* desc. for distance tree */</span>
  <span class="keyword">this</span>.bl_desc  = <span class="literal">null</span>;         <span class="comment">/* desc. for bit length tree */</span>

  <span class="comment">//ush bl_count[MAX_BITS+1];</span>
  <span class="keyword">this</span>.bl_count = <span class="keyword">new</span> utils.Buf16(MAX_BITS + <span class="number">1</span>);
  <span class="comment">/* number of codes at each bit length for an optimal tree */</span>

  <span class="comment">//int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */</span>
  <span class="keyword">this</span>.heap = <span class="keyword">new</span> utils.Buf16(<span class="number">2</span> * L_CODES + <span class="number">1</span>);  <span class="comment">/* heap used to build the Huffman trees */</span>
  zero(<span class="keyword">this</span>.heap);

  <span class="keyword">this</span>.heap_len = <span class="number">0</span>;               <span class="comment">/* number of elements in the heap */</span>
  <span class="keyword">this</span>.heap_max = <span class="number">0</span>;               <span class="comment">/* element of largest frequency */</span>
  <span class="comment">/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */</span>

  <span class="keyword">this</span>.depth = <span class="keyword">new</span> utils.Buf16(<span class="number">2</span> * L_CODES + <span class="number">1</span>); <span class="comment">//uch depth[2*L_CODES+1];</span>
  zero(<span class="keyword">this</span>.depth);
  <span class="comment">/* Depth of each subtree used as tie breaker for trees of equal frequency
   */</span>

  <span class="keyword">this</span>.l_buf = <span class="number">0</span>;          <span class="comment">/* buffer index for literals or lengths */</span>

  <span class="keyword">this</span>.lit_bufsize = <span class="number">0</span>;
  <span class="comment">/* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */</span>

  <span class="keyword">this</span>.last_lit = <span class="number">0</span>;      <span class="comment">/* running index in l_buf */</span>

  <span class="keyword">this</span>.d_buf = <span class="number">0</span>;
  <span class="comment">/* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */</span>

  <span class="keyword">this</span>.opt_len = <span class="number">0</span>;       <span class="comment">/* bit length of current block with optimal trees */</span>
  <span class="keyword">this</span>.static_len = <span class="number">0</span>;    <span class="comment">/* bit length of current block with static trees */</span>
  <span class="keyword">this</span>.matches = <span class="number">0</span>;       <span class="comment">/* number of string matches in current block */</span>
  <span class="keyword">this</span>.insert = <span class="number">0</span>;        <span class="comment">/* bytes at end of window left to insert */</span>


  <span class="keyword">this</span>.bi_buf = <span class="number">0</span>;
  <span class="comment">/* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */</span>
  <span class="keyword">this</span>.bi_valid = <span class="number">0</span>;
  <span class="comment">/* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */</span>

  <span class="comment">// Used for window memory init. We safely ignore it for JS. That makes</span>
  <span class="comment">// sense only for pointers and memory check tools.</span>
  <span class="comment">//this.high_water = 0;</span>
  <span class="comment">/* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */</span>
}


<span class="function"><span class="keyword">function</span> <span class="title">deflateResetKeep</span><span class="params">(strm)</span> {</span>
  <span class="keyword">var</span> s;

  <span class="keyword">if</span> (!strm || !strm.state) {
    <span class="keyword">return</span> err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = <span class="number">0</span>;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = <span class="number">0</span>;
  s.pending_out = <span class="number">0</span>;

  <span class="keyword">if</span> (s.wrap &lt; <span class="number">0</span>) {
    s.wrap = -s.wrap;
    <span class="comment">/* was made negative by deflate(..., Z_FINISH); */</span>
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === <span class="number">2</span>) ?
    <span class="number">0</span>  <span class="comment">// crc32(0, Z_NULL, 0)</span>
  :
    <span class="number">1</span>; <span class="comment">// adler32(0, Z_NULL, 0)</span>
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  <span class="keyword">return</span> Z_OK;
}


<span class="function"><span class="keyword">function</span> <span class="title">deflateReset</span><span class="params">(strm)</span> {</span>
  <span class="keyword">var</span> ret = deflateResetKeep(strm);
  <span class="keyword">if</span> (ret === Z_OK) {
    lm_init(strm.state);
  }
  <span class="keyword">return</span> ret;
}


<span class="function"><span class="keyword">function</span> <span class="title">deflateSetHeader</span><span class="params">(strm, head)</span> {</span>
  <span class="keyword">if</span> (!strm || !strm.state) { <span class="keyword">return</span> Z_STREAM_ERROR; }
  <span class="keyword">if</span> (strm.state.wrap !== <span class="number">2</span>) { <span class="keyword">return</span> Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  <span class="keyword">return</span> Z_OK;
}


<span class="function"><span class="keyword">function</span> <span class="title">deflateInit2</span><span class="params">(strm, level, method, windowBits, memLevel, strategy)</span> {</span>
  <span class="keyword">if</span> (!strm) { <span class="comment">// === Z_NULL</span>
    <span class="keyword">return</span> Z_STREAM_ERROR;
  }
  <span class="keyword">var</span> wrap = <span class="number">1</span>;

  <span class="keyword">if</span> (level === Z_DEFAULT_COMPRESSION) {
    level = <span class="number">6</span>;
  }

  <span class="keyword">if</span> (windowBits &lt; <span class="number">0</span>) { <span class="comment">/* suppress zlib wrapper */</span>
    wrap = <span class="number">0</span>;
    windowBits = -windowBits;
  }

  <span class="keyword">else</span> <span class="keyword">if</span> (windowBits > <span class="number">15</span>) {
    wrap = <span class="number">2</span>;           <span class="comment">/* write gzip wrapper instead */</span>
    windowBits -= <span class="number">16</span>;
  }


  <span class="keyword">if</span> (memLevel &lt; <span class="number">1</span> || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits &lt; <span class="number">8</span> || windowBits > <span class="number">15</span> || level &lt; <span class="number">0</span> || level > <span class="number">9</span> ||
    strategy &lt; <span class="number">0</span> || strategy > Z_FIXED) {
    <span class="keyword">return</span> err(strm, Z_STREAM_ERROR);
  }


  <span class="keyword">if</span> (windowBits === <span class="number">8</span>) {
    windowBits = <span class="number">9</span>;
  }
  <span class="comment">/* until 256-byte window bug fixed */</span>

  <span class="keyword">var</span> s = <span class="keyword">new</span> DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = <span class="literal">null</span>;
  s.w_bits = windowBits;
  s.w_size = <span class="number">1</span> &lt;&lt; s.w_bits;
  s.w_mask = s.w_size - <span class="number">1</span>;

  s.hash_bits = memLevel + <span class="number">7</span>;
  s.hash_size = <span class="number">1</span> &lt;&lt; s.hash_bits;
  s.hash_mask = s.hash_size - <span class="number">1</span>;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - <span class="number">1</span>) / MIN_MATCH);

  s.window = <span class="keyword">new</span> utils.Buf8(s.w_size * <span class="number">2</span>);
  s.head = <span class="keyword">new</span> utils.Buf16(s.hash_size);
  s.prev = <span class="keyword">new</span> utils.Buf16(s.w_size);

  <span class="comment">// Don't need mem init magic for JS.</span>
  <span class="comment">//s.high_water = 0;  /* nothing written to s->window yet */</span>

  s.lit_bufsize = <span class="number">1</span> &lt;&lt; (memLevel + <span class="number">6</span>); <span class="comment">/* 16K elements by default */</span>

  s.pending_buf_size = s.lit_bufsize * <span class="number">4</span>;

  <span class="comment">//overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);</span>
  <span class="comment">//s->pending_buf = (uchf *) overlay;</span>
  s.pending_buf = <span class="keyword">new</span> utils.Buf8(s.pending_buf_size);

  <span class="comment">// It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)</span>
  <span class="comment">//s->d_buf = overlay + s->lit_bufsize/sizeof(ush);</span>
  s.d_buf = <span class="number">1</span> * s.lit_bufsize;

  <span class="comment">//s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;</span>
  s.l_buf = (<span class="number">1</span> + <span class="number">2</span>) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  <span class="keyword">return</span> deflateReset(strm);
}

<span class="function"><span class="keyword">function</span> <span class="title">deflateInit</span><span class="params">(strm, level)</span> {</span>
  <span class="keyword">return</span> deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


<span class="function"><span class="keyword">function</span> <span class="title">deflate</span><span class="params">(strm, flush)</span> {</span>
  <span class="keyword">var</span> old_flush, s;
  <span class="keyword">var</span> beg, val; <span class="comment">// for gzip header write only</span>

  <span class="keyword">if</span> (!strm || !strm.state ||
    flush > Z_BLOCK || flush &lt; <span class="number">0</span>) {
    <span class="keyword">return</span> strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  <span class="keyword">if</span> (!strm.output ||
      (!strm.input &amp;&amp; strm.avail_in !== <span class="number">0</span>) ||
      (s.status === FINISH_STATE &amp;&amp; flush !== Z_FINISH)) {
    <span class="keyword">return</span> err(strm, (strm.avail_out === <span class="number">0</span>) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; <span class="comment">/* just in case */</span>
  old_flush = s.last_flush;
  s.last_flush = flush;

  <span class="comment">/* Write the header */</span>
  <span class="keyword">if</span> (s.status === INIT_STATE) {

    <span class="keyword">if</span> (s.wrap === <span class="number">2</span>) { <span class="comment">// GZIP header</span>
      strm.adler = <span class="number">0</span>;  <span class="comment">//crc32(0L, Z_NULL, 0);</span>
      put_byte(s, <span class="number">31</span>);
      put_byte(s, <span class="number">139</span>);
      put_byte(s, <span class="number">8</span>);
      <span class="keyword">if</span> (!s.gzhead) { <span class="comment">// s->gzhead == Z_NULL</span>
        put_byte(s, <span class="number">0</span>);
        put_byte(s, <span class="number">0</span>);
        put_byte(s, <span class="number">0</span>);
        put_byte(s, <span class="number">0</span>);
        put_byte(s, <span class="number">0</span>);
        put_byte(s, s.level === <span class="number">9</span> ? <span class="number">2</span> :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level &lt; <span class="number">2</span> ?
                     <span class="number">4</span> : <span class="number">0</span>));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      <span class="keyword">else</span> {
        put_byte(s, (s.gzhead.text ? <span class="number">1</span> : <span class="number">0</span>) +
                    (s.gzhead.hcrc ? <span class="number">2</span> : <span class="number">0</span>) +
                    (!s.gzhead.extra ? <span class="number">0</span> : <span class="number">4</span>) +
                    (!s.gzhead.name ? <span class="number">0</span> : <span class="number">8</span>) +
                    (!s.gzhead.comment ? <span class="number">0</span> : <span class="number">16</span>)
        );
        put_byte(s, s.gzhead.time &amp; <span class="number">0xff</span>);
        put_byte(s, (s.gzhead.time >> <span class="number">8</span>) &amp; <span class="number">0xff</span>);
        put_byte(s, (s.gzhead.time >> <span class="number">16</span>) &amp; <span class="number">0xff</span>);
        put_byte(s, (s.gzhead.time >> <span class="number">24</span>) &amp; <span class="number">0xff</span>);
        put_byte(s, s.level === <span class="number">9</span> ? <span class="number">2</span> :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level &lt; <span class="number">2</span> ?
                     <span class="number">4</span> : <span class="number">0</span>));
        put_byte(s, s.gzhead.os &amp; <span class="number">0xff</span>);
        <span class="keyword">if</span> (s.gzhead.extra &amp;&amp; s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length &amp; <span class="number">0xff</span>);
          put_byte(s, (s.gzhead.extra.length >> <span class="number">8</span>) &amp; <span class="number">0xff</span>);
        }
        <span class="keyword">if</span> (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, <span class="number">0</span>);
        }
        s.gzindex = <span class="number">0</span>;
        s.status = EXTRA_STATE;
      }
    }
    <span class="keyword">else</span> <span class="comment">// DEFLATE header</span>
    {
      <span class="keyword">var</span> header = (Z_DEFLATED + ((s.w_bits - <span class="number">8</span>) &lt;&lt; <span class="number">4</span>)) &lt;&lt; <span class="number">8</span>;
      <span class="keyword">var</span> level_flags = -<span class="number">1</span>;

      <span class="keyword">if</span> (s.strategy >= Z_HUFFMAN_ONLY || s.level &lt; <span class="number">2</span>) {
        level_flags = <span class="number">0</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (s.level &lt; <span class="number">6</span>) {
        level_flags = <span class="number">1</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (s.level === <span class="number">6</span>) {
        level_flags = <span class="number">2</span>;
      } <span class="keyword">else</span> {
        level_flags = <span class="number">3</span>;
      }
      header |= (level_flags &lt;&lt; <span class="number">6</span>);
      <span class="keyword">if</span> (s.strstart !== <span class="number">0</span>) { header |= PRESET_DICT; }
      header += <span class="number">31</span> - (header % <span class="number">31</span>);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      <span class="comment">/* Save the adler32 of the preset dictionary: */</span>
      <span class="keyword">if</span> (s.strstart !== <span class="number">0</span>) {
        putShortMSB(s, strm.adler >>> <span class="number">16</span>);
        putShortMSB(s, strm.adler &amp; <span class="number">0xffff</span>);
      }
      strm.adler = <span class="number">1</span>; <span class="comment">// adler32(0L, Z_NULL, 0);</span>
    }
  }

<span class="comment">//#ifdef GZIP</span>
  <span class="keyword">if</span> (s.status === EXTRA_STATE) {
    <span class="keyword">if</span> (s.gzhead.extra<span class="comment">/* != Z_NULL*/</span>) {
      beg = s.pending;  <span class="comment">/* start of bytes to update crc */</span>

      <span class="keyword">while</span> (s.gzindex &lt; (s.gzhead.extra.length &amp; <span class="number">0xffff</span>)) {
        <span class="keyword">if</span> (s.pending === s.pending_buf_size) {
          <span class="keyword">if</span> (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          <span class="keyword">if</span> (s.pending === s.pending_buf_size) {
            <span class="keyword">break</span>;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] &amp; <span class="number">0xff</span>);
        s.gzindex++;
      }
      <span class="keyword">if</span> (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      <span class="keyword">if</span> (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = <span class="number">0</span>;
        s.status = NAME_STATE;
      }
    }
    <span class="keyword">else</span> {
      s.status = NAME_STATE;
    }
  }
  <span class="keyword">if</span> (s.status === NAME_STATE) {
    <span class="keyword">if</span> (s.gzhead.name<span class="comment">/* != Z_NULL*/</span>) {
      beg = s.pending;  <span class="comment">/* start of bytes to update crc */</span>
      <span class="comment">//int val;</span>

      <span class="keyword">do</span> {
        <span class="keyword">if</span> (s.pending === s.pending_buf_size) {
          <span class="keyword">if</span> (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          <span class="keyword">if</span> (s.pending === s.pending_buf_size) {
            val = <span class="number">1</span>;
            <span class="keyword">break</span>;
          }
        }
        <span class="comment">// JS specific: little magic to add zero terminator to end of string</span>
        <span class="keyword">if</span> (s.gzindex &lt; s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) &amp; <span class="number">0xff</span>;
        } <span class="keyword">else</span> {
          val = <span class="number">0</span>;
        }
        put_byte(s, val);
      } <span class="keyword">while</span> (val !== <span class="number">0</span>);

      <span class="keyword">if</span> (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      <span class="keyword">if</span> (val === <span class="number">0</span>) {
        s.gzindex = <span class="number">0</span>;
        s.status = COMMENT_STATE;
      }
    }
    <span class="keyword">else</span> {
      s.status = COMMENT_STATE;
    }
  }
  <span class="keyword">if</span> (s.status === COMMENT_STATE) {
    <span class="keyword">if</span> (s.gzhead.comment<span class="comment">/* != Z_NULL*/</span>) {
      beg = s.pending;  <span class="comment">/* start of bytes to update crc */</span>
      <span class="comment">//int val;</span>

      <span class="keyword">do</span> {
        <span class="keyword">if</span> (s.pending === s.pending_buf_size) {
          <span class="keyword">if</span> (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          <span class="keyword">if</span> (s.pending === s.pending_buf_size) {
            val = <span class="number">1</span>;
            <span class="keyword">break</span>;
          }
        }
        <span class="comment">// JS specific: little magic to add zero terminator to end of string</span>
        <span class="keyword">if</span> (s.gzindex &lt; s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) &amp; <span class="number">0xff</span>;
        } <span class="keyword">else</span> {
          val = <span class="number">0</span>;
        }
        put_byte(s, val);
      } <span class="keyword">while</span> (val !== <span class="number">0</span>);

      <span class="keyword">if</span> (s.gzhead.hcrc &amp;&amp; s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      <span class="keyword">if</span> (val === <span class="number">0</span>) {
        s.status = HCRC_STATE;
      }
    }
    <span class="keyword">else</span> {
      s.status = HCRC_STATE;
    }
  }
  <span class="keyword">if</span> (s.status === HCRC_STATE) {
    <span class="keyword">if</span> (s.gzhead.hcrc) {
      <span class="keyword">if</span> (s.pending + <span class="number">2</span> > s.pending_buf_size) {
        flush_pending(strm);
      }
      <span class="keyword">if</span> (s.pending + <span class="number">2</span> &lt;= s.pending_buf_size) {
        put_byte(s, strm.adler &amp; <span class="number">0xff</span>);
        put_byte(s, (strm.adler >> <span class="number">8</span>) &amp; <span class="number">0xff</span>);
        strm.adler = <span class="number">0</span>; <span class="comment">//crc32(0L, Z_NULL, 0);</span>
        s.status = BUSY_STATE;
      }
    }
    <span class="keyword">else</span> {
      s.status = BUSY_STATE;
    }
  }
<span class="comment">//#endif</span>

  <span class="comment">/* Flush as much pending output as possible */</span>
  <span class="keyword">if</span> (s.pending !== <span class="number">0</span>) {
    flush_pending(strm);
    <span class="keyword">if</span> (strm.avail_out === <span class="number">0</span>) {
      <span class="comment">/* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */</span>
      s.last_flush = -<span class="number">1</span>;
      <span class="keyword">return</span> Z_OK;
    }

    <span class="comment">/* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> (strm.avail_in === <span class="number">0</span> &amp;&amp; rank(flush) &lt;= rank(old_flush) &amp;&amp;
    flush !== Z_FINISH) {
    <span class="keyword">return</span> err(strm, Z_BUF_ERROR);
  }

  <span class="comment">/* User must not provide more input after the first FINISH: */</span>
  <span class="keyword">if</span> (s.status === FINISH_STATE &amp;&amp; strm.avail_in !== <span class="number">0</span>) {
    <span class="keyword">return</span> err(strm, Z_BUF_ERROR);
  }

  <span class="comment">/* Start a new block or continue the current one.
   */</span>
  <span class="keyword">if</span> (strm.avail_in !== <span class="number">0</span> || s.lookahead !== <span class="number">0</span> ||
    (flush !== Z_NO_FLUSH &amp;&amp; s.status !== FINISH_STATE)) {
    <span class="keyword">var</span> bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    <span class="keyword">if</span> (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    <span class="keyword">if</span> (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      <span class="keyword">if</span> (strm.avail_out === <span class="number">0</span>) {
        s.last_flush = -<span class="number">1</span>;
        <span class="comment">/* avoid BUF_ERROR next call, see above */</span>
      }
      <span class="keyword">return</span> Z_OK;
      <span class="comment">/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */</span>
    }
    <span class="keyword">if</span> (bstate === BS_BLOCK_DONE) {
      <span class="keyword">if</span> (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (flush !== Z_BLOCK) { <span class="comment">/* FULL_FLUSH or SYNC_FLUSH */</span>

        trees._tr_stored_block(s, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">false</span>);
        <span class="comment">/* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */</span>
        <span class="keyword">if</span> (flush === Z_FULL_FLUSH) {
          <span class="comment">/*** CLEAR_HASH(s); ***/</span>             <span class="comment">/* forget history */</span>
          zero(s.head); <span class="comment">// Fill with NIL (= 0);</span>

          <span class="keyword">if</span> (s.lookahead === <span class="number">0</span>) {
            s.strstart = <span class="number">0</span>;
            s.block_start = <span class="number">0</span>;
            s.insert = <span class="number">0</span>;
          }
        }
      }
      flush_pending(strm);
      <span class="keyword">if</span> (strm.avail_out === <span class="number">0</span>) {
        s.last_flush = -<span class="number">1</span>; <span class="comment">/* avoid BUF_ERROR at next call, see above */</span>
        <span class="keyword">return</span> Z_OK;
      }
    }
  }
  <span class="comment">//Assert(strm->avail_out > 0, "bug2");</span>
  <span class="comment">//if (strm.avail_out &lt;= 0) { throw new Error("bug2");}</span>

  <span class="keyword">if</span> (flush !== Z_FINISH) { <span class="keyword">return</span> Z_OK; }
  <span class="keyword">if</span> (s.wrap &lt;= <span class="number">0</span>) { <span class="keyword">return</span> Z_STREAM_END; }

  <span class="comment">/* Write the trailer */</span>
  <span class="keyword">if</span> (s.wrap === <span class="number">2</span>) {
    put_byte(s, strm.adler &amp; <span class="number">0xff</span>);
    put_byte(s, (strm.adler >> <span class="number">8</span>) &amp; <span class="number">0xff</span>);
    put_byte(s, (strm.adler >> <span class="number">16</span>) &amp; <span class="number">0xff</span>);
    put_byte(s, (strm.adler >> <span class="number">24</span>) &amp; <span class="number">0xff</span>);
    put_byte(s, strm.total_in &amp; <span class="number">0xff</span>);
    put_byte(s, (strm.total_in >> <span class="number">8</span>) &amp; <span class="number">0xff</span>);
    put_byte(s, (strm.total_in >> <span class="number">16</span>) &amp; <span class="number">0xff</span>);
    put_byte(s, (strm.total_in >> <span class="number">24</span>) &amp; <span class="number">0xff</span>);
  }
  <span class="keyword">else</span>
  {
    putShortMSB(s, strm.adler >>> <span class="number">16</span>);
    putShortMSB(s, strm.adler &amp; <span class="number">0xffff</span>);
  }

  flush_pending(strm);
  <span class="comment">/* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */</span>
  <span class="keyword">if</span> (s.wrap > <span class="number">0</span>) { s.wrap = -s.wrap; }
  <span class="comment">/* write the trailer only once! */</span>
  <span class="keyword">return</span> s.pending !== <span class="number">0</span> ? Z_OK : Z_STREAM_END;
}

<span class="function"><span class="keyword">function</span> <span class="title">deflateEnd</span><span class="params">(strm)</span> {</span>
  <span class="keyword">var</span> status;

  <span class="keyword">if</span> (!strm<span class="comment">/*== Z_NULL*/</span> || !strm.state<span class="comment">/*== Z_NULL*/</span>) {
    <span class="keyword">return</span> Z_STREAM_ERROR;
  }

  status = strm.state.status;
  <span class="keyword">if</span> (status !== INIT_STATE &amp;&amp;
    status !== EXTRA_STATE &amp;&amp;
    status !== NAME_STATE &amp;&amp;
    status !== COMMENT_STATE &amp;&amp;
    status !== HCRC_STATE &amp;&amp;
    status !== BUSY_STATE &amp;&amp;
    status !== FINISH_STATE
  ) {
    <span class="keyword">return</span> err(strm, Z_STREAM_ERROR);
  }

  strm.state = <span class="literal">null</span>;

  <span class="keyword">return</span> status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


<span class="comment">/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflateSetDictionary</span><span class="params">(strm, dictionary)</span> {</span>
  <span class="keyword">var</span> dictLength = dictionary.length;

  <span class="keyword">var</span> s;
  <span class="keyword">var</span> str, n;
  <span class="keyword">var</span> wrap;
  <span class="keyword">var</span> avail;
  <span class="keyword">var</span> next;
  <span class="keyword">var</span> input;
  <span class="keyword">var</span> tmpDict;

  <span class="keyword">if</span> (!strm<span class="comment">/*== Z_NULL*/</span> || !strm.state<span class="comment">/*== Z_NULL*/</span>) {
    <span class="keyword">return</span> Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  <span class="keyword">if</span> (wrap === <span class="number">2</span> || (wrap === <span class="number">1</span> &amp;&amp; s.status !== INIT_STATE) || s.lookahead) {
    <span class="keyword">return</span> Z_STREAM_ERROR;
  }

  <span class="comment">/* when using zlib wrappers, compute Adler-32 for provided dictionary */</span>
  <span class="keyword">if</span> (wrap === <span class="number">1</span>) {
    <span class="comment">/* adler32(strm->adler, dictionary, dictLength); */</span>
    strm.adler = adler32(strm.adler, dictionary, dictLength, <span class="number">0</span>);
  }

  s.wrap = <span class="number">0</span>;   <span class="comment">/* avoid computing Adler-32 in read_buf */</span>

  <span class="comment">/* if dictionary would fill window, just replace the history */</span>
  <span class="keyword">if</span> (dictLength >= s.w_size) {
    <span class="keyword">if</span> (wrap === <span class="number">0</span>) {            <span class="comment">/* already empty otherwise */</span>
      <span class="comment">/*** CLEAR_HASH(s); ***/</span>
      zero(s.head); <span class="comment">// Fill with NIL (= 0);</span>
      s.strstart = <span class="number">0</span>;
      s.block_start = <span class="number">0</span>;
      s.insert = <span class="number">0</span>;
    }
    <span class="comment">/* use the tail */</span>
    <span class="comment">// dictionary = dictionary.slice(dictLength - s.w_size);</span>
    tmpDict = <span class="keyword">new</span> utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, <span class="number">0</span>);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  <span class="comment">/* insert dictionary into window and hash */</span>
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = <span class="number">0</span>;
  strm.input = dictionary;
  fill_window(s);
  <span class="keyword">while</span> (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - <span class="number">1</span>);
    <span class="keyword">do</span> {
      <span class="comment">/* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */</span>
      s.ins_h = ((s.ins_h &lt;&lt; s.hash_shift) ^ s.window[str + MIN_MATCH - <span class="number">1</span>]) &amp; s.hash_mask;

      s.prev[str &amp; s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } <span class="keyword">while</span> (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - <span class="number">1</span>;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = <span class="number">0</span>;
  s.match_length = s.prev_length = MIN_MATCH - <span class="number">1</span>;
  s.match_available = <span class="number">0</span>;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  <span class="keyword">return</span> Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = <span class="string">'pako deflate (from Nodeca project)'</span>;

<span class="comment">/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/</span>
</code></pre>