<h1>trees.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="comment">// (C) 1995-2013 Jean-loup Gailly and Mark Adler</span>
<span class="comment">// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin</span>
<span class="comment">//</span>
<span class="comment">// This software is provided 'as-is', without any express or implied</span>
<span class="comment">// warranty. In no event will the authors be held liable for any damages</span>
<span class="comment">// arising from the use of this software.</span>
<span class="comment">//</span>
<span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<span class="comment">// including commercial applications, and to alter it and redistribute it</span>
<span class="comment">// freely, subject to the following restrictions:</span>
<span class="comment">//</span>
<span class="comment">// 1. The origin of this software must not be misrepresented; you must not</span>
<span class="comment">//   claim that you wrote the original software. If you use this software</span>
<span class="comment">//   in a product, an acknowledgment in the product documentation would be</span>
<span class="comment">//   appreciated but is not required.</span>
<span class="comment">// 2. Altered source versions must be plainly marked as such, and must not be</span>
<span class="comment">//   misrepresented as being the original software.</span>
<span class="comment">// 3. This notice may not be removed or altered from any source distribution.</span>

<span class="comment">/* eslint-disable space-unary-ops */</span>

<span class="keyword">var</span> utils = require(<span class="string">'../utils/common'</span>);

<span class="comment">/* Public constants ==========================================================*/</span>
<span class="comment">/* ===========================================================================*/</span>


<span class="comment">//var Z_FILTERED          = 1;</span>
<span class="comment">//var Z_HUFFMAN_ONLY      = 2;</span>
<span class="comment">//var Z_RLE               = 3;</span>
<span class="keyword">var</span> Z_FIXED               = <span class="number">4</span>;
<span class="comment">//var Z_DEFAULT_STRATEGY  = 0;</span>

<span class="comment">/* Possible values of the data_type field (though see inflate()) */</span>
<span class="keyword">var</span> Z_BINARY              = <span class="number">0</span>;
<span class="keyword">var</span> Z_TEXT                = <span class="number">1</span>;
<span class="comment">//var Z_ASCII             = 1; // = Z_TEXT</span>
<span class="keyword">var</span> Z_UNKNOWN             = <span class="number">2</span>;

<span class="comment">/*============================================================================*/</span>


<span class="function"><span class="keyword">function</span> <span class="title">zero</span><span class="params">(buf)</span> {</span> <span class="keyword">var</span> len = buf.length; <span class="keyword">while</span> (--len >= <span class="number">0</span>) { buf[len] = <span class="number">0</span>; } }

<span class="comment">// From zutil.h</span>

<span class="keyword">var</span> STORED_BLOCK = <span class="number">0</span>;
<span class="keyword">var</span> STATIC_TREES = <span class="number">1</span>;
<span class="keyword">var</span> DYN_TREES    = <span class="number">2</span>;
<span class="comment">/* The three kinds of block type */</span>

<span class="keyword">var</span> MIN_MATCH    = <span class="number">3</span>;
<span class="keyword">var</span> MAX_MATCH    = <span class="number">258</span>;
<span class="comment">/* The minimum and maximum match lengths */</span>

<span class="comment">// From deflate.h</span>
<span class="comment">/* ===========================================================================
 * Internal compression state.
 */</span>

<span class="keyword">var</span> LENGTH_CODES  = <span class="number">29</span>;
<span class="comment">/* number of length codes, not counting the special END_BLOCK code */</span>

<span class="keyword">var</span> LITERALS      = <span class="number">256</span>;
<span class="comment">/* number of literal bytes 0..255 */</span>

<span class="keyword">var</span> L_CODES       = LITERALS + <span class="number">1</span> + LENGTH_CODES;
<span class="comment">/* number of Literal or Length codes, including the END_BLOCK code */</span>

<span class="keyword">var</span> D_CODES       = <span class="number">30</span>;
<span class="comment">/* number of distance codes */</span>

<span class="keyword">var</span> BL_CODES      = <span class="number">19</span>;
<span class="comment">/* number of codes used to transfer the bit lengths */</span>

<span class="keyword">var</span> HEAP_SIZE     = <span class="number">2</span> * L_CODES + <span class="number">1</span>;
<span class="comment">/* maximum heap size */</span>

<span class="keyword">var</span> MAX_BITS      = <span class="number">15</span>;
<span class="comment">/* All codes must not exceed MAX_BITS bits */</span>

<span class="keyword">var</span> Buf_size      = <span class="number">16</span>;
<span class="comment">/* size of bit buffer in bi_buf */</span>


<span class="comment">/* ===========================================================================
 * Constants
 */</span>

<span class="keyword">var</span> MAX_BL_BITS = <span class="number">7</span>;
<span class="comment">/* Bit length codes must not exceed MAX_BL_BITS bits */</span>

<span class="keyword">var</span> END_BLOCK   = <span class="number">256</span>;
<span class="comment">/* end of block literal code */</span>

<span class="keyword">var</span> REP_3_6     = <span class="number">16</span>;
<span class="comment">/* repeat previous bit length 3-6 times (2 bits of repeat count) */</span>

<span class="keyword">var</span> REPZ_3_10   = <span class="number">17</span>;
<span class="comment">/* repeat a zero length 3-10 times  (3 bits of repeat count) */</span>

<span class="keyword">var</span> REPZ_11_138 = <span class="number">18</span>;
<span class="comment">/* repeat a zero length 11-138 times  (7 bits of repeat count) */</span>

<span class="comment">/* eslint-disable comma-spacing,array-bracket-spacing */</span>
<span class="keyword">var</span> extra_lbits =   <span class="comment">/* extra bits for each length code */</span>
  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">0</span>];

<span class="keyword">var</span> extra_dbits =   <span class="comment">/* extra bits for each distance code */</span>
  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">13</span>];

<span class="keyword">var</span> extra_blbits =  <span class="comment">/* extra bits for each bit length code */</span>
  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>];

<span class="keyword">var</span> bl_order =
  [<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">1</span>,<span class="number">15</span>];
<span class="comment">/* eslint-enable comma-spacing,array-bracket-spacing */</span>

<span class="comment">/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */</span>

<span class="comment">/* ===========================================================================
 * Local data. These are initialized only once.
 */</span>

<span class="comment">// We pre-fill arrays with 0 to avoid uninitialized gaps</span>

<span class="keyword">var</span> DIST_CODE_LEN = <span class="number">512</span>; <span class="comment">/* see definition of array dist_code below */</span>

<span class="comment">// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1</span>
<span class="keyword">var</span> static_ltree  = <span class="keyword">new</span> Array((L_CODES + <span class="number">2</span>) * <span class="number">2</span>);
zero(static_ltree);
<span class="comment">/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */</span>

<span class="keyword">var</span> static_dtree  = <span class="keyword">new</span> Array(D_CODES * <span class="number">2</span>);
zero(static_dtree);
<span class="comment">/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */</span>

<span class="keyword">var</span> _dist_code    = <span class="keyword">new</span> Array(DIST_CODE_LEN);
zero(_dist_code);
<span class="comment">/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */</span>

<span class="keyword">var</span> _length_code  = <span class="keyword">new</span> Array(MAX_MATCH - MIN_MATCH + <span class="number">1</span>);
zero(_length_code);
<span class="comment">/* length code for each normalized match length (0 == MIN_MATCH) */</span>

<span class="keyword">var</span> base_length   = <span class="keyword">new</span> Array(LENGTH_CODES);
zero(base_length);
<span class="comment">/* First normalized length for each code (0 = MIN_MATCH) */</span>

<span class="keyword">var</span> base_dist     = <span class="keyword">new</span> Array(D_CODES);
zero(base_dist);
<span class="comment">/* First normalized distance for each code (0 = distance of 1) */</span>


<span class="function"><span class="keyword">function</span> <span class="title">StaticTreeDesc</span><span class="params">(static_tree, extra_bits, extra_base, elems, max_length)</span> {</span>

  <span class="keyword">this</span>.static_tree  = static_tree;  <span class="comment">/* static tree or NULL */</span>
  <span class="keyword">this</span>.extra_bits   = extra_bits;   <span class="comment">/* extra bits for each code or NULL */</span>
  <span class="keyword">this</span>.extra_base   = extra_base;   <span class="comment">/* base index for extra_bits */</span>
  <span class="keyword">this</span>.elems        = elems;        <span class="comment">/* max number of elements in the tree */</span>
  <span class="keyword">this</span>.max_length   = max_length;   <span class="comment">/* max bit length for the codes */</span>

  <span class="comment">// show if `static_tree` has data or dummy - needed for monomorphic objects</span>
  <span class="keyword">this</span>.has_stree    = static_tree &amp;&amp; static_tree.length;
}


<span class="keyword">var</span> static_l_desc;
<span class="keyword">var</span> static_d_desc;
<span class="keyword">var</span> static_bl_desc;


<span class="function"><span class="keyword">function</span> <span class="title">TreeDesc</span><span class="params">(dyn_tree, stat_desc)</span> {</span>
  <span class="keyword">this</span>.dyn_tree = dyn_tree;     <span class="comment">/* the dynamic tree */</span>
  <span class="keyword">this</span>.max_code = <span class="number">0</span>;            <span class="comment">/* largest code with non zero frequency */</span>
  <span class="keyword">this</span>.stat_desc = stat_desc;   <span class="comment">/* the corresponding static tree */</span>
}



<span class="function"><span class="keyword">function</span> <span class="title">d_code</span><span class="params">(dist)</span> {</span>
  <span class="keyword">return</span> dist &lt; <span class="number">256</span> ? _dist_code[dist] : _dist_code[<span class="number">256</span> + (dist >>> <span class="number">7</span>)];
}


<span class="comment">/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">put_short</span><span class="params">(s, w)</span> {</span>
<span class="comment">//    put_byte(s, (uch)((w) &amp; 0xff));</span>
<span class="comment">//    put_byte(s, (uch)((ush)(w) >> 8));</span>
  s.pending_buf[s.pending++] = (w) &amp; <span class="number">0xff</span>;
  s.pending_buf[s.pending++] = (w >>> <span class="number">8</span>) &amp; <span class="number">0xff</span>;
}


<span class="comment">/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length &lt;= 16 and value fits in length bits.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">send_bits</span><span class="params">(s, value, length)</span> {</span>
  <span class="keyword">if</span> (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value &lt;&lt; s.bi_valid) &amp; <span class="number">0xffff</span>;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } <span class="keyword">else</span> {
    s.bi_buf |= (value &lt;&lt; s.bi_valid) &amp; <span class="number">0xffff</span>;
    s.bi_valid += length;
  }
}


<span class="function"><span class="keyword">function</span> <span class="title">send_code</span><span class="params">(s, c, tree)</span> {</span>
  send_bits(s, tree[c * <span class="number">2</span>]<span class="comment">/*.Code*/</span>, tree[c * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>);
}


<span class="comment">/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 &lt;= len &lt;= 15
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">bi_reverse</span><span class="params">(code, len)</span> {</span>
  <span class="keyword">var</span> res = <span class="number">0</span>;
  <span class="keyword">do</span> {
    res |= code &amp; <span class="number">1</span>;
    code >>>= <span class="number">1</span>;
    res &lt;&lt;= <span class="number">1</span>;
  } <span class="keyword">while</span> (--len > <span class="number">0</span>);
  <span class="keyword">return</span> res >>> <span class="number">1</span>;
}


<span class="comment">/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">bi_flush</span><span class="params">(s)</span> {</span>
  <span class="keyword">if</span> (s.bi_valid === <span class="number">16</span>) {
    put_short(s, s.bi_buf);
    s.bi_buf = <span class="number">0</span>;
    s.bi_valid = <span class="number">0</span>;

  } <span class="keyword">else</span> <span class="keyword">if</span> (s.bi_valid >= <span class="number">8</span>) {
    s.pending_buf[s.pending++] = s.bi_buf &amp; <span class="number">0xff</span>;
    s.bi_buf >>= <span class="number">8</span>;
    s.bi_valid -= <span class="number">8</span>;
  }
}


<span class="comment">/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">gen_bitlen</span><span class="params">(s, desc)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">tree_desc</span> *<span class="title">desc</span>;    /* <span class="title">the</span> <span class="title">tree</span> <span class="title">descriptor</span> */
{</span>
  <span class="keyword">var</span> tree            = desc.dyn_tree;
  <span class="keyword">var</span> max_code        = desc.max_code;
  <span class="keyword">var</span> stree           = desc.stat_desc.static_tree;
  <span class="keyword">var</span> has_stree       = desc.stat_desc.has_stree;
  <span class="keyword">var</span> extra           = desc.stat_desc.extra_bits;
  <span class="keyword">var</span> base            = desc.stat_desc.extra_base;
  <span class="keyword">var</span> max_length      = desc.stat_desc.max_length;
  <span class="keyword">var</span> h;              <span class="comment">/* heap index */</span>
  <span class="keyword">var</span> n, m;           <span class="comment">/* iterate over the tree elements */</span>
  <span class="keyword">var</span> bits;           <span class="comment">/* bit length */</span>
  <span class="keyword">var</span> xbits;          <span class="comment">/* extra bits */</span>
  <span class="keyword">var</span> f;              <span class="comment">/* frequency */</span>
  <span class="keyword">var</span> overflow = <span class="number">0</span>;   <span class="comment">/* number of elements with bit length too large */</span>

  <span class="keyword">for</span> (bits = <span class="number">0</span>; bits &lt;= MAX_BITS; bits++) {
    s.bl_count[bits] = <span class="number">0</span>;
  }

  <span class="comment">/* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */</span>
  tree[s.heap[s.heap_max] * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">0</span>; <span class="comment">/* root of the heap */</span>

  <span class="keyword">for</span> (h = s.heap_max + <span class="number">1</span>; h &lt; HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Dad*/</span> * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> + <span class="number">1</span>;
    <span class="keyword">if</span> (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = bits;
    <span class="comment">/* We overwrite tree[n].Dad which is no longer needed */</span>

    <span class="keyword">if</span> (n > max_code) { <span class="keyword">continue</span>; } <span class="comment">/* not a leaf node */</span>

    s.bl_count[bits]++;
    xbits = <span class="number">0</span>;
    <span class="keyword">if</span> (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>;
    s.opt_len += f * (bits + xbits);
    <span class="keyword">if</span> (has_stree) {
      s.static_len += f * (stree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> + xbits);
    }
  }
  <span class="keyword">if</span> (overflow === <span class="number">0</span>) { <span class="keyword">return</span>; }

  <span class="comment">// Trace((stderr,"\nbit length overflow\n"));</span>
  <span class="comment">/* This happens for example on obj2 and pic of the Calgary corpus */</span>

  <span class="comment">/* Find the first bit length which could increase: */</span>
  <span class="keyword">do</span> {
    bits = max_length - <span class="number">1</span>;
    <span class="keyword">while</span> (s.bl_count[bits] === <span class="number">0</span>) { bits--; }
    s.bl_count[bits]--;      <span class="comment">/* move one leaf down the tree */</span>
    s.bl_count[bits + <span class="number">1</span>] += <span class="number">2</span>; <span class="comment">/* move one overflow item as its brother */</span>
    s.bl_count[max_length]--;
    <span class="comment">/* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */</span>
    overflow -= <span class="number">2</span>;
  } <span class="keyword">while</span> (overflow > <span class="number">0</span>);

  <span class="comment">/* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */</span>
  <span class="keyword">for</span> (bits = max_length; bits !== <span class="number">0</span>; bits--) {
    n = s.bl_count[bits];
    <span class="keyword">while</span> (n !== <span class="number">0</span>) {
      m = s.heap[--h];
      <span class="keyword">if</span> (m > max_code) { <span class="keyword">continue</span>; }
      <span class="keyword">if</span> (tree[m * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> !== bits) {
        <span class="comment">// Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));</span>
        s.opt_len += (bits - tree[m * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>) * tree[m * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>;
        tree[m * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = bits;
      }
      n--;
    }
  }
}


<span class="comment">/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">gen_codes</span><span class="params">(tree, max_code, bl_count)</span>
//    <span class="title">ct_data</span> *<span class="title">tree</span>;             /* <span class="title">the</span> <span class="title">tree</span> <span class="title">to</span> <span class="title">decorate</span> */
//    <span class="title">int</span> <span class="title">max_code</span>;              /* <span class="title">largest</span> <span class="title">code</span> <span class="title">with</span> <span class="title">non</span> <span class="title">zero</span> <span class="title">frequency</span> */
//    <span class="title">ushf</span> *<span class="title">bl_count</span>;            /* <span class="title">number</span> <span class="title">of</span> <span class="title">codes</span> <span class="title">at</span> <span class="title">each</span> <span class="title">bit</span> <span class="title">length</span> */
{</span>
  <span class="keyword">var</span> next_code = <span class="keyword">new</span> Array(MAX_BITS + <span class="number">1</span>); <span class="comment">/* next code value for each bit length */</span>
  <span class="keyword">var</span> code = <span class="number">0</span>;              <span class="comment">/* running code value */</span>
  <span class="keyword">var</span> bits;                  <span class="comment">/* bit index */</span>
  <span class="keyword">var</span> n;                     <span class="comment">/* code index */</span>

  <span class="comment">/* The distribution counts are first used to generate the code values
   * without bit reversal.
   */</span>
  <span class="keyword">for</span> (bits = <span class="number">1</span>; bits &lt;= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - <span class="number">1</span>]) &lt;&lt; <span class="number">1</span>;
  }
  <span class="comment">/* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */</span>
  <span class="comment">//Assert (code + bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,</span>
  <span class="comment">//        "inconsistent bit counts");</span>
  <span class="comment">//Tracev((stderr,"\ngen_codes: max_code %d ", max_code));</span>

  <span class="keyword">for</span> (n = <span class="number">0</span>;  n &lt;= max_code; n++) {
    <span class="keyword">var</span> len = tree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>;
    <span class="keyword">if</span> (len === <span class="number">0</span>) { <span class="keyword">continue</span>; }
    <span class="comment">/* Now reverse the bits */</span>
    tree[n * <span class="number">2</span>]<span class="comment">/*.Code*/</span> = bi_reverse(next_code[len]++, len);

    <span class="comment">//Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",</span>
    <span class="comment">//     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));</span>
  }
}


<span class="comment">/* ===========================================================================
 * Initialize the various 'constant' tables.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">tr_static_init</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> n;        <span class="comment">/* iterates over tree elements */</span>
  <span class="keyword">var</span> bits;     <span class="comment">/* bit counter */</span>
  <span class="keyword">var</span> length;   <span class="comment">/* length value */</span>
  <span class="keyword">var</span> code;     <span class="comment">/* code value */</span>
  <span class="keyword">var</span> dist;     <span class="comment">/* distance index */</span>
  <span class="keyword">var</span> bl_count = <span class="keyword">new</span> Array(MAX_BITS + <span class="number">1</span>);
  <span class="comment">/* number of codes at each bit length for an optimal tree */</span>

  <span class="comment">// do check in _tr_init()</span>
  <span class="comment">//if (static_init_done) return;</span>

  <span class="comment">/* For some embedded targets, global variables are not initialized: */</span>
<span class="comment">/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/</span>

  <span class="comment">/* Initialize the mapping length (0..255) -> length code (0..28) */</span>
  length = <span class="number">0</span>;
  <span class="keyword">for</span> (code = <span class="number">0</span>; code &lt; LENGTH_CODES - <span class="number">1</span>; code++) {
    base_length[code] = length;
    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; (<span class="number">1</span> &lt;&lt; extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  <span class="comment">//Assert (length == 256, "tr_static_init: length != 256");</span>
  <span class="comment">/* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */</span>
  _length_code[length - <span class="number">1</span>] = code;

  <span class="comment">/* Initialize the mapping dist (0..32K) -> dist code (0..29) */</span>
  dist = <span class="number">0</span>;
  <span class="keyword">for</span> (code = <span class="number">0</span>; code &lt; <span class="number">16</span>; code++) {
    base_dist[code] = dist;
    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; (<span class="number">1</span> &lt;&lt; extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  <span class="comment">//Assert (dist == 256, "tr_static_init: dist != 256");</span>
  dist >>= <span class="number">7</span>; <span class="comment">/* from now on, all distances are divided by 128 */</span>
  <span class="keyword">for</span> (; code &lt; D_CODES; code++) {
    base_dist[code] = dist &lt;&lt; <span class="number">7</span>;
    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; (<span class="number">1</span> &lt;&lt; (extra_dbits[code] - <span class="number">7</span>)); n++) {
      _dist_code[<span class="number">256</span> + dist++] = code;
    }
  }
  <span class="comment">//Assert (dist == 256, "tr_static_init: 256+dist != 512");</span>

  <span class="comment">/* Construct the codes of the static literal tree */</span>
  <span class="keyword">for</span> (bits = <span class="number">0</span>; bits &lt;= MAX_BITS; bits++) {
    bl_count[bits] = <span class="number">0</span>;
  }

  n = <span class="number">0</span>;
  <span class="keyword">while</span> (n &lt;= <span class="number">143</span>) {
    static_ltree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">8</span>;
    n++;
    bl_count[<span class="number">8</span>]++;
  }
  <span class="keyword">while</span> (n &lt;= <span class="number">255</span>) {
    static_ltree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">9</span>;
    n++;
    bl_count[<span class="number">9</span>]++;
  }
  <span class="keyword">while</span> (n &lt;= <span class="number">279</span>) {
    static_ltree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">7</span>;
    n++;
    bl_count[<span class="number">7</span>]++;
  }
  <span class="keyword">while</span> (n &lt;= <span class="number">287</span>) {
    static_ltree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">8</span>;
    n++;
    bl_count[<span class="number">8</span>]++;
  }
  <span class="comment">/* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */</span>
  gen_codes(static_ltree, L_CODES + <span class="number">1</span>, bl_count);

  <span class="comment">/* The static distance tree is trivial: */</span>
  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; D_CODES; n++) {
    static_dtree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">5</span>;
    static_dtree[n * <span class="number">2</span>]<span class="comment">/*.Code*/</span> = bi_reverse(n, <span class="number">5</span>);
  }

  <span class="comment">// Now data ready and we can init static trees</span>
  static_l_desc = <span class="keyword">new</span> StaticTreeDesc(static_ltree, extra_lbits, LITERALS + <span class="number">1</span>, L_CODES, MAX_BITS);
  static_d_desc = <span class="keyword">new</span> StaticTreeDesc(static_dtree, extra_dbits, <span class="number">0</span>,          D_CODES, MAX_BITS);
  static_bl_desc = <span class="keyword">new</span> StaticTreeDesc(<span class="keyword">new</span> Array(<span class="number">0</span>), extra_blbits, <span class="number">0</span>,         BL_CODES, MAX_BL_BITS);

  <span class="comment">//static_init_done = true;</span>
}


<span class="comment">/* ===========================================================================
 * Initialize a new block.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">init_block</span><span class="params">(s)</span> {</span>
  <span class="keyword">var</span> n; <span class="comment">/* iterates over tree elements */</span>

  <span class="comment">/* Initialize the trees. */</span>
  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; L_CODES;  n++) { s.dyn_ltree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> = <span class="number">0</span>; }
  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; D_CODES;  n++) { s.dyn_dtree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> = <span class="number">0</span>; }
  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; BL_CODES; n++) { s.bl_tree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> = <span class="number">0</span>; }

  s.dyn_ltree[END_BLOCK * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> = <span class="number">1</span>;
  s.opt_len = s.static_len = <span class="number">0</span>;
  s.last_lit = s.matches = <span class="number">0</span>;
}


<span class="comment">/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">bi_windup</span><span class="params">(s)</span>
{</span>
  <span class="keyword">if</span> (s.bi_valid > <span class="number">8</span>) {
    put_short(s, s.bi_buf);
  } <span class="keyword">else</span> <span class="keyword">if</span> (s.bi_valid > <span class="number">0</span>) {
    <span class="comment">//put_byte(s, (Byte)s->bi_buf);</span>
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = <span class="number">0</span>;
  s.bi_valid = <span class="number">0</span>;
}

<span class="comment">/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">copy_block</span><span class="params">(s, buf, len, header)</span>
//<span class="title">DeflateState</span> *<span class="title">s</span>;
//<span class="title">charf</span>    *<span class="title">buf</span>;    /* <span class="title">the</span> <span class="title">input</span> <span class="title">data</span> */
//<span class="title">unsigned</span> <span class="title">len</span>;     /* <span class="title">its</span> <span class="title">length</span> */
//<span class="title">int</span>      <span class="title">header</span>;  /* <span class="title">true</span> <span class="title">if</span> <span class="title">block</span> <span class="title">header</span> <span class="title">must</span> <span class="title">be</span> <span class="title">written</span> */
{</span>
  bi_windup(s);        <span class="comment">/* align on byte boundary */</span>

  <span class="keyword">if</span> (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
<span class="comment">//  while (len--) {</span>
<span class="comment">//    put_byte(s, *buf++);</span>
<span class="comment">//  }</span>
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

<span class="comment">/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">smaller</span><span class="params">(tree, n, m, depth)</span> {</span>
  <span class="keyword">var</span> _n2 = n * <span class="number">2</span>;
  <span class="keyword">var</span> _m2 = m * <span class="number">2</span>;
  <span class="keyword">return</span> (tree[_n2]<span class="comment">/*.Freq*/</span> &lt; tree[_m2]<span class="comment">/*.Freq*/</span> ||
         (tree[_n2]<span class="comment">/*.Freq*/</span> === tree[_m2]<span class="comment">/*.Freq*/</span> &amp;&amp; depth[n] &lt;= depth[m]));
}

<span class="comment">/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">pqdownheap</span><span class="params">(s, tree, k)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">ct_data</span> *<span class="title">tree</span>;  /* <span class="title">the</span> <span class="title">tree</span> <span class="title">to</span> <span class="title">restore</span> */
//    <span class="title">int</span> <span class="title">k</span>;               /* <span class="title">node</span> <span class="title">to</span> <span class="title">move</span> <span class="title">down</span> */
{</span>
  <span class="keyword">var</span> v = s.heap[k];
  <span class="keyword">var</span> j = k &lt;&lt; <span class="number">1</span>;  <span class="comment">/* left son of k */</span>
  <span class="keyword">while</span> (j &lt;= s.heap_len) {
    <span class="comment">/* Set j to the smallest of the two sons: */</span>
    <span class="keyword">if</span> (j &lt; s.heap_len &amp;&amp;
      smaller(tree, s.heap[j + <span class="number">1</span>], s.heap[j], s.depth)) {
      j++;
    }
    <span class="comment">/* Exit if v is smaller than both sons */</span>
    <span class="keyword">if</span> (smaller(tree, v, s.heap[j], s.depth)) { <span class="keyword">break</span>; }

    <span class="comment">/* Exchange v with the smallest son */</span>
    s.heap[k] = s.heap[j];
    k = j;

    <span class="comment">/* And continue down the tree, setting j to the left son of k */</span>
    j &lt;&lt;= <span class="number">1</span>;
  }
  s.heap[k] = v;
}


<span class="comment">// inlined manually</span>
<span class="comment">// var SMALLEST = 1;</span>

<span class="comment">/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">compress_block</span><span class="params">(s, ltree, dtree)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">const</span> <span class="title">ct_data</span> *<span class="title">ltree</span>; /* <span class="title">literal</span> <span class="title">tree</span> */
//    <span class="title">const</span> <span class="title">ct_data</span> *<span class="title">dtree</span>; /* <span class="title">distance</span> <span class="title">tree</span> */
{</span>
  <span class="keyword">var</span> dist;           <span class="comment">/* distance of matched string */</span>
  <span class="keyword">var</span> lc;             <span class="comment">/* match length or unmatched char (if dist == 0) */</span>
  <span class="keyword">var</span> lx = <span class="number">0</span>;         <span class="comment">/* running index in l_buf */</span>
  <span class="keyword">var</span> code;           <span class="comment">/* the code to send */</span>
  <span class="keyword">var</span> extra;          <span class="comment">/* number of extra bits to send */</span>

  <span class="keyword">if</span> (s.last_lit !== <span class="number">0</span>) {
    <span class="keyword">do</span> {
      dist = (s.pending_buf[s.d_buf + lx * <span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | (s.pending_buf[s.d_buf + lx * <span class="number">2</span> + <span class="number">1</span>]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      <span class="keyword">if</span> (dist === <span class="number">0</span>) {
        send_code(s, lc, ltree); <span class="comment">/* send a literal byte */</span>
        <span class="comment">//Tracecv(isgraph(lc), (stderr," '%c' ", lc));</span>
      } <span class="keyword">else</span> {
        <span class="comment">/* Here, lc is the match length - MIN_MATCH */</span>
        code = _length_code[lc];
        send_code(s, code + LITERALS + <span class="number">1</span>, ltree); <span class="comment">/* send the length code */</span>
        extra = extra_lbits[code];
        <span class="keyword">if</span> (extra !== <span class="number">0</span>) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       <span class="comment">/* send the extra length bits */</span>
        }
        dist--; <span class="comment">/* dist is now the match distance - 1 */</span>
        code = d_code(dist);
        <span class="comment">//Assert (code &lt; D_CODES, "bad d_code");</span>

        send_code(s, code, dtree);       <span class="comment">/* send the distance code */</span>
        extra = extra_dbits[code];
        <span class="keyword">if</span> (extra !== <span class="number">0</span>) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   <span class="comment">/* send the extra distance bits */</span>
        }
      } <span class="comment">/* literal or match pair ? */</span>

      <span class="comment">/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */</span>
      <span class="comment">//Assert((uInt)(s->pending) &lt; s->lit_bufsize + 2*lx,</span>
      <span class="comment">//       "pendingBuf overflow");</span>

    } <span class="keyword">while</span> (lx &lt; s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


<span class="comment">/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">build_tree</span><span class="params">(s, desc)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">tree_desc</span> *<span class="title">desc</span>; /* <span class="title">the</span> <span class="title">tree</span> <span class="title">descriptor</span> */
{</span>
  <span class="keyword">var</span> tree     = desc.dyn_tree;
  <span class="keyword">var</span> stree    = desc.stat_desc.static_tree;
  <span class="keyword">var</span> has_stree = desc.stat_desc.has_stree;
  <span class="keyword">var</span> elems    = desc.stat_desc.elems;
  <span class="keyword">var</span> n, m;          <span class="comment">/* iterate over heap elements */</span>
  <span class="keyword">var</span> max_code = -<span class="number">1</span>; <span class="comment">/* largest code with non zero frequency */</span>
  <span class="keyword">var</span> node;          <span class="comment">/* new node being created */</span>

  <span class="comment">/* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */</span>
  s.heap_len = <span class="number">0</span>;
  s.heap_max = HEAP_SIZE;

  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; elems; n++) {
    <span class="keyword">if</span> (tree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> !== <span class="number">0</span>) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = <span class="number">0</span>;

    } <span class="keyword">else</span> {
      tree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">0</span>;
    }
  }

  <span class="comment">/* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */</span>
  <span class="keyword">while</span> (s.heap_len &lt; <span class="number">2</span>) {
    node = s.heap[++s.heap_len] = (max_code &lt; <span class="number">2</span> ? ++max_code : <span class="number">0</span>);
    tree[node * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> = <span class="number">1</span>;
    s.depth[node] = <span class="number">0</span>;
    s.opt_len--;

    <span class="keyword">if</span> (has_stree) {
      s.static_len -= stree[node * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>;
    }
    <span class="comment">/* node is 0 or 1 so it does not have extra bits */</span>
  }
  desc.max_code = max_code;

  <span class="comment">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */</span>
  <span class="keyword">for</span> (n = (s.heap_len >> <span class="number">1</span><span class="comment">/*int /2*/</span>); n >= <span class="number">1</span>; n--) { pqdownheap(s, tree, n); }

  <span class="comment">/* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */</span>
  node = elems;              <span class="comment">/* next internal node of the tree */</span>
  <span class="keyword">do</span> {
    <span class="comment">//pqremove(s, tree, n);  /* n = node of least frequency */</span>
    <span class="comment">/*** pqremove ***/</span>
    n = s.heap[<span class="number">1</span><span class="comment">/*SMALLEST*/</span>];
    s.heap[<span class="number">1</span><span class="comment">/*SMALLEST*/</span>] = s.heap[s.heap_len--];
    pqdownheap(s, tree, <span class="number">1</span><span class="comment">/*SMALLEST*/</span>);
    <span class="comment">/***/</span>

    m = s.heap[<span class="number">1</span><span class="comment">/*SMALLEST*/</span>]; <span class="comment">/* m = node of next least frequency */</span>

    s.heap[--s.heap_max] = n; <span class="comment">/* keep the nodes sorted by frequency */</span>
    s.heap[--s.heap_max] = m;

    <span class="comment">/* Create a new node father of n and m */</span>
    tree[node * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> = tree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> + tree[m * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + <span class="number">1</span>;
    tree[n * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Dad*/</span> = tree[m * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Dad*/</span> = node;

    <span class="comment">/* and insert the new node in the heap */</span>
    s.heap[<span class="number">1</span><span class="comment">/*SMALLEST*/</span>] = node++;
    pqdownheap(s, tree, <span class="number">1</span><span class="comment">/*SMALLEST*/</span>);

  } <span class="keyword">while</span> (s.heap_len >= <span class="number">2</span>);

  s.heap[--s.heap_max] = s.heap[<span class="number">1</span><span class="comment">/*SMALLEST*/</span>];

  <span class="comment">/* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */</span>
  gen_bitlen(s, desc);

  <span class="comment">/* The field len is now set, we can generate the bit codes */</span>
  gen_codes(tree, max_code, s.bl_count);
}


<span class="comment">/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">scan_tree</span><span class="params">(s, tree, max_code)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">ct_data</span> *<span class="title">tree</span>;   /* <span class="title">the</span> <span class="title">tree</span> <span class="title">to</span> <span class="title">be</span> <span class="title">scanned</span> */
//    <span class="title">int</span> <span class="title">max_code</span>;    /* <span class="title">and</span> <span class="title">its</span> <span class="title">largest</span> <span class="title">code</span> <span class="title">of</span> <span class="title">non</span> <span class="title">zero</span> <span class="title">frequency</span> */
{</span>
  <span class="keyword">var</span> n;                     <span class="comment">/* iterates over all tree elements */</span>
  <span class="keyword">var</span> prevlen = -<span class="number">1</span>;          <span class="comment">/* last emitted length */</span>
  <span class="keyword">var</span> curlen;                <span class="comment">/* length of current code */</span>

  <span class="keyword">var</span> nextlen = tree[<span class="number">0</span> * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>; <span class="comment">/* length of next code */</span>

  <span class="keyword">var</span> count = <span class="number">0</span>;             <span class="comment">/* repeat count of the current code */</span>
  <span class="keyword">var</span> max_count = <span class="number">7</span>;         <span class="comment">/* max repeat count */</span>
  <span class="keyword">var</span> min_count = <span class="number">4</span>;         <span class="comment">/* min repeat count */</span>

  <span class="keyword">if</span> (nextlen === <span class="number">0</span>) {
    max_count = <span class="number">138</span>;
    min_count = <span class="number">3</span>;
  }
  tree[(max_code + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> = <span class="number">0xffff</span>; <span class="comment">/* guard */</span>

  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt;= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>;

    <span class="keyword">if</span> (++count &lt; max_count &amp;&amp; curlen === nextlen) {
      <span class="keyword">continue</span>;

    } <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; min_count) {
      s.bl_tree[curlen * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> += count;

    } <span class="keyword">else</span> <span class="keyword">if</span> (curlen !== <span class="number">0</span>) {

      <span class="keyword">if</span> (curlen !== prevlen) { s.bl_tree[curlen * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>++; }
      s.bl_tree[REP_3_6 * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>++;

    } <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">10</span>) {
      s.bl_tree[REPZ_3_10 * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>++;

    } <span class="keyword">else</span> {
      s.bl_tree[REPZ_11_138 * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>++;
    }

    count = <span class="number">0</span>;
    prevlen = curlen;

    <span class="keyword">if</span> (nextlen === <span class="number">0</span>) {
      max_count = <span class="number">138</span>;
      min_count = <span class="number">3</span>;

    } <span class="keyword">else</span> <span class="keyword">if</span> (curlen === nextlen) {
      max_count = <span class="number">6</span>;
      min_count = <span class="number">3</span>;

    } <span class="keyword">else</span> {
      max_count = <span class="number">7</span>;
      min_count = <span class="number">4</span>;
    }
  }
}


<span class="comment">/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">send_tree</span><span class="params">(s, tree, max_code)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">ct_data</span> *<span class="title">tree</span>; /* <span class="title">the</span> <span class="title">tree</span> <span class="title">to</span> <span class="title">be</span> <span class="title">scanned</span> */
//    <span class="title">int</span> <span class="title">max_code</span>;       /* <span class="title">and</span> <span class="title">its</span> <span class="title">largest</span> <span class="title">code</span> <span class="title">of</span> <span class="title">non</span> <span class="title">zero</span> <span class="title">frequency</span> */
{</span>
  <span class="keyword">var</span> n;                     <span class="comment">/* iterates over all tree elements */</span>
  <span class="keyword">var</span> prevlen = -<span class="number">1</span>;          <span class="comment">/* last emitted length */</span>
  <span class="keyword">var</span> curlen;                <span class="comment">/* length of current code */</span>

  <span class="keyword">var</span> nextlen = tree[<span class="number">0</span> * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>; <span class="comment">/* length of next code */</span>

  <span class="keyword">var</span> count = <span class="number">0</span>;             <span class="comment">/* repeat count of the current code */</span>
  <span class="keyword">var</span> max_count = <span class="number">7</span>;         <span class="comment">/* max repeat count */</span>
  <span class="keyword">var</span> min_count = <span class="number">4</span>;         <span class="comment">/* min repeat count */</span>

  <span class="comment">/* tree[max_code+1].Len = -1; */</span>  <span class="comment">/* guard already set */</span>
  <span class="keyword">if</span> (nextlen === <span class="number">0</span>) {
    max_count = <span class="number">138</span>;
    min_count = <span class="number">3</span>;
  }

  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt;= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>;

    <span class="keyword">if</span> (++count &lt; max_count &amp;&amp; curlen === nextlen) {
      <span class="keyword">continue</span>;

    } <span class="keyword">else</span> <span class="keyword">if</span> (count &lt; min_count) {
      <span class="keyword">do</span> { send_code(s, curlen, s.bl_tree); } <span class="keyword">while</span> (--count !== <span class="number">0</span>);

    } <span class="keyword">else</span> <span class="keyword">if</span> (curlen !== <span class="number">0</span>) {
      <span class="keyword">if</span> (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      <span class="comment">//Assert(count >= 3 &amp;&amp; count &lt;= 6, " 3_6?");</span>
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - <span class="number">3</span>, <span class="number">2</span>);

    } <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">10</span>) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - <span class="number">3</span>, <span class="number">3</span>);

    } <span class="keyword">else</span> {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - <span class="number">11</span>, <span class="number">7</span>);
    }

    count = <span class="number">0</span>;
    prevlen = curlen;
    <span class="keyword">if</span> (nextlen === <span class="number">0</span>) {
      max_count = <span class="number">138</span>;
      min_count = <span class="number">3</span>;

    } <span class="keyword">else</span> <span class="keyword">if</span> (curlen === nextlen) {
      max_count = <span class="number">6</span>;
      min_count = <span class="number">3</span>;

    } <span class="keyword">else</span> {
      max_count = <span class="number">7</span>;
      min_count = <span class="number">4</span>;
    }
  }
}


<span class="comment">/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">build_bl_tree</span><span class="params">(s)</span> {</span>
  <span class="keyword">var</span> max_blindex;  <span class="comment">/* index of last bit length code of non zero freq */</span>

  <span class="comment">/* Determine the bit length frequencies for literal and distance trees */</span>
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  <span class="comment">/* Build the bit length tree: */</span>
  build_tree(s, s.bl_desc);
  <span class="comment">/* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */</span>

  <span class="comment">/* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */</span>
  <span class="keyword">for</span> (max_blindex = BL_CODES - <span class="number">1</span>; max_blindex >= <span class="number">3</span>; max_blindex--) {
    <span class="keyword">if</span> (s.bl_tree[bl_order[max_blindex] * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span> !== <span class="number">0</span>) {
      <span class="keyword">break</span>;
    }
  }
  <span class="comment">/* Update opt_len to include the bit length tree and counts */</span>
  s.opt_len += <span class="number">3</span> * (max_blindex + <span class="number">1</span>) + <span class="number">5</span> + <span class="number">5</span> + <span class="number">4</span>;
  <span class="comment">//Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",</span>
  <span class="comment">//        s->opt_len, s->static_len));</span>

  <span class="keyword">return</span> max_blindex;
}


<span class="comment">/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">send_all_trees</span><span class="params">(s, lcodes, dcodes, blcodes)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">int</span> <span class="title">lcodes</span>, <span class="title">dcodes</span>, <span class="title">blcodes</span>; /* <span class="title">number</span> <span class="title">of</span> <span class="title">codes</span> <span class="title">for</span> <span class="title">each</span> <span class="title">tree</span> */
{</span>
  <span class="keyword">var</span> rank;                    <span class="comment">/* index in bl_order */</span>

  <span class="comment">//Assert (lcodes >= 257 &amp;&amp; dcodes >= 1 &amp;&amp; blcodes >= 4, "not enough codes");</span>
  <span class="comment">//Assert (lcodes &lt;= L_CODES &amp;&amp; dcodes &lt;= D_CODES &amp;&amp; blcodes &lt;= BL_CODES,</span>
  <span class="comment">//        "too many codes");</span>
  <span class="comment">//Tracev((stderr, "\nbl counts: "));</span>
  send_bits(s, lcodes - <span class="number">257</span>, <span class="number">5</span>); <span class="comment">/* not +255 as stated in appnote.txt */</span>
  send_bits(s, dcodes - <span class="number">1</span>,   <span class="number">5</span>);
  send_bits(s, blcodes - <span class="number">4</span>,  <span class="number">4</span>); <span class="comment">/* not -3 as stated in appnote.txt */</span>
  <span class="keyword">for</span> (rank = <span class="number">0</span>; rank &lt; blcodes; rank++) {
    <span class="comment">//Tracev((stderr, "\nbl code %2d ", bl_order[rank]));</span>
    send_bits(s, s.bl_tree[bl_order[rank] * <span class="number">2</span> + <span class="number">1</span>]<span class="comment">/*.Len*/</span>, <span class="number">3</span>);
  }
  <span class="comment">//Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));</span>

  send_tree(s, s.dyn_ltree, lcodes - <span class="number">1</span>); <span class="comment">/* literal tree */</span>
  <span class="comment">//Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));</span>

  send_tree(s, s.dyn_dtree, dcodes - <span class="number">1</span>); <span class="comment">/* distance tree */</span>
  <span class="comment">//Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));</span>
}


<span class="comment">/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">detect_data_type</span><span class="params">(s)</span> {</span>
  <span class="comment">/* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */</span>
  <span class="keyword">var</span> black_mask = <span class="number">0xf3ffc07f</span>;
  <span class="keyword">var</span> n;

  <span class="comment">/* Check for non-textual ("black-listed") bytes. */</span>
  <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt;= <span class="number">31</span>; n++, black_mask >>>= <span class="number">1</span>) {
    <span class="keyword">if</span> ((black_mask &amp; <span class="number">1</span>) &amp;&amp; (s.dyn_ltree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> !== <span class="number">0</span>)) {
      <span class="keyword">return</span> Z_BINARY;
    }
  }

  <span class="comment">/* Check for textual ("white-listed") bytes. */</span>
  <span class="keyword">if</span> (s.dyn_ltree[<span class="number">9</span> * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> !== <span class="number">0</span> || s.dyn_ltree[<span class="number">10</span> * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> !== <span class="number">0</span> ||
      s.dyn_ltree[<span class="number">13</span> * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> !== <span class="number">0</span>) {
    <span class="keyword">return</span> Z_TEXT;
  }
  <span class="keyword">for</span> (n = <span class="number">32</span>; n &lt; LITERALS; n++) {
    <span class="keyword">if</span> (s.dyn_ltree[n * <span class="number">2</span>]<span class="comment">/*.Freq*/</span> !== <span class="number">0</span>) {
      <span class="keyword">return</span> Z_TEXT;
    }
  }

  <span class="comment">/* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */</span>
  <span class="keyword">return</span> Z_BINARY;
}


<span class="keyword">var</span> static_init_done = <span class="literal">false</span>;

<span class="comment">/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">_tr_init</span><span class="params">(s)</span>
{</span>

  <span class="keyword">if</span> (!static_init_done) {
    tr_static_init();
    static_init_done = <span class="literal">true</span>;
  }

  s.l_desc  = <span class="keyword">new</span> TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = <span class="keyword">new</span> TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = <span class="keyword">new</span> TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = <span class="number">0</span>;
  s.bi_valid = <span class="number">0</span>;

  <span class="comment">/* Initialize the first block of the first file: */</span>
  init_block(s);
}


<span class="comment">/* ===========================================================================
 * Send a stored block
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">_tr_stored_block</span><span class="params">(s, buf, stored_len, last)</span>
//<span class="title">DeflateState</span> *<span class="title">s</span>;
//<span class="title">charf</span> *<span class="title">buf</span>;       /* <span class="title">input</span> <span class="title">block</span> */
//<span class="title">ulg</span> <span class="title">stored_len</span>;   /* <span class="title">length</span> <span class="title">of</span> <span class="title">input</span> <span class="title">block</span> */
//<span class="title">int</span> <span class="title">last</span>;         /* <span class="title">one</span> <span class="title">if</span> <span class="title">this</span> <span class="title">is</span> <span class="title">the</span> <span class="title">last</span> <span class="title">block</span> <span class="title">for</span> <span class="title">a</span> <span class="title">file</span> */
{</span>
  send_bits(s, (STORED_BLOCK &lt;&lt; <span class="number">1</span>) + (last ? <span class="number">1</span> : <span class="number">0</span>), <span class="number">3</span>);    <span class="comment">/* send block type */</span>
  copy_block(s, buf, stored_len, <span class="literal">true</span>); <span class="comment">/* with header */</span>
}


<span class="comment">/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">_tr_align</span><span class="params">(s)</span> {</span>
  send_bits(s, STATIC_TREES &lt;&lt; <span class="number">1</span>, <span class="number">3</span>);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


<span class="comment">/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">_tr_flush_block</span><span class="params">(s, buf, stored_len, last)</span>
//<span class="title">DeflateState</span> *<span class="title">s</span>;
//<span class="title">charf</span> *<span class="title">buf</span>;       /* <span class="title">input</span> <span class="title">block</span>, <span class="title">or</span> <span class="title">NULL</span> <span class="title">if</span> <span class="title">too</span> <span class="title">old</span> */
//<span class="title">ulg</span> <span class="title">stored_len</span>;   /* <span class="title">length</span> <span class="title">of</span> <span class="title">input</span> <span class="title">block</span> */
//<span class="title">int</span> <span class="title">last</span>;         /* <span class="title">one</span> <span class="title">if</span> <span class="title">this</span> <span class="title">is</span> <span class="title">the</span> <span class="title">last</span> <span class="title">block</span> <span class="title">for</span> <span class="title">a</span> <span class="title">file</span> */
{</span>
  <span class="keyword">var</span> opt_lenb, static_lenb;  <span class="comment">/* opt_len and static_len in bytes */</span>
  <span class="keyword">var</span> max_blindex = <span class="number">0</span>;        <span class="comment">/* index of last bit length code of non zero freq */</span>

  <span class="comment">/* Build the Huffman trees unless a stored block is forced */</span>
  <span class="keyword">if</span> (s.level > <span class="number">0</span>) {

    <span class="comment">/* Check if the file is binary or text */</span>
    <span class="keyword">if</span> (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    <span class="comment">/* Construct the literal and distance trees */</span>
    build_tree(s, s.l_desc);
    <span class="comment">// Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,</span>
    <span class="comment">//        s->static_len));</span>

    build_tree(s, s.d_desc);
    <span class="comment">// Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,</span>
    <span class="comment">//        s->static_len));</span>
    <span class="comment">/* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */</span>

    <span class="comment">/* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */</span>
    max_blindex = build_bl_tree(s);

    <span class="comment">/* Determine the best encoding. Compute the block lengths in bytes. */</span>
    opt_lenb = (s.opt_len + <span class="number">3</span> + <span class="number">7</span>) >>> <span class="number">3</span>;
    static_lenb = (s.static_len + <span class="number">3</span> + <span class="number">7</span>) >>> <span class="number">3</span>;

    <span class="comment">// Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",</span>
    <span class="comment">//        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,</span>
    <span class="comment">//        s->last_lit));</span>

    <span class="keyword">if</span> (static_lenb &lt;= opt_lenb) { opt_lenb = static_lenb; }

  } <span class="keyword">else</span> {
    <span class="comment">// Assert(buf != (char*)0, "lost buf");</span>
    opt_lenb = static_lenb = stored_len + <span class="number">5</span>; <span class="comment">/* force a stored block */</span>
  }

  <span class="keyword">if</span> ((stored_len + <span class="number">4</span> &lt;= opt_lenb) &amp;&amp; (buf !== -<span class="number">1</span>)) {
    <span class="comment">/* 4: two words for the lengths */</span>

    <span class="comment">/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to
     * transform a block into a stored block.
     */</span>
    _tr_stored_block(s, buf, stored_len, last);

  } <span class="keyword">else</span> <span class="keyword">if</span> (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES &lt;&lt; <span class="number">1</span>) + (last ? <span class="number">1</span> : <span class="number">0</span>), <span class="number">3</span>);
    compress_block(s, static_ltree, static_dtree);

  } <span class="keyword">else</span> {
    send_bits(s, (DYN_TREES &lt;&lt; <span class="number">1</span>) + (last ? <span class="number">1</span> : <span class="number">0</span>), <span class="number">3</span>);
    send_all_trees(s, s.l_desc.max_code + <span class="number">1</span>, s.d_desc.max_code + <span class="number">1</span>, max_blindex + <span class="number">1</span>);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  <span class="comment">// Assert (s->compressed_len == s->bits_sent, "bad compressed size");</span>
  <span class="comment">/* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */</span>
  init_block(s);

  <span class="keyword">if</span> (last) {
    bi_windup(s);
  }
  <span class="comment">// Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,</span>
  <span class="comment">//       s->compressed_len-7*last));</span>
}

<span class="comment">/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">_tr_tally</span><span class="params">(s, dist, lc)</span>
//    <span class="title">deflate_state</span> *<span class="title">s</span>;
//    <span class="title">unsigned</span> <span class="title">dist</span>;  /* <span class="title">distance</span> <span class="title">of</span> <span class="title">matched</span> <span class="title">string</span> */
//    <span class="title">unsigned</span> <span class="title">lc</span>;    /* <span class="title">match</span> <span class="title">length</span>-<span class="title">MIN_MATCH</span> <span class="title">or</span> <span class="title">unmatched</span> <span class="title">char</span> <span class="params">(if dist==0)</span> */
{</span>
  <span class="comment">//var out_length, in_length, dcode;</span>

  s.pending_buf[s.d_buf + s.last_lit * <span class="number">2</span>]     = (dist >>> <span class="number">8</span>) &amp; <span class="number">0xff</span>;
  s.pending_buf[s.d_buf + s.last_lit * <span class="number">2</span> + <span class="number">1</span>] = dist &amp; <span class="number">0xff</span>;

  s.pending_buf[s.l_buf + s.last_lit] = lc &amp; <span class="number">0xff</span>;
  s.last_lit++;

  <span class="keyword">if</span> (dist === <span class="number">0</span>) {
    <span class="comment">/* lc is the unmatched char */</span>
    s.dyn_ltree[lc * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>++;
  } <span class="keyword">else</span> {
    s.matches++;
    <span class="comment">/* Here, lc is the match length - MIN_MATCH */</span>
    dist--;             <span class="comment">/* dist = match distance - 1 */</span>
    <span class="comment">//Assert((ush)dist &lt; (ush)MAX_DIST(s) &amp;&amp;</span>
    <span class="comment">//       (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;</span>
    <span class="comment">//       (ush)d_code(dist) &lt; (ush)D_CODES,  "_tr_tally: bad match");</span>

    s.dyn_ltree[(_length_code[lc] + LITERALS + <span class="number">1</span>) * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>++;
    s.dyn_dtree[d_code(dist) * <span class="number">2</span>]<span class="comment">/*.Freq*/</span>++;
  }

<span class="comment">// (!) This block is disabled in zlib defaults,</span>
<span class="comment">// don't enable it for binary compatibility</span>

<span class="comment">//#ifdef TRUNCATE_BLOCK</span>
<span class="comment">//  /* Try to guess if it is profitable to stop the current block here */</span>
<span class="comment">//  if ((s.last_lit &amp; 0x1fff) === 0 &amp;&amp; s.level > 2) {</span>
<span class="comment">//    /* Compute an upper bound for the compressed length */</span>
<span class="comment">//    out_length = s.last_lit*8;</span>
<span class="comment">//    in_length = s.strstart - s.block_start;</span>
<span class="comment">//</span>
<span class="comment">//    for (dcode = 0; dcode &lt; D_CODES; dcode++) {</span>
<span class="comment">//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);</span>
<span class="comment">//    }</span>
<span class="comment">//    out_length >>>= 3;</span>
<span class="comment">//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",</span>
<span class="comment">//    //       s->last_lit, in_length, out_length,</span>
<span class="comment">//    //       100L - out_length*100L/in_length));</span>
<span class="comment">//    if (s.matches &lt; (s.last_lit>>1)/*int /2*/ &amp;&amp; out_length &lt; (in_length>>1)/*int /2*/) {</span>
<span class="comment">//      return true;</span>
<span class="comment">//    }</span>
<span class="comment">//  }</span>
<span class="comment">//#endif</span>

  <span class="keyword">return</span> (s.last_lit === s.lit_bufsize - <span class="number">1</span>);
  <span class="comment">/* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */</span>
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;
</code></pre>