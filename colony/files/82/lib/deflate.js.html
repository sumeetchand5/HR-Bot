<h1>deflate.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;


<span class="keyword">var</span> zlib_deflate = require(<span class="string">'./zlib/deflate'</span>);
<span class="keyword">var</span> utils        = require(<span class="string">'./utils/common'</span>);
<span class="keyword">var</span> strings      = require(<span class="string">'./utils/strings'</span>);
<span class="keyword">var</span> msg          = require(<span class="string">'./zlib/messages'</span>);
<span class="keyword">var</span> ZStream      = require(<span class="string">'./zlib/zstream'</span>);

<span class="keyword">var</span> toString = Object.prototype.toString;

<span class="comment">/* Public constants ==========================================================*/</span>
<span class="comment">/* ===========================================================================*/</span>

<span class="keyword">var</span> Z_NO_FLUSH      = <span class="number">0</span>;
<span class="keyword">var</span> Z_FINISH        = <span class="number">4</span>;

<span class="keyword">var</span> Z_OK            = <span class="number">0</span>;
<span class="keyword">var</span> Z_STREAM_END    = <span class="number">1</span>;
<span class="keyword">var</span> Z_SYNC_FLUSH    = <span class="number">2</span>;

<span class="keyword">var</span> Z_DEFAULT_COMPRESSION = -<span class="number">1</span>;

<span class="keyword">var</span> Z_DEFAULT_STRATEGY    = <span class="number">0</span>;

<span class="keyword">var</span> Z_DEFLATED  = <span class="number">8</span>;

<span class="comment">/* ===========================================================================*/</span>


<span class="comment">/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/</span>

<span class="comment">/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/</span>

<span class="comment">/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/</span>

<span class="comment">/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/</span>

<span class="comment">/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/</span>


<span class="comment">/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/</span>
<span class="function"><span class="keyword">function</span> <span class="title">Deflate</span><span class="params">(options)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Deflate)) <span class="keyword">return</span> <span class="keyword">new</span> Deflate(options);

  <span class="keyword">this</span>.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: <span class="number">16384</span>,
    windowBits: <span class="number">15</span>,
    memLevel: <span class="number">8</span>,
    strategy: Z_DEFAULT_STRATEGY,
    to: <span class="string">''</span>
  }, options || {});

  <span class="keyword">var</span> opt = <span class="keyword">this</span>.options;

  <span class="keyword">if</span> (opt.raw &amp;&amp; (opt.windowBits > <span class="number">0</span>)) {
    opt.windowBits = -opt.windowBits;
  }

  <span class="keyword">else</span> <span class="keyword">if</span> (opt.gzip &amp;&amp; (opt.windowBits > <span class="number">0</span>) &amp;&amp; (opt.windowBits &lt; <span class="number">16</span>)) {
    opt.windowBits += <span class="number">16</span>;
  }

  <span class="keyword">this</span>.err    = <span class="number">0</span>;      <span class="comment">// error code, if happens (0 = Z_OK)</span>
  <span class="keyword">this</span>.msg    = <span class="string">''</span>;     <span class="comment">// error message</span>
  <span class="keyword">this</span>.ended  = <span class="literal">false</span>;  <span class="comment">// used to avoid multiple onEnd() calls</span>
  <span class="keyword">this</span>.chunks = [];     <span class="comment">// chunks of compressed data</span>

  <span class="keyword">this</span>.strm = <span class="keyword">new</span> ZStream();
  <span class="keyword">this</span>.strm.avail_out = <span class="number">0</span>;

  <span class="keyword">var</span> status = zlib_deflate.deflateInit2(
    <span class="keyword">this</span>.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  <span class="keyword">if</span> (status !== Z_OK) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(msg[status]);
  }

  <span class="keyword">if</span> (opt.header) {
    zlib_deflate.deflateSetHeader(<span class="keyword">this</span>.strm, opt.header);
  }

  <span class="keyword">if</span> (opt.dictionary) {
    <span class="keyword">var</span> dict;
    <span class="comment">// Convert data if needed</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> opt.dictionary === <span class="string">'string'</span>) {
      <span class="comment">// If we need to compress text, change encoding to utf8.</span>
      dict = strings.string2buf(opt.dictionary);
    } <span class="keyword">else</span> <span class="keyword">if</span> (toString.call(opt.dictionary) === <span class="string">'[object ArrayBuffer]'</span>) {
      dict = <span class="keyword">new</span> Uint8Array(opt.dictionary);
    } <span class="keyword">else</span> {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(<span class="keyword">this</span>.strm, dict);

    <span class="keyword">if</span> (status !== Z_OK) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(msg[status]);
    }

    <span class="keyword">this</span>._dict_set = <span class="literal">true</span>;
  }
}

<span class="comment">/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/</span>
Deflate.prototype.push = <span class="function"><span class="keyword">function</span> <span class="params">(data, mode)</span> {</span>
  <span class="keyword">var</span> strm = <span class="keyword">this</span>.strm;
  <span class="keyword">var</span> chunkSize = <span class="keyword">this</span>.options.chunkSize;
  <span class="keyword">var</span> status, _mode;

  <span class="keyword">if</span> (<span class="keyword">this</span>.ended) { <span class="keyword">return</span> <span class="literal">false</span>; }

  _mode = (mode === ~~mode) ? mode : ((mode === <span class="literal">true</span>) ? Z_FINISH : Z_NO_FLUSH);

  <span class="comment">// Convert data if needed</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) {
    <span class="comment">// If we need to compress text, change encoding to utf8.</span>
    strm.input = strings.string2buf(data);
  } <span class="keyword">else</span> <span class="keyword">if</span> (toString.call(data) === <span class="string">'[object ArrayBuffer]'</span>) {
    strm.input = <span class="keyword">new</span> Uint8Array(data);
  } <span class="keyword">else</span> {
    strm.input = data;
  }

  strm.next_in = <span class="number">0</span>;
  strm.avail_in = strm.input.length;

  <span class="keyword">do</span> {
    <span class="keyword">if</span> (strm.avail_out === <span class="number">0</span>) {
      strm.output = <span class="keyword">new</span> utils.Buf8(chunkSize);
      strm.next_out = <span class="number">0</span>;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    <span class="comment">/* no bad return value */</span>

    <span class="keyword">if</span> (status !== Z_STREAM_END &amp;&amp; status !== Z_OK) {
      <span class="keyword">this</span>.onEnd(status);
      <span class="keyword">this</span>.ended = <span class="literal">true</span>;
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">if</span> (strm.avail_out === <span class="number">0</span> || (strm.avail_in === <span class="number">0</span> &amp;&amp; (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.options.to === <span class="string">'string'</span>) {
        <span class="keyword">this</span>.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } <span class="keyword">while</span> ((strm.avail_in > <span class="number">0</span> || strm.avail_out === <span class="number">0</span>) &amp;&amp; status !== Z_STREAM_END);

  <span class="comment">// Finalize on the last chunk.</span>
  <span class="keyword">if</span> (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(<span class="keyword">this</span>.strm);
    <span class="keyword">this</span>.onEnd(status);
    <span class="keyword">this</span>.ended = <span class="literal">true</span>;
    <span class="keyword">return</span> status === Z_OK;
  }

  <span class="comment">// callback interim results if Z_SYNC_FLUSH.</span>
  <span class="keyword">if</span> (_mode === Z_SYNC_FLUSH) {
    <span class="keyword">this</span>.onEnd(Z_OK);
    strm.avail_out = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }

  <span class="keyword">return</span> <span class="literal">true</span>;
};


<span class="comment">/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/</span>
Deflate.prototype.onData = <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
  <span class="keyword">this</span>.chunks.push(chunk);
};


<span class="comment">/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/</span>
Deflate.prototype.onEnd = <span class="function"><span class="keyword">function</span> <span class="params">(status)</span> {</span>
  <span class="comment">// On success - join</span>
  <span class="keyword">if</span> (status === Z_OK) {
    <span class="keyword">if</span> (<span class="keyword">this</span>.options.to === <span class="string">'string'</span>) {
      <span class="keyword">this</span>.result = <span class="keyword">this</span>.chunks.join(<span class="string">''</span>);
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.result = utils.flattenChunks(<span class="keyword">this</span>.chunks);
    }
  }
  <span class="keyword">this</span>.chunks = [];
  <span class="keyword">this</span>.err = status;
  <span class="keyword">this</span>.msg = <span class="keyword">this</span>.strm.msg;
};


<span class="comment">/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflate</span><span class="params">(input, options)</span> {</span>
  <span class="keyword">var</span> deflator = <span class="keyword">new</span> Deflate(options);

  deflator.push(input, <span class="literal">true</span>);

  <span class="comment">// That will never happens, if you don't cheat with options :)</span>
  <span class="keyword">if</span> (deflator.err) { <span class="keyword">throw</span> deflator.msg || msg[deflator.err]; }

  <span class="keyword">return</span> deflator.result;
}


<span class="comment">/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/</span>
<span class="function"><span class="keyword">function</span> <span class="title">deflateRaw</span><span class="params">(input, options)</span> {</span>
  options = options || {};
  options.raw = <span class="literal">true</span>;
  <span class="keyword">return</span> deflate(input, options);
}


<span class="comment">/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/</span>
<span class="function"><span class="keyword">function</span> <span class="title">gzip</span><span class="params">(input, options)</span> {</span>
  options = options || {};
  options.gzip = <span class="literal">true</span>;
  <span class="keyword">return</span> deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;
</code></pre>