<h1>inflate.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;


<span class="keyword">var</span> zlib_inflate = require(<span class="string">'./zlib/inflate'</span>);
<span class="keyword">var</span> utils        = require(<span class="string">'./utils/common'</span>);
<span class="keyword">var</span> strings      = require(<span class="string">'./utils/strings'</span>);
<span class="keyword">var</span> c            = require(<span class="string">'./zlib/constants'</span>);
<span class="keyword">var</span> msg          = require(<span class="string">'./zlib/messages'</span>);
<span class="keyword">var</span> ZStream      = require(<span class="string">'./zlib/zstream'</span>);
<span class="keyword">var</span> GZheader     = require(<span class="string">'./zlib/gzheader'</span>);

<span class="keyword">var</span> toString = Object.prototype.toString;

<span class="comment">/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/</span>

<span class="comment">/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/</span>

<span class="comment">/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/</span>

<span class="comment">/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/</span>

<span class="comment">/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/</span>


<span class="comment">/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/</span>
<span class="function"><span class="keyword">function</span> <span class="title">Inflate</span><span class="params">(options)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Inflate)) <span class="keyword">return</span> <span class="keyword">new</span> Inflate(options);

  <span class="keyword">this</span>.options = utils.assign({
    chunkSize: <span class="number">16384</span>,
    windowBits: <span class="number">0</span>,
    to: <span class="string">''</span>
  }, options || {});

  <span class="keyword">var</span> opt = <span class="keyword">this</span>.options;

  <span class="comment">// Force window size for `raw` data, if not set directly,</span>
  <span class="comment">// because we have no header for autodetect.</span>
  <span class="keyword">if</span> (opt.raw &amp;&amp; (opt.windowBits >= <span class="number">0</span>) &amp;&amp; (opt.windowBits &lt; <span class="number">16</span>)) {
    opt.windowBits = -opt.windowBits;
    <span class="keyword">if</span> (opt.windowBits === <span class="number">0</span>) { opt.windowBits = -<span class="number">15</span>; }
  }

  <span class="comment">// If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate</span>
  <span class="keyword">if</span> ((opt.windowBits >= <span class="number">0</span>) &amp;&amp; (opt.windowBits &lt; <span class="number">16</span>) &amp;&amp;
      !(options &amp;&amp; options.windowBits)) {
    opt.windowBits += <span class="number">32</span>;
  }

  <span class="comment">// Gzip header has no info about windows size, we can do autodetect only</span>
  <span class="comment">// for deflate. So, if window size not set, force it to max when gzip possible</span>
  <span class="keyword">if</span> ((opt.windowBits > <span class="number">15</span>) &amp;&amp; (opt.windowBits &lt; <span class="number">48</span>)) {
    <span class="comment">// bit 3 (16) -> gzipped data</span>
    <span class="comment">// bit 4 (32) -> autodetect gzip/deflate</span>
    <span class="keyword">if</span> ((opt.windowBits &amp; <span class="number">15</span>) === <span class="number">0</span>) {
      opt.windowBits |= <span class="number">15</span>;
    }
  }

  <span class="keyword">this</span>.err    = <span class="number">0</span>;      <span class="comment">// error code, if happens (0 = Z_OK)</span>
  <span class="keyword">this</span>.msg    = <span class="string">''</span>;     <span class="comment">// error message</span>
  <span class="keyword">this</span>.ended  = <span class="literal">false</span>;  <span class="comment">// used to avoid multiple onEnd() calls</span>
  <span class="keyword">this</span>.chunks = [];     <span class="comment">// chunks of compressed data</span>

  <span class="keyword">this</span>.strm   = <span class="keyword">new</span> ZStream();
  <span class="keyword">this</span>.strm.avail_out = <span class="number">0</span>;

  <span class="keyword">var</span> status  = zlib_inflate.inflateInit2(
    <span class="keyword">this</span>.strm,
    opt.windowBits
  );

  <span class="keyword">if</span> (status !== c.Z_OK) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(msg[status]);
  }

  <span class="keyword">this</span>.header = <span class="keyword">new</span> GZheader();

  zlib_inflate.inflateGetHeader(<span class="keyword">this</span>.strm, <span class="keyword">this</span>.header);

  <span class="comment">// Setup dictionary</span>
  <span class="keyword">if</span> (opt.dictionary) {
    <span class="comment">// Convert data if needed</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> opt.dictionary === <span class="string">'string'</span>) {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } <span class="keyword">else</span> <span class="keyword">if</span> (toString.call(opt.dictionary) === <span class="string">'[object ArrayBuffer]'</span>) {
      opt.dictionary = <span class="keyword">new</span> Uint8Array(opt.dictionary);
    }
    <span class="keyword">if</span> (opt.raw) { <span class="comment">//In raw mode we need to set the dictionary early</span>
      status = zlib_inflate.inflateSetDictionary(<span class="keyword">this</span>.strm, opt.dictionary);
      <span class="keyword">if</span> (status !== c.Z_OK) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(msg[status]);
      }
    }
  }
}

<span class="comment">/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/</span>
Inflate.prototype.push = <span class="function"><span class="keyword">function</span> <span class="params">(data, mode)</span> {</span>
  <span class="keyword">var</span> strm = <span class="keyword">this</span>.strm;
  <span class="keyword">var</span> chunkSize = <span class="keyword">this</span>.options.chunkSize;
  <span class="keyword">var</span> dictionary = <span class="keyword">this</span>.options.dictionary;
  <span class="keyword">var</span> status, _mode;
  <span class="keyword">var</span> next_out_utf8, tail, utf8str;

  <span class="comment">// Flag to properly process Z_BUF_ERROR on testing inflate call</span>
  <span class="comment">// when we check that all output data was flushed.</span>
  <span class="keyword">var</span> allowBufError = <span class="literal">false</span>;

  <span class="keyword">if</span> (<span class="keyword">this</span>.ended) { <span class="keyword">return</span> <span class="literal">false</span>; }
  _mode = (mode === ~~mode) ? mode : ((mode === <span class="literal">true</span>) ? c.Z_FINISH : c.Z_NO_FLUSH);

  <span class="comment">// Convert data if needed</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'string'</span>) {
    <span class="comment">// Only binary strings can be decompressed on practice</span>
    strm.input = strings.binstring2buf(data);
  } <span class="keyword">else</span> <span class="keyword">if</span> (toString.call(data) === <span class="string">'[object ArrayBuffer]'</span>) {
    strm.input = <span class="keyword">new</span> Uint8Array(data);
  } <span class="keyword">else</span> {
    strm.input = data;
  }

  strm.next_in = <span class="number">0</span>;
  strm.avail_in = strm.input.length;

  <span class="keyword">do</span> {
    <span class="keyword">if</span> (strm.avail_out === <span class="number">0</span>) {
      strm.output = <span class="keyword">new</span> utils.Buf8(chunkSize);
      strm.next_out = <span class="number">0</span>;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    <span class="comment">/* no bad return value */</span>

    <span class="keyword">if</span> (status === c.Z_NEED_DICT &amp;&amp; dictionary) {
      status = zlib_inflate.inflateSetDictionary(<span class="keyword">this</span>.strm, dictionary);
    }

    <span class="keyword">if</span> (status === c.Z_BUF_ERROR &amp;&amp; allowBufError === <span class="literal">true</span>) {
      status = c.Z_OK;
      allowBufError = <span class="literal">false</span>;
    }

    <span class="keyword">if</span> (status !== c.Z_STREAM_END &amp;&amp; status !== c.Z_OK) {
      <span class="keyword">this</span>.onEnd(status);
      <span class="keyword">this</span>.ended = <span class="literal">true</span>;
      <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">if</span> (strm.next_out) {
      <span class="keyword">if</span> (strm.avail_out === <span class="number">0</span> || status === c.Z_STREAM_END || (strm.avail_in === <span class="number">0</span> &amp;&amp; (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        <span class="keyword">if</span> (<span class="keyword">this</span>.options.to === <span class="string">'string'</span>) {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          <span class="comment">// move tail</span>
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          <span class="keyword">if</span> (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, <span class="number">0</span>); }

          <span class="keyword">this</span>.onData(utf8str);

        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    <span class="comment">// When no more input data, we should check that internal inflate buffers</span>
    <span class="comment">// are flushed. The only way to do it when avail_out = 0 - run one more</span>
    <span class="comment">// inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.</span>
    <span class="comment">// Here we set flag to process this error properly.</span>
    <span class="comment">//</span>
    <span class="comment">// NOTE. Deflate does not return error in this case and does not needs such</span>
    <span class="comment">// logic.</span>
    <span class="keyword">if</span> (strm.avail_in === <span class="number">0</span> &amp;&amp; strm.avail_out === <span class="number">0</span>) {
      allowBufError = <span class="literal">true</span>;
    }

  } <span class="keyword">while</span> ((strm.avail_in > <span class="number">0</span> || strm.avail_out === <span class="number">0</span>) &amp;&amp; status !== c.Z_STREAM_END);

  <span class="keyword">if</span> (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  <span class="comment">// Finalize on the last chunk.</span>
  <span class="keyword">if</span> (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(<span class="keyword">this</span>.strm);
    <span class="keyword">this</span>.onEnd(status);
    <span class="keyword">this</span>.ended = <span class="literal">true</span>;
    <span class="keyword">return</span> status === c.Z_OK;
  }

  <span class="comment">// callback interim results if Z_SYNC_FLUSH.</span>
  <span class="keyword">if</span> (_mode === c.Z_SYNC_FLUSH) {
    <span class="keyword">this</span>.onEnd(c.Z_OK);
    strm.avail_out = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="literal">true</span>;
  }

  <span class="keyword">return</span> <span class="literal">true</span>;
};


<span class="comment">/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/</span>
Inflate.prototype.onData = <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
  <span class="keyword">this</span>.chunks.push(chunk);
};


<span class="comment">/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/</span>
Inflate.prototype.onEnd = <span class="function"><span class="keyword">function</span> <span class="params">(status)</span> {</span>
  <span class="comment">// On success - join</span>
  <span class="keyword">if</span> (status === c.Z_OK) {
    <span class="keyword">if</span> (<span class="keyword">this</span>.options.to === <span class="string">'string'</span>) {
      <span class="comment">// Glue &amp; convert here, until we teach pako to send</span>
      <span class="comment">// utf8 aligned strings to onData</span>
      <span class="keyword">this</span>.result = <span class="keyword">this</span>.chunks.join(<span class="string">''</span>);
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.result = utils.flattenChunks(<span class="keyword">this</span>.chunks);
    }
  }
  <span class="keyword">this</span>.chunks = [];
  <span class="keyword">this</span>.err = status;
  <span class="keyword">this</span>.msg = <span class="keyword">this</span>.strm.msg;
};


<span class="comment">/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/</span>
<span class="function"><span class="keyword">function</span> <span class="title">inflate</span><span class="params">(input, options)</span> {</span>
  <span class="keyword">var</span> inflator = <span class="keyword">new</span> Inflate(options);

  inflator.push(input, <span class="literal">true</span>);

  <span class="comment">// That will never happens, if you don't cheat with options :)</span>
  <span class="keyword">if</span> (inflator.err) { <span class="keyword">throw</span> inflator.msg || msg[inflator.err]; }

  <span class="keyword">return</span> inflator.result;
}


<span class="comment">/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/</span>
<span class="function"><span class="keyword">function</span> <span class="title">inflateRaw</span><span class="params">(input, options)</span> {</span>
  options = options || {};
  options.raw = <span class="literal">true</span>;
  <span class="keyword">return</span> inflate(input, options);
}


<span class="comment">/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/</span>


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;
</code></pre>