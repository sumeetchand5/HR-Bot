<h1>string_decoder.js</h1>
<pre><code class="lang-js"><span class="comment">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="comment">//</span>
<span class="comment">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="comment">// copy of this software and associated documentation files (the</span>
<span class="comment">// "Software"), to deal in the Software without restriction, including</span>
<span class="comment">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="comment">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="comment">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="comment">// following conditions:</span>
<span class="comment">//</span>
<span class="comment">// The above copyright notice and this permission notice shall be included</span>
<span class="comment">// in all copies or substantial portions of the Software.</span>
<span class="comment">//</span>
<span class="comment">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="comment">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="comment">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="comment">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="comment">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="comment">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="comment">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="string">'use strict'</span>;

<span class="comment">/*&lt;replacement>*/</span>

<span class="keyword">var</span> Buffer = require(<span class="string">'safe-buffer'</span>).Buffer;
<span class="comment">/*&lt;/replacement>*/</span>

<span class="keyword">var</span> isEncoding = Buffer.isEncoding || <span class="function"><span class="keyword">function</span> <span class="params">(encoding)</span> {</span>
  encoding = <span class="string">''</span> + encoding;
  <span class="keyword">switch</span> (encoding &amp;&amp; encoding.toLowerCase()) {
    <span class="keyword">case</span> <span class="string">'hex'</span>:<span class="keyword">case</span> <span class="string">'utf8'</span>:<span class="keyword">case</span> <span class="string">'utf-8'</span>:<span class="keyword">case</span> <span class="string">'ascii'</span>:<span class="keyword">case</span> <span class="string">'binary'</span>:<span class="keyword">case</span> <span class="string">'base64'</span>:<span class="keyword">case</span> <span class="string">'ucs2'</span>:<span class="keyword">case</span> <span class="string">'ucs-2'</span>:<span class="keyword">case</span> <span class="string">'utf16le'</span>:<span class="keyword">case</span> <span class="string">'utf-16le'</span>:<span class="keyword">case</span> <span class="string">'raw'</span>:
      <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">default</span>:
      <span class="keyword">return</span> <span class="literal">false</span>;
  }
};

<span class="function"><span class="keyword">function</span> <span class="title">_normalizeEncoding</span><span class="params">(enc)</span> {</span>
  <span class="keyword">if</span> (!enc) <span class="keyword">return</span> <span class="string">'utf8'</span>;
  <span class="keyword">var</span> retried;
  <span class="keyword">while</span> (<span class="literal">true</span>) {
    <span class="keyword">switch</span> (enc) {
      <span class="keyword">case</span> <span class="string">'utf8'</span>:
      <span class="keyword">case</span> <span class="string">'utf-8'</span>:
        <span class="keyword">return</span> <span class="string">'utf8'</span>;
      <span class="keyword">case</span> <span class="string">'ucs2'</span>:
      <span class="keyword">case</span> <span class="string">'ucs-2'</span>:
      <span class="keyword">case</span> <span class="string">'utf16le'</span>:
      <span class="keyword">case</span> <span class="string">'utf-16le'</span>:
        <span class="keyword">return</span> <span class="string">'utf16le'</span>;
      <span class="keyword">case</span> <span class="string">'latin1'</span>:
      <span class="keyword">case</span> <span class="string">'binary'</span>:
        <span class="keyword">return</span> <span class="string">'latin1'</span>;
      <span class="keyword">case</span> <span class="string">'base64'</span>:
      <span class="keyword">case</span> <span class="string">'ascii'</span>:
      <span class="keyword">case</span> <span class="string">'hex'</span>:
        <span class="keyword">return</span> enc;
      <span class="keyword">default</span>:
        <span class="keyword">if</span> (retried) <span class="keyword">return</span>; <span class="comment">// undefined</span>
        enc = (<span class="string">''</span> + enc).toLowerCase();
        retried = <span class="literal">true</span>;
    }
  }
};

<span class="comment">// Do not cache `Buffer.isEncoding` when checking encoding names as some</span>
<span class="comment">// modules monkey-patch it to support additional encodings</span>
<span class="function"><span class="keyword">function</span> <span class="title">normalizeEncoding</span><span class="params">(enc)</span> {</span>
  <span class="keyword">var</span> nenc = _normalizeEncoding(enc);
  <span class="keyword">if</span> (<span class="keyword">typeof</span> nenc !== <span class="string">'string'</span> &amp;&amp; (Buffer.isEncoding === isEncoding || !isEncoding(enc))) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Unknown encoding: '</span> + enc);
  <span class="keyword">return</span> nenc || enc;
}

<span class="comment">// StringDecoder provides an interface for efficiently splitting a series of</span>
<span class="comment">// buffers into a series of JS strings without breaking apart multi-byte</span>
<span class="comment">// characters.</span>
exports.StringDecoder = StringDecoder;
<span class="function"><span class="keyword">function</span> <span class="title">StringDecoder</span><span class="params">(encoding)</span> {</span>
  <span class="keyword">this</span>.encoding = normalizeEncoding(encoding);
  <span class="keyword">var</span> nb;
  <span class="keyword">switch</span> (<span class="keyword">this</span>.encoding) {
    <span class="keyword">case</span> <span class="string">'utf16le'</span>:
      <span class="keyword">this</span>.text = utf16Text;
      <span class="keyword">this</span>.end = utf16End;
      nb = <span class="number">4</span>;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'utf8'</span>:
      <span class="keyword">this</span>.fillLast = utf8FillLast;
      nb = <span class="number">4</span>;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'base64'</span>:
      <span class="keyword">this</span>.text = base64Text;
      <span class="keyword">this</span>.end = base64End;
      nb = <span class="number">3</span>;
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      <span class="keyword">this</span>.write = simpleWrite;
      <span class="keyword">this</span>.end = simpleEnd;
      <span class="keyword">return</span>;
  }
  <span class="keyword">this</span>.lastNeed = <span class="number">0</span>;
  <span class="keyword">this</span>.lastTotal = <span class="number">0</span>;
  <span class="keyword">this</span>.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = <span class="function"><span class="keyword">function</span> <span class="params">(buf)</span> {</span>
  <span class="keyword">if</span> (buf.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span>;
  <span class="keyword">var</span> r;
  <span class="keyword">var</span> i;
  <span class="keyword">if</span> (<span class="keyword">this</span>.lastNeed) {
    r = <span class="keyword">this</span>.fillLast(buf);
    <span class="keyword">if</span> (r === <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="string">''</span>;
    i = <span class="keyword">this</span>.lastNeed;
    <span class="keyword">this</span>.lastNeed = <span class="number">0</span>;
  } <span class="keyword">else</span> {
    i = <span class="number">0</span>;
  }
  <span class="keyword">if</span> (i &lt; buf.length) <span class="keyword">return</span> r ? r + <span class="keyword">this</span>.text(buf, i) : <span class="keyword">this</span>.text(buf, i);
  <span class="keyword">return</span> r || <span class="string">''</span>;
};

StringDecoder.prototype.end = utf8End;

<span class="comment">// Returns only complete characters in a Buffer</span>
StringDecoder.prototype.text = utf8Text;

<span class="comment">// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer</span>
StringDecoder.prototype.fillLast = <span class="function"><span class="keyword">function</span> <span class="params">(buf)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.lastNeed &lt;= buf.length) {
    buf.copy(<span class="keyword">this</span>.lastChar, <span class="keyword">this</span>.lastTotal - <span class="keyword">this</span>.lastNeed, <span class="number">0</span>, <span class="keyword">this</span>.lastNeed);
    <span class="keyword">return</span> <span class="keyword">this</span>.lastChar.toString(<span class="keyword">this</span>.encoding, <span class="number">0</span>, <span class="keyword">this</span>.lastTotal);
  }
  buf.copy(<span class="keyword">this</span>.lastChar, <span class="keyword">this</span>.lastTotal - <span class="keyword">this</span>.lastNeed, <span class="number">0</span>, buf.length);
  <span class="keyword">this</span>.lastNeed -= buf.length;
};

<span class="comment">// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a</span>
<span class="comment">// continuation byte. If an invalid byte is detected, -2 is returned.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf8CheckByte</span><span class="params">(byte)</span> {</span>
  <span class="keyword">if</span> (byte &lt;= <span class="number">0x7F</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="keyword">else</span> <span class="keyword">if</span> (byte >> <span class="number">5</span> === <span class="number">0x06</span>) <span class="keyword">return</span> <span class="number">2</span>;<span class="keyword">else</span> <span class="keyword">if</span> (byte >> <span class="number">4</span> === <span class="number">0x0E</span>) <span class="keyword">return</span> <span class="number">3</span>;<span class="keyword">else</span> <span class="keyword">if</span> (byte >> <span class="number">3</span> === <span class="number">0x1E</span>) <span class="keyword">return</span> <span class="number">4</span>;
  <span class="keyword">return</span> byte >> <span class="number">6</span> === <span class="number">0x02</span> ? -<span class="number">1</span> : -<span class="number">2</span>;
}

<span class="comment">// Checks at most 3 bytes at the end of a Buffer in order to detect an</span>
<span class="comment">// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)</span>
<span class="comment">// needed to complete the UTF-8 character (if applicable) are returned.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf8CheckIncomplete</span><span class="params">(self, buf, i)</span> {</span>
  <span class="keyword">var</span> j = buf.length - <span class="number">1</span>;
  <span class="keyword">if</span> (j &lt; i) <span class="keyword">return</span> <span class="number">0</span>;
  <span class="keyword">var</span> nb = utf8CheckByte(buf[j]);
  <span class="keyword">if</span> (nb >= <span class="number">0</span>) {
    <span class="keyword">if</span> (nb > <span class="number">0</span>) self.lastNeed = nb - <span class="number">1</span>;
    <span class="keyword">return</span> nb;
  }
  <span class="keyword">if</span> (--j &lt; i || nb === -<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;
  nb = utf8CheckByte(buf[j]);
  <span class="keyword">if</span> (nb >= <span class="number">0</span>) {
    <span class="keyword">if</span> (nb > <span class="number">0</span>) self.lastNeed = nb - <span class="number">2</span>;
    <span class="keyword">return</span> nb;
  }
  <span class="keyword">if</span> (--j &lt; i || nb === -<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;
  nb = utf8CheckByte(buf[j]);
  <span class="keyword">if</span> (nb >= <span class="number">0</span>) {
    <span class="keyword">if</span> (nb > <span class="number">0</span>) {
      <span class="keyword">if</span> (nb === <span class="number">2</span>) nb = <span class="number">0</span>;<span class="keyword">else</span> self.lastNeed = nb - <span class="number">3</span>;
    }
    <span class="keyword">return</span> nb;
  }
  <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="comment">// Validates as many continuation bytes for a multi-byte UTF-8 character as</span>
<span class="comment">// needed or are available. If we see a non-continuation byte where we expect</span>
<span class="comment">// one, we "replace" the validated continuation bytes we've seen so far with</span>
<span class="comment">// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding</span>
<span class="comment">// behavior. The continuation byte check is included three times in the case</span>
<span class="comment">// where all of the continuation bytes for a character exist in the same buffer.</span>
<span class="comment">// It is also done this way as a slight performance increase instead of using a</span>
<span class="comment">// loop.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf8CheckExtraBytes</span><span class="params">(self, buf, p)</span> {</span>
  <span class="keyword">if</span> ((buf[<span class="number">0</span>] &amp; <span class="number">0xC0</span>) !== <span class="number">0x80</span>) {
    self.lastNeed = <span class="number">0</span>;
    <span class="keyword">return</span> <span class="string">'\ufffd'</span>;
  }
  <span class="keyword">if</span> (self.lastNeed > <span class="number">1</span> &amp;&amp; buf.length > <span class="number">1</span>) {
    <span class="keyword">if</span> ((buf[<span class="number">1</span>] &amp; <span class="number">0xC0</span>) !== <span class="number">0x80</span>) {
      self.lastNeed = <span class="number">1</span>;
      <span class="keyword">return</span> <span class="string">'\ufffd'</span>;
    }
    <span class="keyword">if</span> (self.lastNeed > <span class="number">2</span> &amp;&amp; buf.length > <span class="number">2</span>) {
      <span class="keyword">if</span> ((buf[<span class="number">2</span>] &amp; <span class="number">0xC0</span>) !== <span class="number">0x80</span>) {
        self.lastNeed = <span class="number">2</span>;
        <span class="keyword">return</span> <span class="string">'\ufffd'</span>;
      }
    }
  }
}

<span class="comment">// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf8FillLast</span><span class="params">(buf)</span> {</span>
  <span class="keyword">var</span> p = <span class="keyword">this</span>.lastTotal - <span class="keyword">this</span>.lastNeed;
  <span class="keyword">var</span> r = utf8CheckExtraBytes(<span class="keyword">this</span>, buf, p);
  <span class="keyword">if</span> (r !== <span class="literal">undefined</span>) <span class="keyword">return</span> r;
  <span class="keyword">if</span> (<span class="keyword">this</span>.lastNeed &lt;= buf.length) {
    buf.copy(<span class="keyword">this</span>.lastChar, p, <span class="number">0</span>, <span class="keyword">this</span>.lastNeed);
    <span class="keyword">return</span> <span class="keyword">this</span>.lastChar.toString(<span class="keyword">this</span>.encoding, <span class="number">0</span>, <span class="keyword">this</span>.lastTotal);
  }
  buf.copy(<span class="keyword">this</span>.lastChar, p, <span class="number">0</span>, buf.length);
  <span class="keyword">this</span>.lastNeed -= buf.length;
}

<span class="comment">// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a</span>
<span class="comment">// partial character, the character's bytes are buffered until the required</span>
<span class="comment">// number of bytes are available.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf8Text</span><span class="params">(buf, i)</span> {</span>
  <span class="keyword">var</span> total = utf8CheckIncomplete(<span class="keyword">this</span>, buf, i);
  <span class="keyword">if</span> (!<span class="keyword">this</span>.lastNeed) <span class="keyword">return</span> buf.toString(<span class="string">'utf8'</span>, i);
  <span class="keyword">this</span>.lastTotal = total;
  <span class="keyword">var</span> end = buf.length - (total - <span class="keyword">this</span>.lastNeed);
  buf.copy(<span class="keyword">this</span>.lastChar, <span class="number">0</span>, end);
  <span class="keyword">return</span> buf.toString(<span class="string">'utf8'</span>, i, end);
}

<span class="comment">// For UTF-8, a replacement character is added when ending on a partial</span>
<span class="comment">// character.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf8End</span><span class="params">(buf)</span> {</span>
  <span class="keyword">var</span> r = buf &amp;&amp; buf.length ? <span class="keyword">this</span>.write(buf) : <span class="string">''</span>;
  <span class="keyword">if</span> (<span class="keyword">this</span>.lastNeed) <span class="keyword">return</span> r + <span class="string">'\ufffd'</span>;
  <span class="keyword">return</span> r;
}

<span class="comment">// UTF-16LE typically needs two bytes per character, but even if we have an even</span>
<span class="comment">// number of bytes available, we need to check if we end on a leading/high</span>
<span class="comment">// surrogate. In that case, we need to wait for the next two bytes in order to</span>
<span class="comment">// decode the last character properly.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf16Text</span><span class="params">(buf, i)</span> {</span>
  <span class="keyword">if</span> ((buf.length - i) % <span class="number">2</span> === <span class="number">0</span>) {
    <span class="keyword">var</span> r = buf.toString(<span class="string">'utf16le'</span>, i);
    <span class="keyword">if</span> (r) {
      <span class="keyword">var</span> c = r.charCodeAt(r.length - <span class="number">1</span>);
      <span class="keyword">if</span> (c >= <span class="number">0xD800</span> &amp;&amp; c &lt;= <span class="number">0xDBFF</span>) {
        <span class="keyword">this</span>.lastNeed = <span class="number">2</span>;
        <span class="keyword">this</span>.lastTotal = <span class="number">4</span>;
        <span class="keyword">this</span>.lastChar[<span class="number">0</span>] = buf[buf.length - <span class="number">2</span>];
        <span class="keyword">this</span>.lastChar[<span class="number">1</span>] = buf[buf.length - <span class="number">1</span>];
        <span class="keyword">return</span> r.slice(<span class="number">0</span>, -<span class="number">1</span>);
      }
    }
    <span class="keyword">return</span> r;
  }
  <span class="keyword">this</span>.lastNeed = <span class="number">1</span>;
  <span class="keyword">this</span>.lastTotal = <span class="number">2</span>;
  <span class="keyword">this</span>.lastChar[<span class="number">0</span>] = buf[buf.length - <span class="number">1</span>];
  <span class="keyword">return</span> buf.toString(<span class="string">'utf16le'</span>, i, buf.length - <span class="number">1</span>);
}

<span class="comment">// For UTF-16LE we do not explicitly append special replacement characters if we</span>
<span class="comment">// end on a partial character, we simply let v8 handle that.</span>
<span class="function"><span class="keyword">function</span> <span class="title">utf16End</span><span class="params">(buf)</span> {</span>
  <span class="keyword">var</span> r = buf &amp;&amp; buf.length ? <span class="keyword">this</span>.write(buf) : <span class="string">''</span>;
  <span class="keyword">if</span> (<span class="keyword">this</span>.lastNeed) {
    <span class="keyword">var</span> end = <span class="keyword">this</span>.lastTotal - <span class="keyword">this</span>.lastNeed;
    <span class="keyword">return</span> r + <span class="keyword">this</span>.lastChar.toString(<span class="string">'utf16le'</span>, <span class="number">0</span>, end);
  }
  <span class="keyword">return</span> r;
}

<span class="function"><span class="keyword">function</span> <span class="title">base64Text</span><span class="params">(buf, i)</span> {</span>
  <span class="keyword">var</span> n = (buf.length - i) % <span class="number">3</span>;
  <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> buf.toString(<span class="string">'base64'</span>, i);
  <span class="keyword">this</span>.lastNeed = <span class="number">3</span> - n;
  <span class="keyword">this</span>.lastTotal = <span class="number">3</span>;
  <span class="keyword">if</span> (n === <span class="number">1</span>) {
    <span class="keyword">this</span>.lastChar[<span class="number">0</span>] = buf[buf.length - <span class="number">1</span>];
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>.lastChar[<span class="number">0</span>] = buf[buf.length - <span class="number">2</span>];
    <span class="keyword">this</span>.lastChar[<span class="number">1</span>] = buf[buf.length - <span class="number">1</span>];
  }
  <span class="keyword">return</span> buf.toString(<span class="string">'base64'</span>, i, buf.length - n);
}

<span class="function"><span class="keyword">function</span> <span class="title">base64End</span><span class="params">(buf)</span> {</span>
  <span class="keyword">var</span> r = buf &amp;&amp; buf.length ? <span class="keyword">this</span>.write(buf) : <span class="string">''</span>;
  <span class="keyword">if</span> (<span class="keyword">this</span>.lastNeed) <span class="keyword">return</span> r + <span class="keyword">this</span>.lastChar.toString(<span class="string">'base64'</span>, <span class="number">0</span>, <span class="number">3</span> - <span class="keyword">this</span>.lastNeed);
  <span class="keyword">return</span> r;
}

<span class="comment">// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)</span>
<span class="function"><span class="keyword">function</span> <span class="title">simpleWrite</span><span class="params">(buf)</span> {</span>
  <span class="keyword">return</span> buf.toString(<span class="keyword">this</span>.encoding);
}

<span class="function"><span class="keyword">function</span> <span class="title">simpleEnd</span><span class="params">(buf)</span> {</span>
  <span class="keyword">return</span> buf &amp;&amp; buf.length ? <span class="keyword">this</span>.write(buf) : <span class="string">''</span>;
}</code></pre>