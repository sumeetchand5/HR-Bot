<h1>cipher.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="keyword">var</span> assert = require(<span class="string">'minimalistic-assert'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">Cipher</span><span class="params">(options)</span> {</span>
  <span class="keyword">this</span>.options = options;

  <span class="keyword">this</span>.type = <span class="keyword">this</span>.options.type;
  <span class="keyword">this</span>.blockSize = <span class="number">8</span>;
  <span class="keyword">this</span>._init();

  <span class="keyword">this</span>.buffer = <span class="keyword">new</span> Array(<span class="keyword">this</span>.blockSize);
  <span class="keyword">this</span>.bufferOff = <span class="number">0</span>;
}
module.exports = Cipher;

Cipher.prototype._init = <span class="function"><span class="keyword">function</span> <span class="title">_init</span><span class="params">()</span> {</span>
  <span class="comment">// Might be overrided</span>
};

Cipher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">(data)</span> {</span>
  <span class="keyword">if</span> (data.length === <span class="number">0</span>)
    <span class="keyword">return</span> [];

  <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'decrypt'</span>)
    <span class="keyword">return</span> <span class="keyword">this</span>._updateDecrypt(data);
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._updateEncrypt(data);
};

Cipher.prototype._buffer = <span class="function"><span class="keyword">function</span> <span class="title">_buffer</span><span class="params">(data, off)</span> {</span>
  <span class="comment">// Append data to buffer</span>
  <span class="keyword">var</span> min = Math.min(<span class="keyword">this</span>.buffer.length - <span class="keyword">this</span>.bufferOff, data.length - off);
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; min; i++)
    <span class="keyword">this</span>.buffer[<span class="keyword">this</span>.bufferOff + i] = data[off + i];
  <span class="keyword">this</span>.bufferOff += min;

  <span class="comment">// Shift next</span>
  <span class="keyword">return</span> min;
};

Cipher.prototype._flushBuffer = <span class="function"><span class="keyword">function</span> <span class="title">_flushBuffer</span><span class="params">(out, off)</span> {</span>
  <span class="keyword">this</span>._update(<span class="keyword">this</span>.buffer, <span class="number">0</span>, out, off);
  <span class="keyword">this</span>.bufferOff = <span class="number">0</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>.blockSize;
};

Cipher.prototype._updateEncrypt = <span class="function"><span class="keyword">function</span> <span class="title">_updateEncrypt</span><span class="params">(data)</span> {</span>
  <span class="keyword">var</span> inputOff = <span class="number">0</span>;
  <span class="keyword">var</span> outputOff = <span class="number">0</span>;

  <span class="keyword">var</span> count = ((<span class="keyword">this</span>.bufferOff + data.length) / <span class="keyword">this</span>.blockSize) | <span class="number">0</span>;
  <span class="keyword">var</span> out = <span class="keyword">new</span> Array(count * <span class="keyword">this</span>.blockSize);

  <span class="keyword">if</span> (<span class="keyword">this</span>.bufferOff !== <span class="number">0</span>) {
    inputOff += <span class="keyword">this</span>._buffer(data, inputOff);

    <span class="keyword">if</span> (<span class="keyword">this</span>.bufferOff === <span class="keyword">this</span>.buffer.length)
      outputOff += <span class="keyword">this</span>._flushBuffer(out, outputOff);
  }

  <span class="comment">// Write blocks</span>
  <span class="keyword">var</span> max = data.length - ((data.length - inputOff) % <span class="keyword">this</span>.blockSize);
  <span class="keyword">for</span> (; inputOff &lt; max; inputOff += <span class="keyword">this</span>.blockSize) {
    <span class="keyword">this</span>._update(data, inputOff, out, outputOff);
    outputOff += <span class="keyword">this</span>.blockSize;
  }

  <span class="comment">// Queue rest</span>
  <span class="keyword">for</span> (; inputOff &lt; data.length; inputOff++, <span class="keyword">this</span>.bufferOff++)
    <span class="keyword">this</span>.buffer[<span class="keyword">this</span>.bufferOff] = data[inputOff];

  <span class="keyword">return</span> out;
};

Cipher.prototype._updateDecrypt = <span class="function"><span class="keyword">function</span> <span class="title">_updateDecrypt</span><span class="params">(data)</span> {</span>
  <span class="keyword">var</span> inputOff = <span class="number">0</span>;
  <span class="keyword">var</span> outputOff = <span class="number">0</span>;

  <span class="keyword">var</span> count = Math.ceil((<span class="keyword">this</span>.bufferOff + data.length) / <span class="keyword">this</span>.blockSize) - <span class="number">1</span>;
  <span class="keyword">var</span> out = <span class="keyword">new</span> Array(count * <span class="keyword">this</span>.blockSize);

  <span class="comment">// TODO(indutny): optimize it, this is far from optimal</span>
  <span class="keyword">for</span> (; count > <span class="number">0</span>; count--) {
    inputOff += <span class="keyword">this</span>._buffer(data, inputOff);
    outputOff += <span class="keyword">this</span>._flushBuffer(out, outputOff);
  }

  <span class="comment">// Buffer rest of the input</span>
  inputOff += <span class="keyword">this</span>._buffer(data, inputOff);

  <span class="keyword">return</span> out;
};

Cipher.prototype.final = <span class="function"><span class="keyword">function</span> <span class="title">final</span><span class="params">(buffer)</span> {</span>
  <span class="keyword">var</span> first;
  <span class="keyword">if</span> (buffer)
    first = <span class="keyword">this</span>.update(buffer);

  <span class="keyword">var</span> last;
  <span class="keyword">if</span> (<span class="keyword">this</span>.type === <span class="string">'encrypt'</span>)
    last = <span class="keyword">this</span>._finalEncrypt();
  <span class="keyword">else</span>
    last = <span class="keyword">this</span>._finalDecrypt();

  <span class="keyword">if</span> (first)
    <span class="keyword">return</span> first.concat(last);
  <span class="keyword">else</span>
    <span class="keyword">return</span> last;
};

Cipher.prototype._pad = <span class="function"><span class="keyword">function</span> <span class="title">_pad</span><span class="params">(buffer, off)</span> {</span>
  <span class="keyword">if</span> (off === <span class="number">0</span>)
    <span class="keyword">return</span> <span class="literal">false</span>;

  <span class="keyword">while</span> (off &lt; buffer.length)
    buffer[off++] = <span class="number">0</span>;

  <span class="keyword">return</span> <span class="literal">true</span>;
};

Cipher.prototype._finalEncrypt = <span class="function"><span class="keyword">function</span> <span class="title">_finalEncrypt</span><span class="params">()</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>._pad(<span class="keyword">this</span>.buffer, <span class="keyword">this</span>.bufferOff))
    <span class="keyword">return</span> [];

  <span class="keyword">var</span> out = <span class="keyword">new</span> Array(<span class="keyword">this</span>.blockSize);
  <span class="keyword">this</span>._update(<span class="keyword">this</span>.buffer, <span class="number">0</span>, out, <span class="number">0</span>);
  <span class="keyword">return</span> out;
};

Cipher.prototype._unpad = <span class="function"><span class="keyword">function</span> <span class="title">_unpad</span><span class="params">(buffer)</span> {</span>
  <span class="keyword">return</span> buffer;
};

Cipher.prototype._finalDecrypt = <span class="function"><span class="keyword">function</span> <span class="title">_finalDecrypt</span><span class="params">()</span> {</span>
  assert.equal(<span class="keyword">this</span>.bufferOff, <span class="keyword">this</span>.blockSize, <span class="string">'Not enough data to decrypt'</span>);
  <span class="keyword">var</span> out = <span class="keyword">new</span> Array(<span class="keyword">this</span>.blockSize);
  <span class="keyword">this</span>._flushBuffer(out, <span class="number">0</span>);

  <span class="keyword">return</span> <span class="keyword">this</span>._unpad(out);
};
</code></pre>