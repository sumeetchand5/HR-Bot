<h1>async_iterator.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="keyword">var</span> _Object$setPrototypeO;

<span class="function"><span class="keyword">function</span> <span class="title">_defineProperty</span><span class="params">(obj, key, value)</span> {</span> <span class="keyword">if</span> (key <span class="keyword">in</span> obj) { Object.defineProperty(obj, key, { value: value, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span>, writable: <span class="literal">true</span> }); } <span class="keyword">else</span> { obj[key] = value; } <span class="keyword">return</span> obj; }

<span class="keyword">var</span> finished = require(<span class="string">'./end-of-stream'</span>);

<span class="keyword">var</span> kLastResolve = Symbol(<span class="string">'lastResolve'</span>);
<span class="keyword">var</span> kLastReject = Symbol(<span class="string">'lastReject'</span>);
<span class="keyword">var</span> kError = Symbol(<span class="string">'error'</span>);
<span class="keyword">var</span> kEnded = Symbol(<span class="string">'ended'</span>);
<span class="keyword">var</span> kLastPromise = Symbol(<span class="string">'lastPromise'</span>);
<span class="keyword">var</span> kHandlePromise = Symbol(<span class="string">'handlePromise'</span>);
<span class="keyword">var</span> kStream = Symbol(<span class="string">'stream'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">createIterResult</span><span class="params">(value, done)</span> {</span>
  <span class="keyword">return</span> {
    value: value,
    done: done
  };
}

<span class="function"><span class="keyword">function</span> <span class="title">readAndResolve</span><span class="params">(iter)</span> {</span>
  <span class="keyword">var</span> resolve = iter[kLastResolve];

  <span class="keyword">if</span> (resolve !== <span class="literal">null</span>) {
    <span class="keyword">var</span> data = iter[kStream].read(); <span class="comment">// we defer if data is null</span>
    <span class="comment">// we can be expecting either 'end' or</span>
    <span class="comment">// 'error'</span>

    <span class="keyword">if</span> (data !== <span class="literal">null</span>) {
      iter[kLastPromise] = <span class="literal">null</span>;
      iter[kLastResolve] = <span class="literal">null</span>;
      iter[kLastReject] = <span class="literal">null</span>;
      resolve(createIterResult(data, <span class="literal">false</span>));
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">onReadable</span><span class="params">(iter)</span> {</span>
  <span class="comment">// we wait for the next tick, because it might</span>
  <span class="comment">// emit an error with process.nextTick</span>
  process.nextTick(readAndResolve, iter);
}

<span class="function"><span class="keyword">function</span> <span class="title">wrapForNext</span><span class="params">(lastPromise, iter)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
    lastPromise.then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">if</span> (iter[kEnded]) {
        resolve(createIterResult(<span class="literal">undefined</span>, <span class="literal">true</span>));
        <span class="keyword">return</span>;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

<span class="keyword">var</span> AsyncIteratorPrototype = Object.getPrototypeOf(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>});
<span class="keyword">var</span> ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    <span class="keyword">return</span> <span class="keyword">this</span>[kStream];
  },

  next: <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

    <span class="comment">// if we have detected an error in the meanwhile</span>
    <span class="comment">// reject straight away</span>
    <span class="keyword">var</span> error = <span class="keyword">this</span>[kError];

    <span class="keyword">if</span> (error !== <span class="literal">null</span>) {
      <span class="keyword">return</span> Promise.reject(error);
    }

    <span class="keyword">if</span> (<span class="keyword">this</span>[kEnded]) {
      <span class="keyword">return</span> Promise.resolve(createIterResult(<span class="literal">undefined</span>, <span class="literal">true</span>));
    }

    <span class="keyword">if</span> (<span class="keyword">this</span>[kStream].destroyed) {
      <span class="comment">// We need to defer via nextTick because if .destroy(err) is</span>
      <span class="comment">// called, the error will be emitted via nextTick, and</span>
      <span class="comment">// we cannot guarantee that there is no error lingering around</span>
      <span class="comment">// waiting to be emitted.</span>
      <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
        process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
          <span class="keyword">if</span> (_<span class="keyword">this</span>[kError]) {
            reject(_<span class="keyword">this</span>[kError]);
          } <span class="keyword">else</span> {
            resolve(createIterResult(<span class="literal">undefined</span>, <span class="literal">true</span>));
          }
        });
      });
    } <span class="comment">// if we have multiple next() calls</span>
    <span class="comment">// we will wait for the previous Promise to finish</span>
    <span class="comment">// this logic is optimized to support for await loops,</span>
    <span class="comment">// where next() is only called once at a time</span>


    <span class="keyword">var</span> lastPromise = <span class="keyword">this</span>[kLastPromise];
    <span class="keyword">var</span> promise;

    <span class="keyword">if</span> (lastPromise) {
      promise = <span class="keyword">new</span> Promise(wrapForNext(lastPromise, <span class="keyword">this</span>));
    } <span class="keyword">else</span> {
      <span class="comment">// fast path needed to support multiple this.push()</span>
      <span class="comment">// without triggering the next() queue</span>
      <span class="keyword">var</span> data = <span class="keyword">this</span>[kStream].read();

      <span class="keyword">if</span> (data !== <span class="literal">null</span>) {
        <span class="keyword">return</span> Promise.resolve(createIterResult(data, <span class="literal">false</span>));
      }

      promise = <span class="keyword">new</span> Promise(<span class="keyword">this</span>[kHandlePromise]);
    }

    <span class="keyword">this</span>[kLastPromise] = promise;
    <span class="keyword">return</span> promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>;
}), _defineProperty(_Object$setPrototypeO, <span class="string">"return"</span>, <span class="function"><span class="keyword">function</span> <span class="title">_return</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> _this2 = <span class="keyword">this</span>;

  <span class="comment">// destroy(err, cb) is a private API</span>
  <span class="comment">// we can guarantee we have that here, because we control the</span>
  <span class="comment">// Readable class this is attached to</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
    _this2[kStream].destroy(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
      <span class="keyword">if</span> (err) {
        reject(err);
        <span class="keyword">return</span>;
      }

      resolve(createIterResult(<span class="literal">undefined</span>, <span class="literal">true</span>));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

<span class="keyword">var</span> createReadableStreamAsyncIterator = <span class="function"><span class="keyword">function</span> <span class="title">createReadableStreamAsyncIterator</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> _Object$create;

  <span class="keyword">var</span> iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: <span class="literal">true</span>
  }), _defineProperty(_Object$create, kLastResolve, {
    value: <span class="literal">null</span>,
    writable: <span class="literal">true</span>
  }), _defineProperty(_Object$create, kLastReject, {
    value: <span class="literal">null</span>,
    writable: <span class="literal">true</span>
  }), _defineProperty(_Object$create, kError, {
    value: <span class="literal">null</span>,
    writable: <span class="literal">true</span>
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: <span class="literal">true</span>
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: <span class="function"><span class="keyword">function</span> <span class="title">value</span><span class="params">(resolve, reject)</span> {</span>
      <span class="keyword">var</span> data = iterator[kStream].read();

      <span class="keyword">if</span> (data) {
        iterator[kLastPromise] = <span class="literal">null</span>;
        iterator[kLastResolve] = <span class="literal">null</span>;
        iterator[kLastReject] = <span class="literal">null</span>;
        resolve(createIterResult(data, <span class="literal">false</span>));
      } <span class="keyword">else</span> {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: <span class="literal">true</span>
  }), _Object$create));
  iterator[kLastPromise] = <span class="literal">null</span>;
  finished(stream, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err &amp;&amp; err.code !== <span class="string">'ERR_STREAM_PREMATURE_CLOSE'</span>) {
      <span class="keyword">var</span> reject = iterator[kLastReject]; <span class="comment">// reject if we are waiting for data in the Promise</span>
      <span class="comment">// returned by next() and store the error</span>

      <span class="keyword">if</span> (reject !== <span class="literal">null</span>) {
        iterator[kLastPromise] = <span class="literal">null</span>;
        iterator[kLastResolve] = <span class="literal">null</span>;
        iterator[kLastReject] = <span class="literal">null</span>;
        reject(err);
      }

      iterator[kError] = err;
      <span class="keyword">return</span>;
    }

    <span class="keyword">var</span> resolve = iterator[kLastResolve];

    <span class="keyword">if</span> (resolve !== <span class="literal">null</span>) {
      iterator[kLastPromise] = <span class="literal">null</span>;
      iterator[kLastResolve] = <span class="literal">null</span>;
      iterator[kLastReject] = <span class="literal">null</span>;
      resolve(createIterResult(<span class="literal">undefined</span>, <span class="literal">true</span>));
    }

    iterator[kEnded] = <span class="literal">true</span>;
  });
  stream.on(<span class="string">'readable'</span>, onReadable.bind(<span class="literal">null</span>, iterator));
  <span class="keyword">return</span> iterator;
};

module.exports = createReadableStreamAsyncIterator;</code></pre>