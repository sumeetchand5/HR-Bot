<h1>buffer_list.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="function"><span class="keyword">function</span> <span class="title">_objectSpread</span><span class="params">(target)</span> {</span> <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arguments.length; i++) { <span class="keyword">var</span> source = arguments[i] != <span class="literal">null</span> ? arguments[i] : {}; <span class="keyword">var</span> ownKeys = Object.keys(source); <span class="keyword">if</span> (<span class="keyword">typeof</span> Object.getOwnPropertySymbols === <span class="string">'function'</span>) { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(<span class="function"><span class="keyword">function</span> <span class="params">(sym)</span> {</span> <span class="keyword">return</span> Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(key)</span> {</span> _defineProperty(target, key, source[key]); }); } <span class="keyword">return</span> target; }

<span class="function"><span class="keyword">function</span> <span class="title">_defineProperty</span><span class="params">(obj, key, value)</span> {</span> <span class="keyword">if</span> (key <span class="keyword">in</span> obj) { Object.defineProperty(obj, key, { value: value, enumerable: <span class="literal">true</span>, configurable: <span class="literal">true</span>, writable: <span class="literal">true</span> }); } <span class="keyword">else</span> { obj[key] = value; } <span class="keyword">return</span> obj; }

<span class="keyword">var</span> _require = require(<span class="string">'buffer'</span>),
    Buffer = _require.Buffer;

<span class="keyword">var</span> _require2 = require(<span class="string">'util'</span>),
    inspect = _require2.inspect;

<span class="keyword">var</span> custom = inspect &amp;&amp; inspect.custom || <span class="string">'inspect'</span>;

<span class="function"><span class="keyword">function</span> <span class="title">copyBuffer</span><span class="params">(src, target, offset)</span> {</span>
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
<span class="comment">/*#__PURE__*/</span>
<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="function"><span class="keyword">function</span> <span class="title">BufferList</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.head = <span class="literal">null</span>;
    <span class="keyword">this</span>.tail = <span class="literal">null</span>;
    <span class="keyword">this</span>.length = <span class="number">0</span>;
  }

  <span class="keyword">var</span> _proto = BufferList.prototype;

  _proto.push = <span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(v)</span> {</span>
    <span class="keyword">var</span> entry = {
      data: v,
      next: <span class="literal">null</span>
    };
    <span class="keyword">if</span> (<span class="keyword">this</span>.length > <span class="number">0</span>) <span class="keyword">this</span>.tail.next = entry;<span class="keyword">else</span> <span class="keyword">this</span>.head = entry;
    <span class="keyword">this</span>.tail = entry;
    ++<span class="keyword">this</span>.length;
  };

  _proto.unshift = <span class="function"><span class="keyword">function</span> <span class="title">unshift</span><span class="params">(v)</span> {</span>
    <span class="keyword">var</span> entry = {
      data: v,
      next: <span class="keyword">this</span>.head
    };
    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">this</span>.tail = entry;
    <span class="keyword">this</span>.head = entry;
    ++<span class="keyword">this</span>.length;
  };

  _proto.shift = <span class="function"><span class="keyword">function</span> <span class="title">shift</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">return</span>;
    <span class="keyword">var</span> ret = <span class="keyword">this</span>.head.data;
    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">1</span>) <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = <span class="literal">null</span>;<span class="keyword">else</span> <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;
    --<span class="keyword">this</span>.length;
    <span class="keyword">return</span> ret;
  };

  _proto.clear = <span class="function"><span class="keyword">function</span> <span class="title">clear</span><span class="params">()</span> {</span>
    <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = <span class="literal">null</span>;
    <span class="keyword">this</span>.length = <span class="number">0</span>;
  };

  _proto.join = <span class="function"><span class="keyword">function</span> <span class="title">join</span><span class="params">(s)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">''</span>;
    <span class="keyword">var</span> p = <span class="keyword">this</span>.head;
    <span class="keyword">var</span> ret = <span class="string">''</span> + p.data;

    <span class="keyword">while</span> (p = p.next) {
      ret += s + p.data;
    }

    <span class="keyword">return</span> ret;
  };

  _proto.concat = <span class="function"><span class="keyword">function</span> <span class="title">concat</span><span class="params">(n)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>.length === <span class="number">0</span>) <span class="keyword">return</span> Buffer.alloc(<span class="number">0</span>);
    <span class="keyword">var</span> ret = Buffer.allocUnsafe(n >>> <span class="number">0</span>);
    <span class="keyword">var</span> p = <span class="keyword">this</span>.head;
    <span class="keyword">var</span> i = <span class="number">0</span>;

    <span class="keyword">while</span> (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    <span class="keyword">return</span> ret;
  } <span class="comment">// Consumes a specified amount of bytes or characters from the buffered data.</span>
  ;

  _proto.consume = <span class="function"><span class="keyword">function</span> <span class="title">consume</span><span class="params">(n, hasStrings)</span> {</span>
    <span class="keyword">var</span> ret;

    <span class="keyword">if</span> (n &lt; <span class="keyword">this</span>.head.data.length) {
      <span class="comment">// `slice` is the same for buffers and strings.</span>
      ret = <span class="keyword">this</span>.head.data.slice(<span class="number">0</span>, n);
      <span class="keyword">this</span>.head.data = <span class="keyword">this</span>.head.data.slice(n);
    } <span class="keyword">else</span> <span class="keyword">if</span> (n === <span class="keyword">this</span>.head.data.length) {
      <span class="comment">// First chunk is a perfect match.</span>
      ret = <span class="keyword">this</span>.shift();
    } <span class="keyword">else</span> {
      <span class="comment">// Result spans more than one buffer.</span>
      ret = hasStrings ? <span class="keyword">this</span>._getString(n) : <span class="keyword">this</span>._getBuffer(n);
    }

    <span class="keyword">return</span> ret;
  };

  _proto.first = <span class="function"><span class="keyword">function</span> <span class="title">first</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.head.data;
  } <span class="comment">// Consumes a specified amount of characters from the buffered data.</span>
  ;

  _proto._getString = <span class="function"><span class="keyword">function</span> <span class="title">_getString</span><span class="params">(n)</span> {</span>
    <span class="keyword">var</span> p = <span class="keyword">this</span>.head;
    <span class="keyword">var</span> c = <span class="number">1</span>;
    <span class="keyword">var</span> ret = p.data;
    n -= ret.length;

    <span class="keyword">while</span> (p = p.next) {
      <span class="keyword">var</span> str = p.data;
      <span class="keyword">var</span> nb = n > str.length ? str.length : n;
      <span class="keyword">if</span> (nb === str.length) ret += str;<span class="keyword">else</span> ret += str.slice(<span class="number">0</span>, n);
      n -= nb;

      <span class="keyword">if</span> (n === <span class="number">0</span>) {
        <span class="keyword">if</span> (nb === str.length) {
          ++c;
          <span class="keyword">if</span> (p.next) <span class="keyword">this</span>.head = p.next;<span class="keyword">else</span> <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = <span class="literal">null</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.head = p;
          p.data = str.slice(nb);
        }

        <span class="keyword">break</span>;
      }

      ++c;
    }

    <span class="keyword">this</span>.length -= c;
    <span class="keyword">return</span> ret;
  } <span class="comment">// Consumes a specified amount of bytes from the buffered data.</span>
  ;

  _proto._getBuffer = <span class="function"><span class="keyword">function</span> <span class="title">_getBuffer</span><span class="params">(n)</span> {</span>
    <span class="keyword">var</span> ret = Buffer.allocUnsafe(n);
    <span class="keyword">var</span> p = <span class="keyword">this</span>.head;
    <span class="keyword">var</span> c = <span class="number">1</span>;
    p.data.copy(ret);
    n -= p.data.length;

    <span class="keyword">while</span> (p = p.next) {
      <span class="keyword">var</span> buf = p.data;
      <span class="keyword">var</span> nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, <span class="number">0</span>, nb);
      n -= nb;

      <span class="keyword">if</span> (n === <span class="number">0</span>) {
        <span class="keyword">if</span> (nb === buf.length) {
          ++c;
          <span class="keyword">if</span> (p.next) <span class="keyword">this</span>.head = p.next;<span class="keyword">else</span> <span class="keyword">this</span>.head = <span class="keyword">this</span>.tail = <span class="literal">null</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.head = p;
          p.data = buf.slice(nb);
        }

        <span class="keyword">break</span>;
      }

      ++c;
    }

    <span class="keyword">this</span>.length -= c;
    <span class="keyword">return</span> ret;
  } <span class="comment">// Make sure the linked list only shows the minimal necessary information.</span>
  ;

  _proto[custom] = <span class="function"><span class="keyword">function</span> <span class="params">(_, options)</span> {</span>
    <span class="keyword">return</span> inspect(<span class="keyword">this</span>, _objectSpread({}, options, {
      <span class="comment">// Only inspect one level.</span>
      depth: <span class="number">0</span>,
      <span class="comment">// It should not recurse.</span>
      customInspect: <span class="literal">false</span>
    }));
  };

  <span class="keyword">return</span> BufferList;
}();</code></pre>