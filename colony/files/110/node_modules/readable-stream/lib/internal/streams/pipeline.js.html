<h1>pipeline.js</h1>
<pre><code class="lang-js"><span class="comment">// Ported from https://github.com/mafintosh/pump with</span>
<span class="comment">// permission from the author, Mathias Buus (@mafintosh).</span>
<span class="string">'use strict'</span>;

<span class="keyword">var</span> eos;

<span class="function"><span class="keyword">function</span> <span class="title">once</span><span class="params">(callback)</span> {</span>
  <span class="keyword">var</span> called = <span class="literal">false</span>;
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span> (called) <span class="keyword">return</span>;
    called = <span class="literal">true</span>;
    callback.apply(<span class="keyword">void</span> <span class="number">0</span>, arguments);
  };
}

<span class="keyword">var</span> _require$codes = require(<span class="string">'../../../errors'</span>).codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

<span class="function"><span class="keyword">function</span> <span class="title">noop</span><span class="params">(err)</span> {</span>
  <span class="comment">// Rethrow the error if it exists to avoid swallowing it</span>
  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;
}

<span class="function"><span class="keyword">function</span> <span class="title">isRequest</span><span class="params">(stream)</span> {</span>
  <span class="keyword">return</span> stream.setHeader &amp;&amp; <span class="keyword">typeof</span> stream.abort === <span class="string">'function'</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">destroyer</span><span class="params">(stream, reading, writing, callback)</span> {</span>
  callback = once(callback);
  <span class="keyword">var</span> closed = <span class="literal">false</span>;
  stream.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    closed = <span class="literal">true</span>;
  });
  <span class="keyword">if</span> (eos === <span class="literal">undefined</span>) eos = require(<span class="string">'./end-of-stream'</span>);
  eos(stream, {
    readable: reading,
    writable: writing
  }, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);
    closed = <span class="literal">true</span>;
    callback();
  });
  <span class="keyword">var</span> destroyed = <span class="literal">false</span>;
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (closed) <span class="keyword">return</span>;
    <span class="keyword">if</span> (destroyed) <span class="keyword">return</span>;
    destroyed = <span class="literal">true</span>; <span class="comment">// request.destroy just do .end - .abort is what we want</span>

    <span class="keyword">if</span> (isRequest(stream)) <span class="keyword">return</span> stream.abort();
    <span class="keyword">if</span> (<span class="keyword">typeof</span> stream.destroy === <span class="string">'function'</span>) <span class="keyword">return</span> stream.destroy();
    callback(err || <span class="keyword">new</span> ERR_STREAM_DESTROYED(<span class="string">'pipe'</span>));
  };
}

<span class="function"><span class="keyword">function</span> <span class="title">call</span><span class="params">(fn)</span> {</span>
  fn();
}

<span class="function"><span class="keyword">function</span> <span class="title">pipe</span><span class="params">(from, to)</span> {</span>
  <span class="keyword">return</span> from.pipe(to);
}

<span class="function"><span class="keyword">function</span> <span class="title">popCallback</span><span class="params">(streams)</span> {</span>
  <span class="keyword">if</span> (!streams.length) <span class="keyword">return</span> noop;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> streams[streams.length - <span class="number">1</span>] !== <span class="string">'function'</span>) <span class="keyword">return</span> noop;
  <span class="keyword">return</span> streams.pop();
}

<span class="function"><span class="keyword">function</span> <span class="title">pipeline</span><span class="params">()</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> _len = arguments.length, streams = <span class="keyword">new</span> Array(_len), _key = <span class="number">0</span>; _key &lt; _len; _key++) {
    streams[_key] = arguments[_key];
  }

  <span class="keyword">var</span> callback = popCallback(streams);
  <span class="keyword">if</span> (Array.isArray(streams[<span class="number">0</span>])) streams = streams[<span class="number">0</span>];

  <span class="keyword">if</span> (streams.length &lt; <span class="number">2</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> ERR_MISSING_ARGS(<span class="string">'streams'</span>);
  }

  <span class="keyword">var</span> error;
  <span class="keyword">var</span> destroys = streams.map(<span class="function"><span class="keyword">function</span> <span class="params">(stream, i)</span> {</span>
    <span class="keyword">var</span> reading = i &lt; streams.length - <span class="number">1</span>;
    <span class="keyword">var</span> writing = i > <span class="number">0</span>;
    <span class="keyword">return</span> destroyer(stream, reading, writing, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
      <span class="keyword">if</span> (!error) error = err;
      <span class="keyword">if</span> (err) destroys.forEach(call);
      <span class="keyword">if</span> (reading) <span class="keyword">return</span>;
      destroys.forEach(call);
      callback(error);
    });
  });
  <span class="keyword">return</span> streams.reduce(pipe);
}

module.exports = pipeline;</code></pre>