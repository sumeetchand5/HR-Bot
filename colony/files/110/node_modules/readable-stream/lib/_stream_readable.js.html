<h1>_stream_readable.js</h1>
<pre><code class="lang-js"><span class="comment">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="comment">//</span>
<span class="comment">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="comment">// copy of this software and associated documentation files (the</span>
<span class="comment">// "Software"), to deal in the Software without restriction, including</span>
<span class="comment">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="comment">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="comment">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="comment">// following conditions:</span>
<span class="comment">//</span>
<span class="comment">// The above copyright notice and this permission notice shall be included</span>
<span class="comment">// in all copies or substantial portions of the Software.</span>
<span class="comment">//</span>
<span class="comment">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="comment">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="comment">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="comment">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="comment">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="comment">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="comment">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="string">'use strict'</span>;

module.exports = Readable;
<span class="comment">/*&lt;replacement>*/</span>

<span class="keyword">var</span> Duplex;
<span class="comment">/*&lt;/replacement>*/</span>

Readable.ReadableState = ReadableState;
<span class="comment">/*&lt;replacement>*/</span>

<span class="keyword">var</span> EE = require(<span class="string">'events'</span>).EventEmitter;

<span class="keyword">var</span> EElistenerCount = <span class="function"><span class="keyword">function</span> <span class="title">EElistenerCount</span><span class="params">(emitter, type)</span> {</span>
  <span class="keyword">return</span> emitter.listeners(type).length;
};
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>


<span class="keyword">var</span> Stream = require(<span class="string">'./internal/streams/stream'</span>);
<span class="comment">/*&lt;/replacement>*/</span>


<span class="keyword">var</span> Buffer = require(<span class="string">'buffer'</span>).Buffer;

<span class="keyword">var</span> OurUint8Array = global.Uint8Array || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};

<span class="function"><span class="keyword">function</span> <span class="title">_uint8ArrayToBuffer</span><span class="params">(chunk)</span> {</span>
  <span class="keyword">return</span> Buffer.from(chunk);
}

<span class="function"><span class="keyword">function</span> <span class="title">_isUint8Array</span><span class="params">(obj)</span> {</span>
  <span class="keyword">return</span> Buffer.isBuffer(obj) || obj <span class="keyword">instanceof</span> OurUint8Array;
}
<span class="comment">/*&lt;replacement>*/</span>


<span class="keyword">var</span> debugUtil = require(<span class="string">'util'</span>);

<span class="keyword">var</span> debug;

<span class="keyword">if</span> (debugUtil &amp;&amp; debugUtil.debuglog) {
  debug = debugUtil.debuglog(<span class="string">'stream'</span>);
} <span class="keyword">else</span> {
  debug = <span class="function"><span class="keyword">function</span> <span class="title">debug</span><span class="params">()</span> {</span>};
}
<span class="comment">/*&lt;/replacement>*/</span>


<span class="keyword">var</span> BufferList = require(<span class="string">'./internal/streams/buffer_list'</span>);

<span class="keyword">var</span> destroyImpl = require(<span class="string">'./internal/streams/destroy'</span>);

<span class="keyword">var</span> _require = require(<span class="string">'./internal/streams/state'</span>),
    getHighWaterMark = _require.getHighWaterMark;

<span class="keyword">var</span> _require$codes = require(<span class="string">'../errors'</span>).codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

<span class="keyword">var</span> _require2 = require(<span class="string">'../experimentalWarning'</span>),
    emitExperimentalWarning = _require2.emitExperimentalWarning; <span class="comment">// Lazy loaded to improve the startup performance.</span>


<span class="keyword">var</span> StringDecoder;
<span class="keyword">var</span> createReadableStreamAsyncIterator;

require(<span class="string">'inherits'</span>)(Readable, Stream);

<span class="keyword">var</span> kProxyEvents = [<span class="string">'error'</span>, <span class="string">'close'</span>, <span class="string">'destroy'</span>, <span class="string">'pause'</span>, <span class="string">'resume'</span>];

<span class="function"><span class="keyword">function</span> <span class="title">prependListener</span><span class="params">(emitter, event, fn)</span> {</span>
  <span class="comment">// Sadly this is not cacheable as some libraries bundle their own</span>
  <span class="comment">// event emitter implementation with them.</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> emitter.prependListener === <span class="string">'function'</span>) <span class="keyword">return</span> emitter.prependListener(event, fn); <span class="comment">// This is a hack to make sure that our error handler is attached before any</span>
  <span class="comment">// userland ones.  NEVER DO THIS. This is here only because this code needs</span>
  <span class="comment">// to continue to work with older versions of Node.js that do not include</span>
  <span class="comment">// the prependListener() method. The goal is to eventually remove this hack.</span>

  <span class="keyword">if</span> (!emitter._events || !emitter._events[event]) emitter.on(event, fn);<span class="keyword">else</span> <span class="keyword">if</span> (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);<span class="keyword">else</span> emitter._events[event] = [fn, emitter._events[event]];
}

<span class="function"><span class="keyword">function</span> <span class="title">ReadableState</span><span class="params">(options, stream, isDuplex)</span> {</span>
  Duplex = Duplex || require(<span class="string">'./_stream_duplex'</span>);
  options = options || {}; <span class="comment">// Duplex streams are both readable and writable, but share</span>
  <span class="comment">// the same options object.</span>
  <span class="comment">// However, some cases require setting options to different</span>
  <span class="comment">// values for the readable and the writable sides of the duplex stream.</span>
  <span class="comment">// These options can be provided separately as readableXXX and writableXXX.</span>

  <span class="keyword">if</span> (<span class="keyword">typeof</span> isDuplex !== <span class="string">'boolean'</span>) isDuplex = stream <span class="keyword">instanceof</span> Duplex; <span class="comment">// object stream flag. Used to make read(n) ignore n and to</span>
  <span class="comment">// make all the buffer merging and length checks go away</span>

  <span class="keyword">this</span>.objectMode = !!options.objectMode;
  <span class="keyword">if</span> (isDuplex) <span class="keyword">this</span>.objectMode = <span class="keyword">this</span>.objectMode || !!options.readableObjectMode; <span class="comment">// the point at which it stops calling _read() to fill the buffer</span>
  <span class="comment">// Note: 0 is a valid value, means "don't call _read preemptively ever"</span>

  <span class="keyword">this</span>.highWaterMark = getHighWaterMark(<span class="keyword">this</span>, options, <span class="string">'readableHighWaterMark'</span>, isDuplex); <span class="comment">// A linked list is used to store data chunks instead of an array because the</span>
  <span class="comment">// linked list can remove elements from the beginning faster than</span>
  <span class="comment">// array.shift()</span>

  <span class="keyword">this</span>.buffer = <span class="keyword">new</span> BufferList();
  <span class="keyword">this</span>.length = <span class="number">0</span>;
  <span class="keyword">this</span>.pipes = <span class="literal">null</span>;
  <span class="keyword">this</span>.pipesCount = <span class="number">0</span>;
  <span class="keyword">this</span>.flowing = <span class="literal">null</span>;
  <span class="keyword">this</span>.ended = <span class="literal">false</span>;
  <span class="keyword">this</span>.endEmitted = <span class="literal">false</span>;
  <span class="keyword">this</span>.reading = <span class="literal">false</span>; <span class="comment">// a flag to be able to tell if the event 'readable'/'data' is emitted</span>
  <span class="comment">// immediately, or on a later tick.  We set this to true at first, because</span>
  <span class="comment">// any actions that shouldn't happen until "later" should generally also</span>
  <span class="comment">// not happen before the first read call.</span>

  <span class="keyword">this</span>.sync = <span class="literal">true</span>; <span class="comment">// whenever we return null, then we set a flag to say</span>
  <span class="comment">// that we're awaiting a 'readable' event emission.</span>

  <span class="keyword">this</span>.needReadable = <span class="literal">false</span>;
  <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span>;
  <span class="keyword">this</span>.readableListening = <span class="literal">false</span>;
  <span class="keyword">this</span>.resumeScheduled = <span class="literal">false</span>;
  <span class="keyword">this</span>.paused = <span class="literal">true</span>; <span class="comment">// Should close be emitted on destroy. Defaults to true.</span>

  <span class="keyword">this</span>.emitClose = options.emitClose !== <span class="literal">false</span>; <span class="comment">// has it been destroyed</span>

  <span class="keyword">this</span>.destroyed = <span class="literal">false</span>; <span class="comment">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="comment">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="comment">// Everything else in the universe uses 'utf8', though.</span>

  <span class="keyword">this</span>.defaultEncoding = options.defaultEncoding || <span class="string">'utf8'</span>; <span class="comment">// the number of writers that are awaiting a drain event in .pipe()s</span>

  <span class="keyword">this</span>.awaitDrain = <span class="number">0</span>; <span class="comment">// if true, a maybeReadMore has been scheduled</span>

  <span class="keyword">this</span>.readingMore = <span class="literal">false</span>;
  <span class="keyword">this</span>.decoder = <span class="literal">null</span>;
  <span class="keyword">this</span>.encoding = <span class="literal">null</span>;

  <span class="keyword">if</span> (options.encoding) {
    <span class="keyword">if</span> (!StringDecoder) StringDecoder = require(<span class="string">'string_decoder/'</span>).StringDecoder;
    <span class="keyword">this</span>.decoder = <span class="keyword">new</span> StringDecoder(options.encoding);
    <span class="keyword">this</span>.encoding = options.encoding;
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">Readable</span><span class="params">(options)</span> {</span>
  Duplex = Duplex || require(<span class="string">'./_stream_duplex'</span>);
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Readable)) <span class="keyword">return</span> <span class="keyword">new</span> Readable(options); <span class="comment">// Checking for a Stream.Duplex instance is faster here instead of inside</span>
  <span class="comment">// the ReadableState constructor, at least with V8 6.5</span>

  <span class="keyword">var</span> isDuplex = <span class="keyword">this</span> <span class="keyword">instanceof</span> Duplex;
  <span class="keyword">this</span>._readableState = <span class="keyword">new</span> ReadableState(options, <span class="keyword">this</span>, isDuplex); <span class="comment">// legacy</span>

  <span class="keyword">this</span>.readable = <span class="literal">true</span>;

  <span class="keyword">if</span> (options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.read === <span class="string">'function'</span>) <span class="keyword">this</span>._read = options.read;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.destroy === <span class="string">'function'</span>) <span class="keyword">this</span>._destroy = options.destroy;
  }

  Stream.call(<span class="keyword">this</span>);
}

Object.defineProperty(Readable.prototype, <span class="string">'destroyed'</span>, {
  <span class="comment">// making it explicit this property is not enumerable</span>
  <span class="comment">// because otherwise some prototype manipulation in</span>
  <span class="comment">// userland will fail</span>
  enumerable: <span class="literal">false</span>,
  get: <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>._readableState === <span class="literal">undefined</span>) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="keyword">return</span> <span class="keyword">this</span>._readableState.destroyed;
  },
  set: <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">(value)</span> {</span>
    <span class="comment">// we ignore the value if the stream</span>
    <span class="comment">// has not been initialized yet</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>._readableState) {
      <span class="keyword">return</span>;
    } <span class="comment">// backward compatibility, the user is explicitly</span>
    <span class="comment">// managing destroyed</span>


    <span class="keyword">this</span>._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = <span class="function"><span class="keyword">function</span> <span class="params">(err, cb)</span> {</span>
  cb(err);
}; <span class="comment">// Manually shove something into the read() buffer.</span>
<span class="comment">// This returns true if the highWaterMark has not been hit yet,</span>
<span class="comment">// similar to how Writable.write() returns true if you should</span>
<span class="comment">// write() some more.</span>


Readable.prototype.push = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding)</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> skipChunkCheck;

  <span class="keyword">if</span> (!state.objectMode) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">'string'</span>) {
      encoding = encoding || state.defaultEncoding;

      <span class="keyword">if</span> (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = <span class="string">''</span>;
      }

      skipChunkCheck = <span class="literal">true</span>;
    }
  } <span class="keyword">else</span> {
    skipChunkCheck = <span class="literal">true</span>;
  }

  <span class="keyword">return</span> readableAddChunk(<span class="keyword">this</span>, chunk, encoding, <span class="literal">false</span>, skipChunkCheck);
}; <span class="comment">// Unshift should *always* be something directly out of read()</span>


Readable.prototype.unshift = <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
  <span class="keyword">return</span> readableAddChunk(<span class="keyword">this</span>, chunk, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">false</span>);
};

<span class="function"><span class="keyword">function</span> <span class="title">readableAddChunk</span><span class="params">(stream, chunk, encoding, addToFront, skipChunkCheck)</span> {</span>
  debug(<span class="string">'readableAddChunk'</span>, chunk);
  <span class="keyword">var</span> state = stream._readableState;

  <span class="keyword">if</span> (chunk === <span class="literal">null</span>) {
    state.reading = <span class="literal">false</span>;
    onEofChunk(stream, state);
  } <span class="keyword">else</span> {
    <span class="keyword">var</span> er;
    <span class="keyword">if</span> (!skipChunkCheck) er = chunkInvalid(state, chunk);

    <span class="keyword">if</span> (er) {
      stream.emit(<span class="string">'error'</span>, er);
    } <span class="keyword">else</span> <span class="keyword">if</span> (state.objectMode || chunk &amp;&amp; chunk.length > <span class="number">0</span>) {
      <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk !== <span class="string">'string'</span> &amp;&amp; !state.objectMode &amp;&amp; Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      <span class="keyword">if</span> (addToFront) {
        <span class="keyword">if</span> (state.endEmitted) stream.emit(<span class="string">'error'</span>, <span class="keyword">new</span> ERR_STREAM_UNSHIFT_AFTER_END_EVENT());<span class="keyword">else</span> addChunk(stream, state, chunk, <span class="literal">true</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (state.ended) {
        stream.emit(<span class="string">'error'</span>, <span class="keyword">new</span> ERR_STREAM_PUSH_AFTER_EOF());
      } <span class="keyword">else</span> <span class="keyword">if</span> (state.destroyed) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      } <span class="keyword">else</span> {
        state.reading = <span class="literal">false</span>;

        <span class="keyword">if</span> (state.decoder &amp;&amp; !encoding) {
          chunk = state.decoder.write(chunk);
          <span class="keyword">if</span> (state.objectMode || chunk.length !== <span class="number">0</span>) addChunk(stream, state, chunk, <span class="literal">false</span>);<span class="keyword">else</span> maybeReadMore(stream, state);
        } <span class="keyword">else</span> {
          addChunk(stream, state, chunk, <span class="literal">false</span>);
        }
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (!addToFront) {
      state.reading = <span class="literal">false</span>;
      maybeReadMore(stream, state);
    }
  } <span class="comment">// We can push more data if we are below the highWaterMark.</span>
  <span class="comment">// Also, if we have no data yet, we can stand some more bytes.</span>
  <span class="comment">// This is to work around cases where hwm=0, such as the repl.</span>


  <span class="keyword">return</span> !state.ended &amp;&amp; (state.length &lt; state.highWaterMark || state.length === <span class="number">0</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">addChunk</span><span class="params">(stream, state, chunk, addToFront)</span> {</span>
  <span class="keyword">if</span> (state.flowing &amp;&amp; state.length === <span class="number">0</span> &amp;&amp; !state.sync) {
    state.awaitDrain = <span class="number">0</span>;
    stream.emit(<span class="string">'data'</span>, chunk);
  } <span class="keyword">else</span> {
    <span class="comment">// update the buffer info.</span>
    state.length += state.objectMode ? <span class="number">1</span> : chunk.length;
    <span class="keyword">if</span> (addToFront) state.buffer.unshift(chunk);<span class="keyword">else</span> state.buffer.push(chunk);
    <span class="keyword">if</span> (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

<span class="function"><span class="keyword">function</span> <span class="title">chunkInvalid</span><span class="params">(state, chunk)</span> {</span>
  <span class="keyword">var</span> er;

  <span class="keyword">if</span> (!_isUint8Array(chunk) &amp;&amp; <span class="keyword">typeof</span> chunk !== <span class="string">'string'</span> &amp;&amp; chunk !== <span class="literal">undefined</span> &amp;&amp; !state.objectMode) {
    er = <span class="keyword">new</span> ERR_INVALID_ARG_TYPE(<span class="string">'chunk'</span>, [<span class="string">'string'</span>, <span class="string">'Buffer'</span>, <span class="string">'Uint8Array'</span>], chunk);
  }

  <span class="keyword">return</span> er;
}

Readable.prototype.isPaused = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>._readableState.flowing === <span class="literal">false</span>;
}; <span class="comment">// backwards compatibility.</span>


Readable.prototype.setEncoding = <span class="function"><span class="keyword">function</span> <span class="params">(enc)</span> {</span>
  <span class="keyword">if</span> (!StringDecoder) StringDecoder = require(<span class="string">'string_decoder/'</span>).StringDecoder;
  <span class="keyword">this</span>._readableState.decoder = <span class="keyword">new</span> StringDecoder(enc); <span class="comment">// if setEncoding(null), decoder.encoding equals utf8</span>

  <span class="keyword">this</span>._readableState.encoding = <span class="keyword">this</span>._readableState.decoder.encoding;
  <span class="keyword">return</span> <span class="keyword">this</span>;
}; <span class="comment">// Don't raise the hwm > 8MB</span>


<span class="keyword">var</span> MAX_HWM = <span class="number">0x800000</span>;

<span class="function"><span class="keyword">function</span> <span class="title">computeNewHighWaterMark</span><span class="params">(n)</span> {</span>
  <span class="keyword">if</span> (n >= MAX_HWM) {
    n = MAX_HWM;
  } <span class="keyword">else</span> {
    <span class="comment">// Get the next highest power of 2 to prevent increasing hwm excessively in</span>
    <span class="comment">// tiny amounts</span>
    n--;
    n |= n >>> <span class="number">1</span>;
    n |= n >>> <span class="number">2</span>;
    n |= n >>> <span class="number">4</span>;
    n |= n >>> <span class="number">8</span>;
    n |= n >>> <span class="number">16</span>;
    n++;
  }

  <span class="keyword">return</span> n;
} <span class="comment">// This function is designed to be inlinable, so please take care when making</span>
<span class="comment">// changes to the function body.</span>


<span class="function"><span class="keyword">function</span> <span class="title">howMuchToRead</span><span class="params">(n, state)</span> {</span>
  <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || state.length === <span class="number">0</span> &amp;&amp; state.ended) <span class="keyword">return</span> <span class="number">0</span>;
  <span class="keyword">if</span> (state.objectMode) <span class="keyword">return</span> <span class="number">1</span>;

  <span class="keyword">if</span> (n !== n) {
    <span class="comment">// Only flow one buffer at a time</span>
    <span class="keyword">if</span> (state.flowing &amp;&amp; state.length) <span class="keyword">return</span> state.buffer.head.data.length;<span class="keyword">else</span> <span class="keyword">return</span> state.length;
  } <span class="comment">// If we're asking for more than the current hwm, then raise the hwm.</span>


  <span class="keyword">if</span> (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  <span class="keyword">if</span> (n &lt;= state.length) <span class="keyword">return</span> n; <span class="comment">// Don't have enough</span>

  <span class="keyword">if</span> (!state.ended) {
    state.needReadable = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
  }

  <span class="keyword">return</span> state.length;
} <span class="comment">// you can override either this method, or the async _read(n) below.</span>


Readable.prototype.read = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
  debug(<span class="string">'read'</span>, n);
  n = parseInt(n, <span class="number">10</span>);
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> nOrig = n;
  <span class="keyword">if</span> (n !== <span class="number">0</span>) state.emittedReadable = <span class="literal">false</span>; <span class="comment">// if we're doing read(0) to trigger a readable event, but we</span>
  <span class="comment">// already have a bunch of data in the buffer, then just trigger</span>
  <span class="comment">// the 'readable' event and move on.</span>

  <span class="keyword">if</span> (n === <span class="number">0</span> &amp;&amp; state.needReadable &amp;&amp; ((state.highWaterMark !== <span class="number">0</span> ? state.length >= state.highWaterMark : state.length > <span class="number">0</span>) || state.ended)) {
    debug(<span class="string">'read: emitReadable'</span>, state.length, state.ended);
    <span class="keyword">if</span> (state.length === <span class="number">0</span> &amp;&amp; state.ended) endReadable(<span class="keyword">this</span>);<span class="keyword">else</span> emitReadable(<span class="keyword">this</span>);
    <span class="keyword">return</span> <span class="literal">null</span>;
  }

  n = howMuchToRead(n, state); <span class="comment">// if we've ended, and we're now clear, then finish it up.</span>

  <span class="keyword">if</span> (n === <span class="number">0</span> &amp;&amp; state.ended) {
    <span class="keyword">if</span> (state.length === <span class="number">0</span>) endReadable(<span class="keyword">this</span>);
    <span class="keyword">return</span> <span class="literal">null</span>;
  } <span class="comment">// All the actual chunk generation logic needs to be</span>
  <span class="comment">// *below* the call to _read.  The reason is that in certain</span>
  <span class="comment">// synthetic stream cases, such as passthrough streams, _read</span>
  <span class="comment">// may be a completely synchronous operation which may change</span>
  <span class="comment">// the state of the read buffer, providing enough data when</span>
  <span class="comment">// before there was *not* enough.</span>
  <span class="comment">//</span>
  <span class="comment">// So, the steps are:</span>
  <span class="comment">// 1. Figure out what the state of things will be after we do</span>
  <span class="comment">// a read from the buffer.</span>
  <span class="comment">//</span>
  <span class="comment">// 2. If that resulting state will trigger a _read, then call _read.</span>
  <span class="comment">// Note that this may be asynchronous, or synchronous.  Yes, it is</span>
  <span class="comment">// deeply ugly to write APIs this way, but that still doesn't mean</span>
  <span class="comment">// that the Readable class should behave improperly, as streams are</span>
  <span class="comment">// designed to be sync/async agnostic.</span>
  <span class="comment">// Take note if the _read call is sync or async (ie, if the read call</span>
  <span class="comment">// has returned yet), so that we know whether or not it's safe to emit</span>
  <span class="comment">// 'readable' etc.</span>
  <span class="comment">//</span>
  <span class="comment">// 3. Actually pull the requested chunks out of the buffer and return.</span>
  <span class="comment">// if we need a readable event, then we need to do some reading.</span>


  <span class="keyword">var</span> doRead = state.needReadable;
  debug(<span class="string">'need readable'</span>, doRead); <span class="comment">// if we currently have less than the highWaterMark, then also read some</span>

  <span class="keyword">if</span> (state.length === <span class="number">0</span> || state.length - n &lt; state.highWaterMark) {
    doRead = <span class="literal">true</span>;
    debug(<span class="string">'length less than watermark'</span>, doRead);
  } <span class="comment">// however, if we've ended, then there's no point, and if we're already</span>
  <span class="comment">// reading, then it's unnecessary.</span>


  <span class="keyword">if</span> (state.ended || state.reading) {
    doRead = <span class="literal">false</span>;
    debug(<span class="string">'reading or ended'</span>, doRead);
  } <span class="keyword">else</span> <span class="keyword">if</span> (doRead) {
    debug(<span class="string">'do read'</span>);
    state.reading = <span class="literal">true</span>;
    state.sync = <span class="literal">true</span>; <span class="comment">// if the length is currently zero, then we *need* a readable event.</span>

    <span class="keyword">if</span> (state.length === <span class="number">0</span>) state.needReadable = <span class="literal">true</span>; <span class="comment">// call internal read method</span>

    <span class="keyword">this</span>._read(state.highWaterMark);

    state.sync = <span class="literal">false</span>; <span class="comment">// If _read pushed data synchronously, then `reading` will be false,</span>
    <span class="comment">// and we need to re-evaluate how much data we can return to the user.</span>

    <span class="keyword">if</span> (!state.reading) n = howMuchToRead(nOrig, state);
  }

  <span class="keyword">var</span> ret;
  <span class="keyword">if</span> (n > <span class="number">0</span>) ret = fromList(n, state);<span class="keyword">else</span> ret = <span class="literal">null</span>;

  <span class="keyword">if</span> (ret === <span class="literal">null</span>) {
    state.needReadable = <span class="literal">true</span>;
    n = <span class="number">0</span>;
  } <span class="keyword">else</span> {
    state.length -= n;
    state.awaitDrain = <span class="number">0</span>;
  }

  <span class="keyword">if</span> (state.length === <span class="number">0</span>) {
    <span class="comment">// If we have nothing in the buffer, then we want to know</span>
    <span class="comment">// as soon as we *do* get something into the buffer.</span>
    <span class="keyword">if</span> (!state.ended) state.needReadable = <span class="literal">true</span>; <span class="comment">// If we tried to read() past the EOF, then emit end on the next tick.</span>

    <span class="keyword">if</span> (nOrig !== n &amp;&amp; state.ended) endReadable(<span class="keyword">this</span>);
  }

  <span class="keyword">if</span> (ret !== <span class="literal">null</span>) <span class="keyword">this</span>.emit(<span class="string">'data'</span>, ret);
  <span class="keyword">return</span> ret;
};

<span class="function"><span class="keyword">function</span> <span class="title">onEofChunk</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (state.ended) <span class="keyword">return</span>;

  <span class="keyword">if</span> (state.decoder) {
    <span class="keyword">var</span> chunk = state.decoder.end();

    <span class="keyword">if</span> (chunk &amp;&amp; chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? <span class="number">1</span> : chunk.length;
    }
  }

  state.ended = <span class="literal">true</span>;

  <span class="keyword">if</span> (state.sync) {
    <span class="comment">// if we are sync, wait until next tick to emit the data.</span>
    <span class="comment">// Otherwise we risk emitting data in the flow()</span>
    <span class="comment">// the readable code triggers during a read() call</span>
    emitReadable(stream);
  } <span class="keyword">else</span> {
    <span class="comment">// emit 'readable' now to make sure it gets picked up.</span>
    state.needReadable = <span class="literal">false</span>;

    <span class="keyword">if</span> (!state.emittedReadable) {
      state.emittedReadable = <span class="literal">true</span>;
      emitReadable_(stream);
    }
  }
} <span class="comment">// Don't emit readable right away in sync mode, because this can trigger</span>
<span class="comment">// another read() call => stack overflow.  This way, it might trigger</span>
<span class="comment">// a nextTick recursion warning, but that's not so bad.</span>


<span class="function"><span class="keyword">function</span> <span class="title">emitReadable</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;
  state.needReadable = <span class="literal">false</span>;

  <span class="keyword">if</span> (!state.emittedReadable) {
    debug(<span class="string">'emitReadable'</span>, state.flowing);
    state.emittedReadable = <span class="literal">true</span>;
    process.nextTick(emitReadable_, stream);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">emitReadable_</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;
  debug(<span class="string">'emitReadable_'</span>, state.destroyed, state.length, state.ended);

  <span class="keyword">if</span> (!state.destroyed &amp;&amp; (state.length || state.ended)) {
    stream.emit(<span class="string">'readable'</span>);
  } <span class="comment">// The stream needs another readable event if</span>
  <span class="comment">// 1. It is not flowing, as the flow mechanism will take</span>
  <span class="comment">//    care of it.</span>
  <span class="comment">// 2. It is not ended.</span>
  <span class="comment">// 3. It is below the highWaterMark, so we can schedule</span>
  <span class="comment">//    another readable later.</span>


  state.needReadable = !state.flowing &amp;&amp; !state.ended &amp;&amp; state.length &lt;= state.highWaterMark;
  flow(stream);
} <span class="comment">// at this point, the user has presumably seen the 'readable' event,</span>
<span class="comment">// and called read() to consume some data.  that may have triggered</span>
<span class="comment">// in turn another _read(n) call, in which case reading = true if</span>
<span class="comment">// it's in progress.</span>
<span class="comment">// However, if we're not ended, or reading, and the length &lt; hwm,</span>
<span class="comment">// then go ahead and try to read some more preemptively.</span>


<span class="function"><span class="keyword">function</span> <span class="title">maybeReadMore</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (!state.readingMore) {
    state.readingMore = <span class="literal">true</span>;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">maybeReadMore_</span><span class="params">(stream, state)</span> {</span>
  <span class="comment">// Attempt to read more data if we should.</span>
  <span class="comment">//</span>
  <span class="comment">// The conditions for reading more data are (one of):</span>
  <span class="comment">// - Not enough data buffered (state.length &lt; state.highWaterMark). The loop</span>
  <span class="comment">//   is responsible for filling the buffer with enough data if such data</span>
  <span class="comment">//   is available. If highWaterMark is 0 and we are not in the flowing mode</span>
  <span class="comment">//   we should _not_ attempt to buffer any extra data. We'll get more data</span>
  <span class="comment">//   when the stream consumer calls read() instead.</span>
  <span class="comment">// - No data in the buffer, and the stream is in flowing mode. In this mode</span>
  <span class="comment">//   the loop below is responsible for ensuring read() is called. Failing to</span>
  <span class="comment">//   call read here would abort the flow and there's no other mechanism for</span>
  <span class="comment">//   continuing the flow if the stream consumer has just subscribed to the</span>
  <span class="comment">//   'data' event.</span>
  <span class="comment">//</span>
  <span class="comment">// In addition to the above conditions to keep reading data, the following</span>
  <span class="comment">// conditions prevent the data from being read:</span>
  <span class="comment">// - The stream has ended (state.ended).</span>
  <span class="comment">// - There is already a pending 'read' operation (state.reading). This is a</span>
  <span class="comment">//   case where the the stream has called the implementation defined _read()</span>
  <span class="comment">//   method, but they are processing the call asynchronously and have _not_</span>
  <span class="comment">//   called push() with new data. In this case we skip performing more</span>
  <span class="comment">//   read()s. The execution ends in this method again after the _read() ends</span>
  <span class="comment">//   up calling push() with more data.</span>
  <span class="keyword">while</span> (!state.reading &amp;&amp; !state.ended &amp;&amp; (state.length &lt; state.highWaterMark || state.flowing &amp;&amp; state.length === <span class="number">0</span>)) {
    <span class="keyword">var</span> len = state.length;
    debug(<span class="string">'maybeReadMore read 0'</span>);
    stream.read(<span class="number">0</span>);
    <span class="keyword">if</span> (len === state.length) <span class="comment">// didn't get any data, stop spinning.</span>
      <span class="keyword">break</span>;
  }

  state.readingMore = <span class="literal">false</span>;
} <span class="comment">// abstract method.  to be overridden in specific implementation classes.</span>
<span class="comment">// call cb(er, data) where data is &lt;= n in length.</span>
<span class="comment">// for virtual (non-string, non-buffer) streams, "length" is somewhat</span>
<span class="comment">// arbitrary, and perhaps not very meaningful.</span>


Readable.prototype._read = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
  <span class="keyword">this</span>.emit(<span class="string">'error'</span>, <span class="keyword">new</span> ERR_METHOD_NOT_IMPLEMENTED(<span class="string">'_read()'</span>));
};

Readable.prototype.pipe = <span class="function"><span class="keyword">function</span> <span class="params">(dest, pipeOpts)</span> {</span>
  <span class="keyword">var</span> src = <span class="keyword">this</span>;
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;

  <span class="keyword">switch</span> (state.pipesCount) {
    <span class="keyword">case</span> <span class="number">0</span>:
      state.pipes = dest;
      <span class="keyword">break</span>;

    <span class="keyword">case</span> <span class="number">1</span>:
      state.pipes = [state.pipes, dest];
      <span class="keyword">break</span>;

    <span class="keyword">default</span>:
      state.pipes.push(dest);
      <span class="keyword">break</span>;
  }

  state.pipesCount += <span class="number">1</span>;
  debug(<span class="string">'pipe count=%d opts=%j'</span>, state.pipesCount, pipeOpts);
  <span class="keyword">var</span> doEnd = (!pipeOpts || pipeOpts.end !== <span class="literal">false</span>) &amp;&amp; dest !== process.stdout &amp;&amp; dest !== process.stderr;
  <span class="keyword">var</span> endFn = doEnd ? onend : unpipe;
  <span class="keyword">if</span> (state.endEmitted) process.nextTick(endFn);<span class="keyword">else</span> src.once(<span class="string">'end'</span>, endFn);
  dest.on(<span class="string">'unpipe'</span>, onunpipe);

  <span class="function"><span class="keyword">function</span> <span class="title">onunpipe</span><span class="params">(readable, unpipeInfo)</span> {</span>
    debug(<span class="string">'onunpipe'</span>);

    <span class="keyword">if</span> (readable === src) {
      <span class="keyword">if</span> (unpipeInfo &amp;&amp; unpipeInfo.hasUnpiped === <span class="literal">false</span>) {
        unpipeInfo.hasUnpiped = <span class="literal">true</span>;
        cleanup();
      }
    }
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onend</span><span class="params">()</span> {</span>
    debug(<span class="string">'onend'</span>);
    dest.end();
  } <span class="comment">// when the dest drains, it reduces the awaitDrain counter</span>
  <span class="comment">// on the source.  This would be more elegant with a .once()</span>
  <span class="comment">// handler in flow(), but adding and removing repeatedly is</span>
  <span class="comment">// too slow.</span>


  <span class="keyword">var</span> ondrain = pipeOnDrain(src);
  dest.on(<span class="string">'drain'</span>, ondrain);
  <span class="keyword">var</span> cleanedUp = <span class="literal">false</span>;

  <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span><span class="params">()</span> {</span>
    debug(<span class="string">'cleanup'</span>); <span class="comment">// cleanup event handlers once the pipe is broken</span>

    dest.removeListener(<span class="string">'close'</span>, onclose);
    dest.removeListener(<span class="string">'finish'</span>, onfinish);
    dest.removeListener(<span class="string">'drain'</span>, ondrain);
    dest.removeListener(<span class="string">'error'</span>, onerror);
    dest.removeListener(<span class="string">'unpipe'</span>, onunpipe);
    src.removeListener(<span class="string">'end'</span>, onend);
    src.removeListener(<span class="string">'end'</span>, unpipe);
    src.removeListener(<span class="string">'data'</span>, ondata);
    cleanedUp = <span class="literal">true</span>; <span class="comment">// if the reader is waiting for a drain event from this</span>
    <span class="comment">// specific writer, then it would cause it to never start</span>
    <span class="comment">// flowing again.</span>
    <span class="comment">// So, if this is awaiting a drain, then we just call it now.</span>
    <span class="comment">// If we don't know, then assume that we are waiting for one.</span>

    <span class="keyword">if</span> (state.awaitDrain &amp;&amp; (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on(<span class="string">'data'</span>, ondata);

  <span class="function"><span class="keyword">function</span> <span class="title">ondata</span><span class="params">(chunk)</span> {</span>
    debug(<span class="string">'ondata'</span>);
    <span class="keyword">var</span> ret = dest.write(chunk);
    debug(<span class="string">'dest.write'</span>, ret);

    <span class="keyword">if</span> (ret === <span class="literal">false</span>) {
      <span class="comment">// If the user unpiped during `dest.write()`, it is possible</span>
      <span class="comment">// to get stuck in a permanently paused state if that write</span>
      <span class="comment">// also returned false.</span>
      <span class="comment">// => Check whether `dest` is still a piping destination.</span>
      <span class="keyword">if</span> ((state.pipesCount === <span class="number">1</span> &amp;&amp; state.pipes === dest || state.pipesCount > <span class="number">1</span> &amp;&amp; indexOf(state.pipes, dest) !== -<span class="number">1</span>) &amp;&amp; !cleanedUp) {
        debug(<span class="string">'false write response, pause'</span>, state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } <span class="comment">// if the dest has an error, then stop piping into it.</span>
  <span class="comment">// however, don't suppress the throwing behavior for this.</span>


  <span class="function"><span class="keyword">function</span> <span class="title">onerror</span><span class="params">(er)</span> {</span>
    debug(<span class="string">'onerror'</span>, er);
    unpipe();
    dest.removeListener(<span class="string">'error'</span>, onerror);
    <span class="keyword">if</span> (EElistenerCount(dest, <span class="string">'error'</span>) === <span class="number">0</span>) dest.emit(<span class="string">'error'</span>, er);
  } <span class="comment">// Make sure our error handler is attached before userland ones.</span>


  prependListener(dest, <span class="string">'error'</span>, onerror); <span class="comment">// Both close and finish should trigger unpipe, but only once.</span>

  <span class="function"><span class="keyword">function</span> <span class="title">onclose</span><span class="params">()</span> {</span>
    dest.removeListener(<span class="string">'finish'</span>, onfinish);
    unpipe();
  }

  dest.once(<span class="string">'close'</span>, onclose);

  <span class="function"><span class="keyword">function</span> <span class="title">onfinish</span><span class="params">()</span> {</span>
    debug(<span class="string">'onfinish'</span>);
    dest.removeListener(<span class="string">'close'</span>, onclose);
    unpipe();
  }

  dest.once(<span class="string">'finish'</span>, onfinish);

  <span class="function"><span class="keyword">function</span> <span class="title">unpipe</span><span class="params">()</span> {</span>
    debug(<span class="string">'unpipe'</span>);
    src.unpipe(dest);
  } <span class="comment">// tell the dest that it's being piped to</span>


  dest.emit(<span class="string">'pipe'</span>, src); <span class="comment">// start the flow if it hasn't been started already.</span>

  <span class="keyword">if</span> (!state.flowing) {
    debug(<span class="string">'pipe resume'</span>);
    src.resume();
  }

  <span class="keyword">return</span> dest;
};

<span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrain</span><span class="params">(src)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrainFunctionResult</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> state = src._readableState;
    debug(<span class="string">'pipeOnDrain'</span>, state.awaitDrain);
    <span class="keyword">if</span> (state.awaitDrain) state.awaitDrain--;

    <span class="keyword">if</span> (state.awaitDrain === <span class="number">0</span> &amp;&amp; EElistenerCount(src, <span class="string">'data'</span>)) {
      state.flowing = <span class="literal">true</span>;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = <span class="function"><span class="keyword">function</span> <span class="params">(dest)</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> unpipeInfo = {
    hasUnpiped: <span class="literal">false</span>
  }; <span class="comment">// if we're not piping anywhere, then do nothing.</span>

  <span class="keyword">if</span> (state.pipesCount === <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// just one destination.  most common case.</span>

  <span class="keyword">if</span> (state.pipesCount === <span class="number">1</span>) {
    <span class="comment">// passed in one, but it's not the right one.</span>
    <span class="keyword">if</span> (dest &amp;&amp; dest !== state.pipes) <span class="keyword">return</span> <span class="keyword">this</span>;
    <span class="keyword">if</span> (!dest) dest = state.pipes; <span class="comment">// got a match.</span>

    state.pipes = <span class="literal">null</span>;
    state.pipesCount = <span class="number">0</span>;
    state.flowing = <span class="literal">false</span>;
    <span class="keyword">if</span> (dest) dest.emit(<span class="string">'unpipe'</span>, <span class="keyword">this</span>, unpipeInfo);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  } <span class="comment">// slow case. multiple pipe destinations.</span>


  <span class="keyword">if</span> (!dest) {
    <span class="comment">// remove all.</span>
    <span class="keyword">var</span> dests = state.pipes;
    <span class="keyword">var</span> len = state.pipesCount;
    state.pipes = <span class="literal">null</span>;
    state.pipesCount = <span class="number">0</span>;
    state.flowing = <span class="literal">false</span>;

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
      dests[i].emit(<span class="string">'unpipe'</span>, <span class="keyword">this</span>, {
        hasUnpiped: <span class="literal">false</span>
      });
    }

    <span class="keyword">return</span> <span class="keyword">this</span>;
  } <span class="comment">// try to find the right one.</span>


  <span class="keyword">var</span> index = indexOf(state.pipes, dest);
  <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>;
  state.pipes.splice(index, <span class="number">1</span>);
  state.pipesCount -= <span class="number">1</span>;
  <span class="keyword">if</span> (state.pipesCount === <span class="number">1</span>) state.pipes = state.pipes[<span class="number">0</span>];
  dest.emit(<span class="string">'unpipe'</span>, <span class="keyword">this</span>, unpipeInfo);
  <span class="keyword">return</span> <span class="keyword">this</span>;
}; <span class="comment">// set up data events if they are asked for</span>
<span class="comment">// Ensure readable listeners eventually get something</span>


Readable.prototype.on = <span class="function"><span class="keyword">function</span> <span class="params">(ev, fn)</span> {</span>
  <span class="keyword">var</span> res = Stream.prototype.on.call(<span class="keyword">this</span>, ev, fn);
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;

  <span class="keyword">if</span> (ev === <span class="string">'data'</span>) {
    <span class="comment">// update readableListening so that resume() may be a no-op</span>
    <span class="comment">// a few lines down. This is needed to support once('readable').</span>
    state.readableListening = <span class="keyword">this</span>.listenerCount(<span class="string">'readable'</span>) > <span class="number">0</span>; <span class="comment">// Try start flowing on next tick if stream isn't explicitly paused</span>

    <span class="keyword">if</span> (state.flowing !== <span class="literal">false</span>) <span class="keyword">this</span>.resume();
  } <span class="keyword">else</span> <span class="keyword">if</span> (ev === <span class="string">'readable'</span>) {
    <span class="keyword">if</span> (!state.endEmitted &amp;&amp; !state.readableListening) {
      state.readableListening = state.needReadable = <span class="literal">true</span>;
      state.flowing = <span class="literal">false</span>;
      state.emittedReadable = <span class="literal">false</span>;
      debug(<span class="string">'on readable'</span>, state.length, state.reading);

      <span class="keyword">if</span> (state.length) {
        emitReadable(<span class="keyword">this</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (!state.reading) {
        process.nextTick(nReadingNextTick, <span class="keyword">this</span>);
      }
    }
  }

  <span class="keyword">return</span> res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = <span class="function"><span class="keyword">function</span> <span class="params">(ev, fn)</span> {</span>
  <span class="keyword">var</span> res = Stream.prototype.removeListener.call(<span class="keyword">this</span>, ev, fn);

  <span class="keyword">if</span> (ev === <span class="string">'readable'</span>) {
    <span class="comment">// We need to check if there is someone still listening to</span>
    <span class="comment">// readable and reset the state. However this needs to happen</span>
    <span class="comment">// after readable has been emitted but before I/O (nextTick) to</span>
    <span class="comment">// support once('readable', fn) cycles. This means that calling</span>
    <span class="comment">// resume within the same tick will have no</span>
    <span class="comment">// effect.</span>
    process.nextTick(updateReadableListening, <span class="keyword">this</span>);
  }

  <span class="keyword">return</span> res;
};

Readable.prototype.removeAllListeners = <span class="function"><span class="keyword">function</span> <span class="params">(ev)</span> {</span>
  <span class="keyword">var</span> res = Stream.prototype.removeAllListeners.apply(<span class="keyword">this</span>, arguments);

  <span class="keyword">if</span> (ev === <span class="string">'readable'</span> || ev === <span class="literal">undefined</span>) {
    <span class="comment">// We need to check if there is someone still listening to</span>
    <span class="comment">// readable and reset the state. However this needs to happen</span>
    <span class="comment">// after readable has been emitted but before I/O (nextTick) to</span>
    <span class="comment">// support once('readable', fn) cycles. This means that calling</span>
    <span class="comment">// resume within the same tick will have no</span>
    <span class="comment">// effect.</span>
    process.nextTick(updateReadableListening, <span class="keyword">this</span>);
  }

  <span class="keyword">return</span> res;
};

<span class="function"><span class="keyword">function</span> <span class="title">updateReadableListening</span><span class="params">(self)</span> {</span>
  <span class="keyword">var</span> state = self._readableState;
  state.readableListening = self.listenerCount(<span class="string">'readable'</span>) > <span class="number">0</span>;

  <span class="keyword">if</span> (state.resumeScheduled &amp;&amp; !state.paused) {
    <span class="comment">// flowing needs to be set to true now, otherwise</span>
    <span class="comment">// the upcoming resume will not flow.</span>
    state.flowing = <span class="literal">true</span>; <span class="comment">// crude way to check if we should resume</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> (self.listenerCount(<span class="string">'data'</span>) > <span class="number">0</span>) {
    self.resume();
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">nReadingNextTick</span><span class="params">(self)</span> {</span>
  debug(<span class="string">'readable nexttick read 0'</span>);
  self.read(<span class="number">0</span>);
} <span class="comment">// pause() and resume() are remnants of the legacy readable stream API</span>
<span class="comment">// If the user uses them, then switch into old mode.</span>


Readable.prototype.resume = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;

  <span class="keyword">if</span> (!state.flowing) {
    debug(<span class="string">'resume'</span>); <span class="comment">// we flow only if there is no one listening</span>
    <span class="comment">// for readable, but we still have to call</span>
    <span class="comment">// resume()</span>

    state.flowing = !state.readableListening;
    resume(<span class="keyword">this</span>, state);
  }

  state.paused = <span class="literal">false</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="function"><span class="keyword">function</span> <span class="title">resume</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (!state.resumeScheduled) {
    state.resumeScheduled = <span class="literal">true</span>;
    process.nextTick(resume_, stream, state);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">resume_</span><span class="params">(stream, state)</span> {</span>
  debug(<span class="string">'resume'</span>, state.reading);

  <span class="keyword">if</span> (!state.reading) {
    stream.read(<span class="number">0</span>);
  }

  state.resumeScheduled = <span class="literal">false</span>;
  stream.emit(<span class="string">'resume'</span>);
  flow(stream);
  <span class="keyword">if</span> (state.flowing &amp;&amp; !state.reading) stream.read(<span class="number">0</span>);
}

Readable.prototype.pause = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  debug(<span class="string">'call pause flowing=%j'</span>, <span class="keyword">this</span>._readableState.flowing);

  <span class="keyword">if</span> (<span class="keyword">this</span>._readableState.flowing !== <span class="literal">false</span>) {
    debug(<span class="string">'pause'</span>);
    <span class="keyword">this</span>._readableState.flowing = <span class="literal">false</span>;
    <span class="keyword">this</span>.emit(<span class="string">'pause'</span>);
  }

  <span class="keyword">this</span>._readableState.paused = <span class="literal">true</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="function"><span class="keyword">function</span> <span class="title">flow</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;
  debug(<span class="string">'flow'</span>, state.flowing);

  <span class="keyword">while</span> (state.flowing &amp;&amp; stream.read() !== <span class="literal">null</span>) {
    ;
  }
} <span class="comment">// wrap an old-style stream as the async data source.</span>
<span class="comment">// This is *not* part of the readable stream interface.</span>
<span class="comment">// It is an ugly unfortunate mess of history.</span>


Readable.prototype.wrap = <span class="function"><span class="keyword">function</span> <span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> paused = <span class="literal">false</span>;
  stream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    debug(<span class="string">'wrapped end'</span>);

    <span class="keyword">if</span> (state.decoder &amp;&amp; !state.ended) {
      <span class="keyword">var</span> chunk = state.decoder.end();
      <span class="keyword">if</span> (chunk &amp;&amp; chunk.length) _<span class="keyword">this</span>.push(chunk);
    }

    _<span class="keyword">this</span>.push(<span class="literal">null</span>);
  });
  stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
    debug(<span class="string">'wrapped data'</span>);
    <span class="keyword">if</span> (state.decoder) chunk = state.decoder.write(chunk); <span class="comment">// don't skip over falsy values in objectMode</span>

    <span class="keyword">if</span> (state.objectMode &amp;&amp; (chunk === <span class="literal">null</span> || chunk === <span class="literal">undefined</span>)) <span class="keyword">return</span>;<span class="keyword">else</span> <span class="keyword">if</span> (!state.objectMode &amp;&amp; (!chunk || !chunk.length)) <span class="keyword">return</span>;

    <span class="keyword">var</span> ret = _<span class="keyword">this</span>.push(chunk);

    <span class="keyword">if</span> (!ret) {
      paused = <span class="literal">true</span>;
      stream.pause();
    }
  }); <span class="comment">// proxy all the other methods.</span>
  <span class="comment">// important when wrapping filters and duplexes.</span>

  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> stream) {
    <span class="keyword">if</span> (<span class="keyword">this</span>[i] === <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> stream[i] === <span class="string">'function'</span>) {
      <span class="keyword">this</span>[i] = <span class="function"><span class="keyword">function</span> <span class="title">methodWrap</span><span class="params">(method)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">methodWrapReturnFunction</span><span class="params">()</span> {</span>
          <span class="keyword">return</span> stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } <span class="comment">// proxy certain important events.</span>


  <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], <span class="keyword">this</span>.emit.bind(<span class="keyword">this</span>, kProxyEvents[n]));
  } <span class="comment">// when we try to consume some more bytes, simply unpause the</span>
  <span class="comment">// underlying stream.</span>


  <span class="keyword">this</span>._read = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
    debug(<span class="string">'wrapped _read'</span>, n);

    <span class="keyword">if</span> (paused) {
      paused = <span class="literal">false</span>;
      stream.resume();
    }
  };

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="keyword">if</span> (<span class="keyword">typeof</span> Symbol === <span class="string">'function'</span>) {
  Readable.prototype[Symbol.asyncIterator] = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    emitExperimentalWarning(<span class="string">'Readable[Symbol.asyncIterator]'</span>);

    <span class="keyword">if</span> (createReadableStreamAsyncIterator === <span class="literal">undefined</span>) {
      createReadableStreamAsyncIterator = require(<span class="string">'./internal/streams/async_iterator'</span>);
    }

    <span class="keyword">return</span> createReadableStreamAsyncIterator(<span class="keyword">this</span>);
  };
}

Object.defineProperty(Readable.prototype, <span class="string">'readableHighWaterMark'</span>, {
  <span class="comment">// making it explicit this property is not enumerable</span>
  <span class="comment">// because otherwise some prototype manipulation in</span>
  <span class="comment">// userland will fail</span>
  enumerable: <span class="literal">false</span>,
  get: <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, <span class="string">'readableBuffer'</span>, {
  <span class="comment">// making it explicit this property is not enumerable</span>
  <span class="comment">// because otherwise some prototype manipulation in</span>
  <span class="comment">// userland will fail</span>
  enumerable: <span class="literal">false</span>,
  get: <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._readableState &amp;&amp; <span class="keyword">this</span>._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, <span class="string">'readableFlowing'</span>, {
  <span class="comment">// making it explicit this property is not enumerable</span>
  <span class="comment">// because otherwise some prototype manipulation in</span>
  <span class="comment">// userland will fail</span>
  enumerable: <span class="literal">false</span>,
  get: <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._readableState.flowing;
  },
  set: <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">(state)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>._readableState) {
      <span class="keyword">this</span>._readableState.flowing = state;
    }
  }
}); <span class="comment">// exposed for testing purposes only.</span>

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, <span class="string">'readableLength'</span>, {
  <span class="comment">// making it explicit this property is not enumerable</span>
  <span class="comment">// because otherwise some prototype manipulation in</span>
  <span class="comment">// userland will fail</span>
  enumerable: <span class="literal">false</span>,
  get: <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._readableState.length;
  }
}); <span class="comment">// Pluck off n bytes from an array of buffers.</span>
<span class="comment">// Length is the combined lengths of all the buffers in the list.</span>
<span class="comment">// This function is designed to be inlinable, so please take care when making</span>
<span class="comment">// changes to the function body.</span>

<span class="function"><span class="keyword">function</span> <span class="title">fromList</span><span class="params">(n, state)</span> {</span>
  <span class="comment">// nothing buffered</span>
  <span class="keyword">if</span> (state.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;
  <span class="keyword">var</span> ret;
  <span class="keyword">if</span> (state.objectMode) ret = state.buffer.shift();<span class="keyword">else</span> <span class="keyword">if</span> (!n || n >= state.length) {
    <span class="comment">// read it all, truncate the list</span>
    <span class="keyword">if</span> (state.decoder) ret = state.buffer.join(<span class="string">''</span>);<span class="keyword">else</span> <span class="keyword">if</span> (state.buffer.length === <span class="number">1</span>) ret = state.buffer.first();<span class="keyword">else</span> ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } <span class="keyword">else</span> {
    <span class="comment">// read part of list</span>
    ret = state.buffer.consume(n, state.decoder);
  }
  <span class="keyword">return</span> ret;
}

<span class="function"><span class="keyword">function</span> <span class="title">endReadable</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;
  debug(<span class="string">'endReadable'</span>, state.endEmitted);

  <span class="keyword">if</span> (!state.endEmitted) {
    state.ended = <span class="literal">true</span>;
    process.nextTick(endReadableNT, state, stream);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">endReadableNT</span><span class="params">(state, stream)</span> {</span>
  debug(<span class="string">'endReadableNT'</span>, state.endEmitted, state.length); <span class="comment">// Check that we didn't get one last unshift.</span>

  <span class="keyword">if</span> (!state.endEmitted &amp;&amp; state.length === <span class="number">0</span>) {
    state.endEmitted = <span class="literal">true</span>;
    stream.readable = <span class="literal">false</span>;
    stream.emit(<span class="string">'end'</span>);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">indexOf</span><span class="params">(xs, x)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = xs.length; i &lt; l; i++) {
    <span class="keyword">if</span> (xs[i] === x) <span class="keyword">return</span> i;
  }

  <span class="keyword">return</span> -<span class="number">1</span>;
}</code></pre>