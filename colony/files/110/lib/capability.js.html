<h1>capability.js</h1>
<pre><code class="lang-js">exports.fetch = isFunction(global.fetch) &amp;&amp; isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

<span class="comment">// The xhr request to example.com may violate some restrictive CSP configurations,</span>
<span class="comment">// so if we're running in a browser that supports `fetch`, avoid calling getXHR()</span>
<span class="comment">// and assume support for certain features below.</span>
<span class="keyword">var</span> xhr
<span class="function"><span class="keyword">function</span> <span class="title">getXHR</span> <span class="params">()</span> {</span>
	<span class="comment">// Cache the xhr value</span>
	<span class="keyword">if</span> (xhr !== <span class="literal">undefined</span>) <span class="keyword">return</span> xhr

	<span class="keyword">if</span> (global.XMLHttpRequest) {
		xhr = <span class="keyword">new</span> global.XMLHttpRequest()
		<span class="comment">// If XDomainRequest is available (ie only, where xhr might not work</span>
		<span class="comment">// cross domain), use the page location. Otherwise use example.com</span>
		<span class="comment">// Note: this doesn't actually make an http request.</span>
		<span class="keyword">try</span> {
			xhr.open(<span class="string">'GET'</span>, global.XDomainRequest ? <span class="string">'/'</span> : <span class="string">'https://example.com'</span>)
		} <span class="keyword">catch</span>(e) {
			xhr = <span class="literal">null</span>
		}
	} <span class="keyword">else</span> {
		<span class="comment">// Service workers don't have XHR</span>
		xhr = <span class="literal">null</span>
	}
	<span class="keyword">return</span> xhr
}

<span class="function"><span class="keyword">function</span> <span class="title">checkTypeSupport</span> <span class="params">(type)</span> {</span>
	<span class="keyword">var</span> xhr = getXHR()
	<span class="keyword">if</span> (!xhr) <span class="keyword">return</span> <span class="literal">false</span>
	<span class="keyword">try</span> {
		xhr.responseType = type
		<span class="keyword">return</span> xhr.responseType === type
	} <span class="keyword">catch</span> (e) {}
	<span class="keyword">return</span> <span class="literal">false</span>
}

<span class="comment">// If fetch is supported, then arraybuffer will be supported too. Skip calling</span>
<span class="comment">// checkTypeSupport(), since that calls getXHR().</span>
exports.arraybuffer = exports.fetch || checkTypeSupport(<span class="string">'arraybuffer'</span>)

<span class="comment">// These next two tests unavoidably show warnings in Chrome. Since fetch will always</span>
<span class="comment">// be used if it's available, just return false for these to avoid the warnings.</span>
exports.msstream = !exports.fetch &amp;&amp; checkTypeSupport(<span class="string">'ms-stream'</span>)
exports.mozchunkedarraybuffer = !exports.fetch &amp;&amp; checkTypeSupport(<span class="string">'moz-chunked-arraybuffer'</span>)

<span class="comment">// If fetch is supported, then overrideMimeType will be supported too. Skip calling</span>
<span class="comment">// getXHR().</span>
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : <span class="literal">false</span>)

<span class="function"><span class="keyword">function</span> <span class="title">isFunction</span> <span class="params">(value)</span> {</span>
	<span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'function'</span>
}

xhr = <span class="literal">null</span> <span class="comment">// Help gc</span>
</code></pre>