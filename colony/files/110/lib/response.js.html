<h1>response.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> capability = require(<span class="string">'./capability'</span>)
<span class="keyword">var</span> inherits = require(<span class="string">'inherits'</span>)
<span class="keyword">var</span> stream = require(<span class="string">'readable-stream'</span>)

<span class="keyword">var</span> rStates = exports.readyStates = {
	UNSENT: <span class="number">0</span>,
	OPENED: <span class="number">1</span>,
	HEADERS_RECEIVED: <span class="number">2</span>,
	LOADING: <span class="number">3</span>,
	DONE: <span class="number">4</span>
}

<span class="keyword">var</span> IncomingMessage = exports.IncomingMessage = <span class="function"><span class="keyword">function</span> <span class="params">(xhr, response, mode, fetchTimer)</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	<span class="comment">// Fake the 'close' event, but only once 'end' fires</span>
	self.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		<span class="comment">// The nextTick is necessary to prevent the 'request' module from causing an infinite loop</span>
		process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
			self.emit(<span class="string">'close'</span>)
		})
	})

	<span class="keyword">if</span> (mode === <span class="string">'fetch'</span>) {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(header, key)</span>{</span>
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		<span class="keyword">if</span> (capability.writableStream) {
			<span class="keyword">var</span> writable = <span class="keyword">new</span> WritableStream({
				write: <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
					<span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve, reject)</span> {</span>
						<span class="keyword">if</span> (self._destroyed) {
							reject()
						} <span class="keyword">else</span> <span class="keyword">if</span>(self.push(Buffer.from(chunk))) {
							resolve()
						} <span class="keyword">else</span> {
							self._resumeFetch = resolve
						}
					})
				},
				close: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
					global.clearTimeout(fetchTimer)
					<span class="keyword">if</span> (!self._destroyed)
						self.push(<span class="literal">null</span>)
				},
				abort: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
					<span class="keyword">if</span> (!self._destroyed)
						self.emit(<span class="string">'error'</span>, err)
				}
			})

			<span class="keyword">try</span> {
				response.body.pipeTo(writable).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
					global.clearTimeout(fetchTimer)
					<span class="keyword">if</span> (!self._destroyed)
						self.emit(<span class="string">'error'</span>, err)
				})
				<span class="keyword">return</span>
			} <span class="keyword">catch</span> (e) {} <span class="comment">// pipeTo method isn't defined. Can't find a better way to feature test this</span>
		}
		<span class="comment">// fallback for when writableStream or pipeTo aren't available</span>
		<span class="keyword">var</span> reader = response.body.getReader()
		<span class="function"><span class="keyword">function</span> <span class="title">read</span> <span class="params">()</span> {</span>
			reader.read().then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> {</span>
				<span class="keyword">if</span> (self._destroyed)
					<span class="keyword">return</span>
				<span class="keyword">if</span> (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(<span class="literal">null</span>)
					<span class="keyword">return</span>
				}
				self.push(Buffer.from(result.value))
				read()
			}).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
				global.clearTimeout(fetchTimer)
				<span class="keyword">if</span> (!self._destroyed)
					self.emit(<span class="string">'error'</span>, err)
			})
		}
		read()
	} <span class="keyword">else</span> {
		self._xhr = xhr
		self._pos = <span class="number">0</span>

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		<span class="keyword">var</span> headers = xhr.getAllResponseHeaders().split(<span class="regexp">/\r?\n/</span>)
		headers.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(header)</span> {</span>
			<span class="keyword">var</span> matches = header.match(<span class="regexp">/^([^:]+):\s*(.*)/</span>)
			<span class="keyword">if</span> (matches) {
				<span class="keyword">var</span> key = matches[<span class="number">1</span>].toLowerCase()
				<span class="keyword">if</span> (key === <span class="string">'set-cookie'</span>) {
					<span class="keyword">if</span> (self.headers[key] === <span class="literal">undefined</span>) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[<span class="number">2</span>])
				} <span class="keyword">else</span> <span class="keyword">if</span> (self.headers[key] !== <span class="literal">undefined</span>) {
					self.headers[key] += <span class="string">', '</span> + matches[<span class="number">2</span>]
				} <span class="keyword">else</span> {
					self.headers[key] = matches[<span class="number">2</span>]
				}
				self.rawHeaders.push(matches[<span class="number">1</span>], matches[<span class="number">2</span>])
			}
		})

		self._charset = <span class="string">'x-user-defined'</span>
		<span class="keyword">if</span> (!capability.overrideMimeType) {
			<span class="keyword">var</span> mimeType = self.rawHeaders[<span class="string">'mime-type'</span>]
			<span class="keyword">if</span> (mimeType) {
				<span class="keyword">var</span> charsetMatch = mimeType.match(<span class="regexp">/;\s*charset=([^;])(;|$)/</span>)
				<span class="keyword">if</span> (charsetMatch) {
					self._charset = charsetMatch[<span class="number">1</span>].toLowerCase()
				}
			}
			<span class="keyword">if</span> (!self._charset)
				self._charset = <span class="string">'utf-8'</span> <span class="comment">// best guess</span>
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>

	<span class="keyword">var</span> resolve = self._resumeFetch
	<span class="keyword">if</span> (resolve) {
		self._resumeFetch = <span class="literal">null</span>
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>

	<span class="keyword">var</span> xhr = self._xhr

	<span class="keyword">var</span> response = <span class="literal">null</span>
	<span class="keyword">switch</span> (self._mode) {
		<span class="keyword">case</span> <span class="string">'text'</span>:
			response = xhr.responseText
			<span class="keyword">if</span> (response.length > self._pos) {
				<span class="keyword">var</span> newData = response.substr(self._pos)
				<span class="keyword">if</span> (self._charset === <span class="string">'x-user-defined'</span>) {
					<span class="keyword">var</span> buffer = Buffer.alloc(newData.length)
					<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; newData.length; i++)
						buffer[i] = newData.charCodeAt(i) &amp; <span class="number">0xff</span>

					self.push(buffer)
				} <span class="keyword">else</span> {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			<span class="keyword">break</span>
		<span class="keyword">case</span> <span class="string">'arraybuffer'</span>:
			<span class="keyword">if</span> (xhr.readyState !== rStates.DONE || !xhr.response)
				<span class="keyword">break</span>
			response = xhr.response
			self.push(Buffer.from(<span class="keyword">new</span> Uint8Array(response)))
			<span class="keyword">break</span>
		<span class="keyword">case</span> <span class="string">'moz-chunked-arraybuffer'</span>: <span class="comment">// take whole</span>
			response = xhr.response
			<span class="keyword">if</span> (xhr.readyState !== rStates.LOADING || !response)
				<span class="keyword">break</span>
			self.push(Buffer.from(<span class="keyword">new</span> Uint8Array(response)))
			<span class="keyword">break</span>
		<span class="keyword">case</span> <span class="string">'ms-stream'</span>:
			response = xhr.response
			<span class="keyword">if</span> (xhr.readyState !== rStates.LOADING)
				<span class="keyword">break</span>
			<span class="keyword">var</span> reader = <span class="keyword">new</span> global.MSStreamReader()
			reader.onprogress = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
				<span class="keyword">if</span> (reader.result.byteLength > self._pos) {
					self.push(Buffer.from(<span class="keyword">new</span> Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
				self.push(<span class="literal">null</span>)
			}
			<span class="comment">// reader.onerror = ??? // TODO: this</span>
			reader.readAsArrayBuffer(response)
			<span class="keyword">break</span>
	}

	<span class="comment">// The ms-stream case handles end separately in reader.onload()</span>
	<span class="keyword">if</span> (self._xhr.readyState === rStates.DONE &amp;&amp; self._mode !== <span class="string">'ms-stream'</span>) {
		self.push(<span class="literal">null</span>)
	}
}
</code></pre>