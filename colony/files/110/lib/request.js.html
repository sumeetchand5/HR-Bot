<h1>request.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> capability = require(<span class="string">'./capability'</span>)
<span class="keyword">var</span> inherits = require(<span class="string">'inherits'</span>)
<span class="keyword">var</span> response = require(<span class="string">'./response'</span>)
<span class="keyword">var</span> stream = require(<span class="string">'readable-stream'</span>)

<span class="keyword">var</span> IncomingMessage = response.IncomingMessage
<span class="keyword">var</span> rStates = response.readyStates

<span class="function"><span class="keyword">function</span> <span class="title">decideMode</span> <span class="params">(preferBinary, useFetch)</span> {</span>
	<span class="keyword">if</span> (capability.fetch &amp;&amp; useFetch) {
		<span class="keyword">return</span> <span class="string">'fetch'</span>
	} <span class="keyword">else</span> <span class="keyword">if</span> (capability.mozchunkedarraybuffer) {
		<span class="keyword">return</span> <span class="string">'moz-chunked-arraybuffer'</span>
	} <span class="keyword">else</span> <span class="keyword">if</span> (capability.msstream) {
		<span class="keyword">return</span> <span class="string">'ms-stream'</span>
	} <span class="keyword">else</span> <span class="keyword">if</span> (capability.arraybuffer &amp;&amp; preferBinary) {
		<span class="keyword">return</span> <span class="string">'arraybuffer'</span>
	} <span class="keyword">else</span> {
		<span class="keyword">return</span> <span class="string">'text'</span>
	}
}

<span class="keyword">var</span> ClientRequest = module.exports = <span class="function"><span class="keyword">function</span> <span class="params">(opts)</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	<span class="keyword">if</span> (opts.auth)
		self.setHeader(<span class="string">'Authorization'</span>, <span class="string">'Basic '</span> + Buffer.from(opts.auth).toString(<span class="string">'base64'</span>))
	Object.keys(opts.headers).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
		self.setHeader(name, opts.headers[name])
	})

	<span class="keyword">var</span> preferBinary
	<span class="keyword">var</span> useFetch = <span class="literal">true</span>
	<span class="keyword">if</span> (opts.mode === <span class="string">'disable-fetch'</span> || (<span class="string">'requestTimeout'</span> <span class="keyword">in</span> opts &amp;&amp; !capability.abortController)) {
		<span class="comment">// If the use of XHR should be preferred. Not typically needed.</span>
		useFetch = <span class="literal">false</span>
		preferBinary = <span class="literal">true</span>
	} <span class="keyword">else</span> <span class="keyword">if</span> (opts.mode === <span class="string">'prefer-streaming'</span>) {
		<span class="comment">// If streaming is a high priority but binary compatibility and</span>
		<span class="comment">// the accuracy of the 'content-type' header aren't</span>
		preferBinary = <span class="literal">false</span>
	} <span class="keyword">else</span> <span class="keyword">if</span> (opts.mode === <span class="string">'allow-wrong-content-type'</span>) {
		<span class="comment">// If streaming is more important than preserving the 'content-type' header</span>
		preferBinary = !capability.overrideMimeType
	} <span class="keyword">else</span> <span class="keyword">if</span> (!opts.mode || opts.mode === <span class="string">'default'</span> || opts.mode === <span class="string">'prefer-fast'</span>) {
		<span class="comment">// Use binary if text streaming may corrupt data or the content-type header, or for speed</span>
		preferBinary = <span class="literal">true</span>
	} <span class="keyword">else</span> {
		<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid value for opts.mode'</span>)
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = <span class="literal">null</span>

	self.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = <span class="function"><span class="keyword">function</span> <span class="params">(name, value)</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>
	<span class="keyword">var</span> lowerName = name.toLowerCase()
	<span class="comment">// This check is not necessary, but it prevents warnings from browsers about setting unsafe</span>
	<span class="comment">// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but</span>
	<span class="comment">// http-browserify did it, so I will too.</span>
	<span class="keyword">if</span> (unsafeHeaders.indexOf(lowerName) !== -<span class="number">1</span>)
		<span class="keyword">return</span>

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
	<span class="keyword">var</span> header = <span class="keyword">this</span>._headers[name.toLowerCase()]
	<span class="keyword">if</span> (header)
		<span class="keyword">return</span> header.value
	<span class="keyword">return</span> <span class="literal">null</span>
}

ClientRequest.prototype.removeHeader = <span class="function"><span class="keyword">function</span> <span class="params">(name)</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>
	<span class="keyword">delete</span> self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>

	<span class="keyword">if</span> (self._destroyed)
		<span class="keyword">return</span>
	<span class="keyword">var</span> opts = self._opts

	<span class="keyword">var</span> headersObj = self._headers
	<span class="keyword">var</span> body = <span class="literal">null</span>
	<span class="keyword">if</span> (opts.method !== <span class="string">'GET'</span> &amp;&amp; opts.method !== <span class="string">'HEAD'</span>) {
        body = <span class="keyword">new</span> Blob(self._body, {
            type: (headersObj[<span class="string">'content-type'</span>] || {}).value || <span class="string">''</span>
        });
    }

	<span class="comment">// create flattened list of headers</span>
	<span class="keyword">var</span> headersList = []
	Object.keys(headersObj).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(keyName)</span> {</span>
		<span class="keyword">var</span> name = headersObj[keyName].name
		<span class="keyword">var</span> value = headersObj[keyName].value
		<span class="keyword">if</span> (Array.isArray(value)) {
			value.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(v)</span> {</span>
				headersList.push([name, v])
			})
		} <span class="keyword">else</span> {
			headersList.push([name, value])
		}
	})

	<span class="keyword">if</span> (self._mode === <span class="string">'fetch'</span>) {
		<span class="keyword">var</span> signal = <span class="literal">null</span>
		<span class="keyword">var</span> fetchTimer = <span class="literal">null</span>
		<span class="keyword">if</span> (capability.abortController) {
			<span class="keyword">var</span> controller = <span class="keyword">new</span> AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			<span class="keyword">if</span> (<span class="string">'requestTimeout'</span> <span class="keyword">in</span> opts &amp;&amp; opts.requestTimeout !== <span class="number">0</span>) {
				self._fetchTimer = global.setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
					self.emit(<span class="string">'requestTimeout'</span>)
					<span class="keyword">if</span> (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || <span class="literal">undefined</span>,
			mode: <span class="string">'cors'</span>,
			credentials: opts.withCredentials ? <span class="string">'include'</span> : <span class="string">'same-origin'</span>,
			signal: signal
		}).then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> {</span>
			self._fetchResponse = response
			self._connect()
		}, <span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> {</span>
			global.clearTimeout(self._fetchTimer)
			<span class="keyword">if</span> (!self._destroyed)
				self.emit(<span class="string">'error'</span>, reason)
		})
	} <span class="keyword">else</span> {
		<span class="keyword">var</span> xhr = self._xhr = <span class="keyword">new</span> global.XMLHttpRequest()
		<span class="keyword">try</span> {
			xhr.open(self._opts.method, self._opts.url, <span class="literal">true</span>)
		} <span class="keyword">catch</span> (err) {
			process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
				self.emit(<span class="string">'error'</span>, err)
			})
			<span class="keyword">return</span>
		}

		<span class="comment">// Can't set responseType on really old browsers</span>
		<span class="keyword">if</span> (<span class="string">'responseType'</span> <span class="keyword">in</span> xhr)
			xhr.responseType = self._mode

		<span class="keyword">if</span> (<span class="string">'withCredentials'</span> <span class="keyword">in</span> xhr)
			xhr.withCredentials = !!opts.withCredentials

		<span class="keyword">if</span> (self._mode === <span class="string">'text'</span> &amp;&amp; <span class="string">'overrideMimeType'</span> <span class="keyword">in</span> xhr)
			xhr.overrideMimeType(<span class="string">'text/plain; charset=x-user-defined'</span>)

		<span class="keyword">if</span> (<span class="string">'requestTimeout'</span> <span class="keyword">in</span> opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
				self.emit(<span class="string">'requestTimeout'</span>)
			}
		}

		headersList.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(header)</span> {</span>
			xhr.setRequestHeader(header[<span class="number">0</span>], header[<span class="number">1</span>])
		})

		self._response = <span class="literal">null</span>
		xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
			<span class="keyword">switch</span> (xhr.readyState) {
				<span class="keyword">case</span> rStates.LOADING:
				<span class="keyword">case</span> rStates.DONE:
					self._onXHRProgress()
					<span class="keyword">break</span>
			}
		}
		<span class="comment">// Necessary for streaming in Firefox, since xhr.response is ONLY defined</span>
		<span class="comment">// in onprogress, not in onreadystatechange with xhr.readyState = 3</span>
		<span class="keyword">if</span> (self._mode === <span class="string">'moz-chunked-arraybuffer'</span>) {
			xhr.onprogress = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
				self._onXHRProgress()
			}
		}

		xhr.onerror = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
			<span class="keyword">if</span> (self._destroyed)
				<span class="keyword">return</span>
			self.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">'XHR error'</span>))
		}

		<span class="keyword">try</span> {
			xhr.send(body)
		} <span class="keyword">catch</span> (err) {
			process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
				self.emit(<span class="string">'error'</span>, err)
			})
			<span class="keyword">return</span>
		}
	}
}

<span class="comment">/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">statusValid</span> <span class="params">(xhr)</span> {</span>
	<span class="keyword">try</span> {
		<span class="keyword">var</span> status = xhr.status
		<span class="keyword">return</span> (status !== <span class="literal">null</span> &amp;&amp; status !== <span class="number">0</span>)
	} <span class="keyword">catch</span> (e) {
		<span class="keyword">return</span> <span class="literal">false</span>
	}
}

ClientRequest.prototype._onXHRProgress = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>

	<span class="keyword">if</span> (!statusValid(self._xhr) || self._destroyed)
		<span class="keyword">return</span>

	<span class="keyword">if</span> (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>

	<span class="keyword">if</span> (self._destroyed)
		<span class="keyword">return</span>

	self._response = <span class="keyword">new</span> IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on(<span class="string">'error'</span>, <span class="keyword">function</span>(err) {
		self.emit(<span class="string">'error'</span>, err)
	})

	self.emit(<span class="string">'response'</span>, self._response)
}

ClientRequest.prototype._write = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding, cb)</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>
	self._destroyed = <span class="literal">true</span>
	global.clearTimeout(self._fetchTimer)
	<span class="keyword">if</span> (self._response)
		self._response._destroyed = <span class="literal">true</span>
	<span class="keyword">if</span> (self._xhr)
		self._xhr.abort()
	<span class="keyword">else</span> <span class="keyword">if</span> (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = <span class="function"><span class="keyword">function</span> <span class="params">(data, encoding, cb)</span> {</span>
	<span class="keyword">var</span> self = <span class="keyword">this</span>
	<span class="keyword">if</span> (<span class="keyword">typeof</span> data === <span class="string">'function'</span>) {
		cb = data
		data = <span class="literal">undefined</span>
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}
ClientRequest.prototype.setTimeout = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}
ClientRequest.prototype.setNoDelay = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}
ClientRequest.prototype.setSocketKeepAlive = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}

<span class="comment">// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method</span>
<span class="keyword">var</span> unsafeHeaders = [
	<span class="string">'accept-charset'</span>,
	<span class="string">'accept-encoding'</span>,
	<span class="string">'access-control-request-headers'</span>,
	<span class="string">'access-control-request-method'</span>,
	<span class="string">'connection'</span>,
	<span class="string">'content-length'</span>,
	<span class="string">'cookie'</span>,
	<span class="string">'cookie2'</span>,
	<span class="string">'date'</span>,
	<span class="string">'dnt'</span>,
	<span class="string">'expect'</span>,
	<span class="string">'host'</span>,
	<span class="string">'keep-alive'</span>,
	<span class="string">'origin'</span>,
	<span class="string">'referer'</span>,
	<span class="string">'te'</span>,
	<span class="string">'trailer'</span>,
	<span class="string">'transfer-encoding'</span>,
	<span class="string">'upgrade'</span>,
	<span class="string">'via'</span>
]
</code></pre>