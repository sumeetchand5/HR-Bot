<h1>index.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="keyword">var</span> hash = require(<span class="string">'hash.js'</span>);
<span class="keyword">var</span> curves = require(<span class="string">'../curves'</span>);
<span class="keyword">var</span> utils = require(<span class="string">'../utils'</span>);
<span class="keyword">var</span> assert = utils.assert;
<span class="keyword">var</span> parseBytes = utils.parseBytes;
<span class="keyword">var</span> KeyPair = require(<span class="string">'./key'</span>);
<span class="keyword">var</span> Signature = require(<span class="string">'./signature'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">EDDSA</span><span class="params">(curve)</span> {</span>
  assert(curve === <span class="string">'ed25519'</span>, <span class="string">'only tested with ed25519 so far'</span>);

  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> EDDSA))
    <span class="keyword">return</span> <span class="keyword">new</span> EDDSA(curve);

  <span class="keyword">var</span> curve = curves[curve].curve;
  <span class="keyword">this</span>.curve = curve;
  <span class="keyword">this</span>.g = curve.g;
  <span class="keyword">this</span>.g.precompute(curve.n.bitLength() + <span class="number">1</span>);

  <span class="keyword">this</span>.pointClass = curve.point().constructor;
  <span class="keyword">this</span>.encodingLength = Math.ceil(curve.n.bitLength() / <span class="number">8</span>);
  <span class="keyword">this</span>.hash = hash.sha512;
}

module.exports = EDDSA;

<span class="comment">/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/</span>
EDDSA.prototype.sign = <span class="function"><span class="keyword">function</span> <span class="title">sign</span><span class="params">(message, secret)</span> {</span>
  message = parseBytes(message);
  <span class="keyword">var</span> key = <span class="keyword">this</span>.keyFromSecret(secret);
  <span class="keyword">var</span> r = <span class="keyword">this</span>.hashInt(key.messagePrefix(), message);
  <span class="keyword">var</span> R = <span class="keyword">this</span>.g.mul(r);
  <span class="keyword">var</span> Rencoded = <span class="keyword">this</span>.encodePoint(R);
  <span class="keyword">var</span> s_ = <span class="keyword">this</span>.hashInt(Rencoded, key.pubBytes(), message)
               .mul(key.priv());
  <span class="keyword">var</span> S = r.add(s_).umod(<span class="keyword">this</span>.curve.n);
  <span class="keyword">return</span> <span class="keyword">this</span>.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

<span class="comment">/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/</span>
EDDSA.prototype.verify = <span class="function"><span class="keyword">function</span> <span class="title">verify</span><span class="params">(message, sig, pub)</span> {</span>
  message = parseBytes(message);
  sig = <span class="keyword">this</span>.makeSignature(sig);
  <span class="keyword">var</span> key = <span class="keyword">this</span>.keyFromPublic(pub);
  <span class="keyword">var</span> h = <span class="keyword">this</span>.hashInt(sig.Rencoded(), key.pubBytes(), message);
  <span class="keyword">var</span> SG = <span class="keyword">this</span>.g.mul(sig.S());
  <span class="keyword">var</span> RplusAh = sig.R().add(key.pub().mul(h));
  <span class="keyword">return</span> RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = <span class="function"><span class="keyword">function</span> <span class="title">hashInt</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> hash = <span class="keyword">this</span>.hash();
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arguments.length; i++)
    hash.update(arguments[i]);
  <span class="keyword">return</span> utils.intFromLE(hash.digest()).umod(<span class="keyword">this</span>.curve.n);
};

EDDSA.prototype.keyFromPublic = <span class="function"><span class="keyword">function</span> <span class="title">keyFromPublic</span><span class="params">(pub)</span> {</span>
  <span class="keyword">return</span> KeyPair.fromPublic(<span class="keyword">this</span>, pub);
};

EDDSA.prototype.keyFromSecret = <span class="function"><span class="keyword">function</span> <span class="title">keyFromSecret</span><span class="params">(secret)</span> {</span>
  <span class="keyword">return</span> KeyPair.fromSecret(<span class="keyword">this</span>, secret);
};

EDDSA.prototype.makeSignature = <span class="function"><span class="keyword">function</span> <span class="title">makeSignature</span><span class="params">(sig)</span> {</span>
  <span class="keyword">if</span> (sig <span class="keyword">instanceof</span> Signature)
    <span class="keyword">return</span> sig;
  <span class="keyword">return</span> <span class="keyword">new</span> Signature(<span class="keyword">this</span>, sig);
};

<span class="comment">/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/</span>
EDDSA.prototype.encodePoint = <span class="function"><span class="keyword">function</span> <span class="title">encodePoint</span><span class="params">(point)</span> {</span>
  <span class="keyword">var</span> enc = point.getY().toArray(<span class="string">'le'</span>, <span class="keyword">this</span>.encodingLength);
  enc[<span class="keyword">this</span>.encodingLength - <span class="number">1</span>] |= point.getX().isOdd() ? <span class="number">0x80</span> : <span class="number">0</span>;
  <span class="keyword">return</span> enc;
};

EDDSA.prototype.decodePoint = <span class="function"><span class="keyword">function</span> <span class="title">decodePoint</span><span class="params">(bytes)</span> {</span>
  bytes = utils.parseBytes(bytes);

  <span class="keyword">var</span> lastIx = bytes.length - <span class="number">1</span>;
  <span class="keyword">var</span> normed = bytes.slice(<span class="number">0</span>, lastIx).concat(bytes[lastIx] &amp; ~<span class="number">0x80</span>);
  <span class="keyword">var</span> xIsOdd = (bytes[lastIx] &amp; <span class="number">0x80</span>) !== <span class="number">0</span>;

  <span class="keyword">var</span> y = utils.intFromLE(normed);
  <span class="keyword">return</span> <span class="keyword">this</span>.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = <span class="function"><span class="keyword">function</span> <span class="title">encodeInt</span><span class="params">(num)</span> {</span>
  <span class="keyword">return</span> num.toArray(<span class="string">'le'</span>, <span class="keyword">this</span>.encodingLength);
};

EDDSA.prototype.decodeInt = <span class="function"><span class="keyword">function</span> <span class="title">decodeInt</span><span class="params">(bytes)</span> {</span>
  <span class="keyword">return</span> utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = <span class="function"><span class="keyword">function</span> <span class="title">isPoint</span><span class="params">(val)</span> {</span>
  <span class="keyword">return</span> val <span class="keyword">instanceof</span> <span class="keyword">this</span>.pointClass;
};
</code></pre>