<h1>base.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="keyword">var</span> BN = require(<span class="string">'bn.js'</span>);
<span class="keyword">var</span> utils = require(<span class="string">'../utils'</span>);
<span class="keyword">var</span> getNAF = utils.getNAF;
<span class="keyword">var</span> getJSF = utils.getJSF;
<span class="keyword">var</span> assert = utils.assert;

<span class="function"><span class="keyword">function</span> <span class="title">BaseCurve</span><span class="params">(type, conf)</span> {</span>
  <span class="keyword">this</span>.type = type;
  <span class="keyword">this</span>.p = <span class="keyword">new</span> BN(conf.p, <span class="number">16</span>);

  <span class="comment">// Use Montgomery, when there is no fast reduction for the prime</span>
  <span class="keyword">this</span>.red = conf.prime ? BN.red(conf.prime) : BN.mont(<span class="keyword">this</span>.p);

  <span class="comment">// Useful for many curves</span>
  <span class="keyword">this</span>.zero = <span class="keyword">new</span> BN(<span class="number">0</span>).toRed(<span class="keyword">this</span>.red);
  <span class="keyword">this</span>.one = <span class="keyword">new</span> BN(<span class="number">1</span>).toRed(<span class="keyword">this</span>.red);
  <span class="keyword">this</span>.two = <span class="keyword">new</span> BN(<span class="number">2</span>).toRed(<span class="keyword">this</span>.red);

  <span class="comment">// Curve configuration, optional</span>
  <span class="keyword">this</span>.n = conf.n &amp;&amp; <span class="keyword">new</span> BN(conf.n, <span class="number">16</span>);
  <span class="keyword">this</span>.g = conf.g &amp;&amp; <span class="keyword">this</span>.pointFromJSON(conf.g, conf.gRed);

  <span class="comment">// Temporary arrays</span>
  <span class="keyword">this</span>._wnafT1 = <span class="keyword">new</span> Array(<span class="number">4</span>);
  <span class="keyword">this</span>._wnafT2 = <span class="keyword">new</span> Array(<span class="number">4</span>);
  <span class="keyword">this</span>._wnafT3 = <span class="keyword">new</span> Array(<span class="number">4</span>);
  <span class="keyword">this</span>._wnafT4 = <span class="keyword">new</span> Array(<span class="number">4</span>);

  <span class="comment">// Generalized Greg Maxwell's trick</span>
  <span class="keyword">var</span> adjustCount = <span class="keyword">this</span>.n &amp;&amp; <span class="keyword">this</span>.p.div(<span class="keyword">this</span>.n);
  <span class="keyword">if</span> (!adjustCount || adjustCount.cmpn(<span class="number">100</span>) > <span class="number">0</span>) {
    <span class="keyword">this</span>.redN = <span class="literal">null</span>;
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>._maxwellTrick = <span class="literal">true</span>;
    <span class="keyword">this</span>.redN = <span class="keyword">this</span>.n.toRed(<span class="keyword">this</span>.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = <span class="function"><span class="keyword">function</span> <span class="title">point</span><span class="params">()</span> {</span>
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Not implemented'</span>);
};

BaseCurve.prototype.validate = <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">()</span> {</span>
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Not implemented'</span>);
};

BaseCurve.prototype._fixedNafMul = <span class="function"><span class="keyword">function</span> <span class="title">_fixedNafMul</span><span class="params">(p, k)</span> {</span>
  assert(p.precomputed);
  <span class="keyword">var</span> doubles = p._getDoubles();

  <span class="keyword">var</span> naf = getNAF(k, <span class="number">1</span>);
  <span class="keyword">var</span> I = (<span class="number">1</span> &lt;&lt; (doubles.step + <span class="number">1</span>)) - (doubles.step % <span class="number">2</span> === <span class="number">0</span> ? <span class="number">2</span> : <span class="number">1</span>);
  I /= <span class="number">3</span>;

  <span class="comment">// Translate into more windowed form</span>
  <span class="keyword">var</span> repr = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; naf.length; j += doubles.step) {
    <span class="keyword">var</span> nafW = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> k = j + doubles.step - <span class="number">1</span>; k >= j; k--)
      nafW = (nafW &lt;&lt; <span class="number">1</span>) + naf[k];
    repr.push(nafW);
  }

  <span class="keyword">var</span> a = <span class="keyword">this</span>.jpoint(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);
  <span class="keyword">var</span> b = <span class="keyword">this</span>.jpoint(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);
  <span class="keyword">for</span> (<span class="keyword">var</span> i = I; i > <span class="number">0</span>; i--) {
    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; repr.length; j++) {
      <span class="keyword">var</span> nafW = repr[j];
      <span class="keyword">if</span> (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      <span class="keyword">else</span> <span class="keyword">if</span> (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  <span class="keyword">return</span> a.toP();
};

BaseCurve.prototype._wnafMul = <span class="function"><span class="keyword">function</span> <span class="title">_wnafMul</span><span class="params">(p, k)</span> {</span>
  <span class="keyword">var</span> w = <span class="number">4</span>;

  <span class="comment">// Precompute window</span>
  <span class="keyword">var</span> nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  <span class="keyword">var</span> wnd = nafPoints.points;

  <span class="comment">// Get NAF form</span>
  <span class="keyword">var</span> naf = getNAF(k, w);

  <span class="comment">// Add `this`*(N+1) for every w-NAF index</span>
  <span class="keyword">var</span> acc = <span class="keyword">this</span>.jpoint(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);
  <span class="keyword">for</span> (<span class="keyword">var</span> i = naf.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
    <span class="comment">// Count zeroes</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; i >= <span class="number">0</span> &amp;&amp; naf[i] === <span class="number">0</span>; i--)
      k++;
    <span class="keyword">if</span> (i >= <span class="number">0</span>)
      k++;
    acc = acc.dblp(k);

    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)
      <span class="keyword">break</span>;
    <span class="keyword">var</span> z = naf[i];
    assert(z !== <span class="number">0</span>);
    <span class="keyword">if</span> (p.type === <span class="string">'affine'</span>) {
      <span class="comment">// J +- P</span>
      <span class="keyword">if</span> (z > <span class="number">0</span>)
        acc = acc.mixedAdd(wnd[(z - <span class="number">1</span>) >> <span class="number">1</span>]);
      <span class="keyword">else</span>
        acc = acc.mixedAdd(wnd[(-z - <span class="number">1</span>) >> <span class="number">1</span>].neg());
    } <span class="keyword">else</span> {
      <span class="comment">// J +- J</span>
      <span class="keyword">if</span> (z > <span class="number">0</span>)
        acc = acc.add(wnd[(z - <span class="number">1</span>) >> <span class="number">1</span>]);
      <span class="keyword">else</span>
        acc = acc.add(wnd[(-z - <span class="number">1</span>) >> <span class="number">1</span>].neg());
    }
  }
  <span class="keyword">return</span> p.type === <span class="string">'affine'</span> ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = <span class="function"><span class="keyword">function</span> <span class="title">_wnafMulAdd</span><span class="params">(defW,
                                                       points,
                                                       coeffs,
                                                       len,
                                                       jacobianResult)</span> {</span>
  <span class="keyword">var</span> wndWidth = <span class="keyword">this</span>._wnafT1;
  <span class="keyword">var</span> wnd = <span class="keyword">this</span>._wnafT2;
  <span class="keyword">var</span> naf = <span class="keyword">this</span>._wnafT3;

  <span class="comment">// Fill all arrays</span>
  <span class="keyword">var</span> max = <span class="number">0</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
    <span class="keyword">var</span> p = points[i];
    <span class="keyword">var</span> nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  <span class="comment">// Comb small window NAFs</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = len - <span class="number">1</span>; i >= <span class="number">1</span>; i -= <span class="number">2</span>) {
    <span class="keyword">var</span> a = i - <span class="number">1</span>;
    <span class="keyword">var</span> b = i;
    <span class="keyword">if</span> (wndWidth[a] !== <span class="number">1</span> || wndWidth[b] !== <span class="number">1</span>) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      <span class="keyword">continue</span>;
    }

    <span class="keyword">var</span> comb = [
      points[a], <span class="comment">/* 1 */</span>
      <span class="literal">null</span>, <span class="comment">/* 3 */</span>
      <span class="literal">null</span>, <span class="comment">/* 5 */</span>
      points[b] <span class="comment">/* 7 */</span>
    ];

    <span class="comment">// Try to avoid Projective points, if possible</span>
    <span class="keyword">if</span> (points[a].y.cmp(points[b].y) === <span class="number">0</span>) {
      comb[<span class="number">1</span>] = points[a].add(points[b]);
      comb[<span class="number">2</span>] = points[a].toJ().mixedAdd(points[b].neg());
    } <span class="keyword">else</span> <span class="keyword">if</span> (points[a].y.cmp(points[b].y.redNeg()) === <span class="number">0</span>) {
      comb[<span class="number">1</span>] = points[a].toJ().mixedAdd(points[b]);
      comb[<span class="number">2</span>] = points[a].add(points[b].neg());
    } <span class="keyword">else</span> {
      comb[<span class="number">1</span>] = points[a].toJ().mixedAdd(points[b]);
      comb[<span class="number">2</span>] = points[a].toJ().mixedAdd(points[b].neg());
    }

    <span class="keyword">var</span> index = [
      -<span class="number">3</span>, <span class="comment">/* -1 -1 */</span>
      -<span class="number">1</span>, <span class="comment">/* -1 0 */</span>
      -<span class="number">5</span>, <span class="comment">/* -1 1 */</span>
      -<span class="number">7</span>, <span class="comment">/* 0 -1 */</span>
      <span class="number">0</span>, <span class="comment">/* 0 0 */</span>
      <span class="number">7</span>, <span class="comment">/* 0 1 */</span>
      <span class="number">5</span>, <span class="comment">/* 1 -1 */</span>
      <span class="number">1</span>, <span class="comment">/* 1 0 */</span>
      <span class="number">3</span>  <span class="comment">/* 1 1 */</span>
    ];

    <span class="keyword">var</span> jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[<span class="number">0</span>].length, max);
    naf[a] = <span class="keyword">new</span> Array(max);
    naf[b] = <span class="keyword">new</span> Array(max);
    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; max; j++) {
      <span class="keyword">var</span> ja = jsf[<span class="number">0</span>][j] | <span class="number">0</span>;
      <span class="keyword">var</span> jb = jsf[<span class="number">1</span>][j] | <span class="number">0</span>;

      naf[a][j] = index[(ja + <span class="number">1</span>) * <span class="number">3</span> + (jb + <span class="number">1</span>)];
      naf[b][j] = <span class="number">0</span>;
      wnd[a] = comb;
    }
  }

  <span class="keyword">var</span> acc = <span class="keyword">this</span>.jpoint(<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);
  <span class="keyword">var</span> tmp = <span class="keyword">this</span>._wnafT4;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = max; i >= <span class="number">0</span>; i--) {
    <span class="keyword">var</span> k = <span class="number">0</span>;

    <span class="keyword">while</span> (i >= <span class="number">0</span>) {
      <span class="keyword">var</span> zero = <span class="literal">true</span>;
      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) {
        tmp[j] = naf[j][i] | <span class="number">0</span>;
        <span class="keyword">if</span> (tmp[j] !== <span class="number">0</span>)
          zero = <span class="literal">false</span>;
      }
      <span class="keyword">if</span> (!zero)
        <span class="keyword">break</span>;
      k++;
      i--;
    }
    <span class="keyword">if</span> (i >= <span class="number">0</span>)
      k++;
    acc = acc.dblp(k);
    <span class="keyword">if</span> (i &lt; <span class="number">0</span>)
      <span class="keyword">break</span>;

    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) {
      <span class="keyword">var</span> z = tmp[j];
      <span class="keyword">var</span> p;
      <span class="keyword">if</span> (z === <span class="number">0</span>)
        <span class="keyword">continue</span>;
      <span class="keyword">else</span> <span class="keyword">if</span> (z > <span class="number">0</span>)
        p = wnd[j][(z - <span class="number">1</span>) >> <span class="number">1</span>];
      <span class="keyword">else</span> <span class="keyword">if</span> (z &lt; <span class="number">0</span>)
        p = wnd[j][(-z - <span class="number">1</span>) >> <span class="number">1</span>].neg();

      <span class="keyword">if</span> (p.type === <span class="string">'affine'</span>)
        acc = acc.mixedAdd(p);
      <span class="keyword">else</span>
        acc = acc.add(p);
    }
  }
  <span class="comment">// Zeroify references</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)
    wnd[i] = <span class="literal">null</span>;

  <span class="keyword">if</span> (jacobianResult)
    <span class="keyword">return</span> acc;
  <span class="keyword">else</span>
    <span class="keyword">return</span> acc.toP();
};

<span class="function"><span class="keyword">function</span> <span class="title">BasePoint</span><span class="params">(curve, type)</span> {</span>
  <span class="keyword">this</span>.curve = curve;
  <span class="keyword">this</span>.type = type;
  <span class="keyword">this</span>.precomputed = <span class="literal">null</span>;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = <span class="function"><span class="keyword">function</span> <span class="title">eq</span><span class="params">(<span class="comment">/*other*/</span>)</span> {</span>
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Not implemented'</span>);
};

BasePoint.prototype.validate = <span class="function"><span class="keyword">function</span> <span class="title">validate</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.curve.validate(<span class="keyword">this</span>);
};

BaseCurve.prototype.decodePoint = <span class="function"><span class="keyword">function</span> <span class="title">decodePoint</span><span class="params">(bytes, enc)</span> {</span>
  bytes = utils.toArray(bytes, enc);

  <span class="keyword">var</span> len = <span class="keyword">this</span>.p.byteLength();

  <span class="comment">// uncompressed, hybrid-odd, hybrid-even</span>
  <span class="keyword">if</span> ((bytes[<span class="number">0</span>] === <span class="number">0x04</span> || bytes[<span class="number">0</span>] === <span class="number">0x06</span> || bytes[<span class="number">0</span>] === <span class="number">0x07</span>) &amp;&amp;
      bytes.length - <span class="number">1</span> === <span class="number">2</span> * len) {
    <span class="keyword">if</span> (bytes[<span class="number">0</span>] === <span class="number">0x06</span>)
      assert(bytes[bytes.length - <span class="number">1</span>] % <span class="number">2</span> === <span class="number">0</span>);
    <span class="keyword">else</span> <span class="keyword">if</span> (bytes[<span class="number">0</span>] === <span class="number">0x07</span>)
      assert(bytes[bytes.length - <span class="number">1</span>] % <span class="number">2</span> === <span class="number">1</span>);

    <span class="keyword">var</span> res =  <span class="keyword">this</span>.point(bytes.slice(<span class="number">1</span>, <span class="number">1</span> + len),
                          bytes.slice(<span class="number">1</span> + len, <span class="number">1</span> + <span class="number">2</span> * len));

    <span class="keyword">return</span> res;
  } <span class="keyword">else</span> <span class="keyword">if</span> ((bytes[<span class="number">0</span>] === <span class="number">0x02</span> || bytes[<span class="number">0</span>] === <span class="number">0x03</span>) &amp;&amp;
              bytes.length - <span class="number">1</span> === len) {
    <span class="keyword">return</span> <span class="keyword">this</span>.pointFromX(bytes.slice(<span class="number">1</span>, <span class="number">1</span> + len), bytes[<span class="number">0</span>] === <span class="number">0x03</span>);
  }
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Unknown point format'</span>);
};

BasePoint.prototype.encodeCompressed = <span class="function"><span class="keyword">function</span> <span class="title">encodeCompressed</span><span class="params">(enc)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.encode(enc, <span class="literal">true</span>);
};

BasePoint.prototype._encode = <span class="function"><span class="keyword">function</span> <span class="title">_encode</span><span class="params">(compact)</span> {</span>
  <span class="keyword">var</span> len = <span class="keyword">this</span>.curve.p.byteLength();
  <span class="keyword">var</span> x = <span class="keyword">this</span>.getX().toArray(<span class="string">'be'</span>, len);

  <span class="keyword">if</span> (compact)
    <span class="keyword">return</span> [ <span class="keyword">this</span>.getY().isEven() ? <span class="number">0x02</span> : <span class="number">0x03</span> ].concat(x);

  <span class="keyword">return</span> [ <span class="number">0x04</span> ].concat(x, <span class="keyword">this</span>.getY().toArray(<span class="string">'be'</span>, len)) ;
};

BasePoint.prototype.encode = <span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">(enc, compact)</span> {</span>
  <span class="keyword">return</span> utils.encode(<span class="keyword">this</span>._encode(compact), enc);
};

BasePoint.prototype.precompute = <span class="function"><span class="keyword">function</span> <span class="title">precompute</span><span class="params">(power)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.precomputed)
    <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="keyword">var</span> precomputed = {
    doubles: <span class="literal">null</span>,
    naf: <span class="literal">null</span>,
    beta: <span class="literal">null</span>
  };
  precomputed.naf = <span class="keyword">this</span>._getNAFPoints(<span class="number">8</span>);
  precomputed.doubles = <span class="keyword">this</span>._getDoubles(<span class="number">4</span>, power);
  precomputed.beta = <span class="keyword">this</span>._getBeta();
  <span class="keyword">this</span>.precomputed = precomputed;

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

BasePoint.prototype._hasDoubles = <span class="function"><span class="keyword">function</span> <span class="title">_hasDoubles</span><span class="params">(k)</span> {</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.precomputed)
    <span class="keyword">return</span> <span class="literal">false</span>;

  <span class="keyword">var</span> doubles = <span class="keyword">this</span>.precomputed.doubles;
  <span class="keyword">if</span> (!doubles)
    <span class="keyword">return</span> <span class="literal">false</span>;

  <span class="keyword">return</span> doubles.points.length >= Math.ceil((k.bitLength() + <span class="number">1</span>) / doubles.step);
};

BasePoint.prototype._getDoubles = <span class="function"><span class="keyword">function</span> <span class="title">_getDoubles</span><span class="params">(step, power)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.precomputed &amp;&amp; <span class="keyword">this</span>.precomputed.doubles)
    <span class="keyword">return</span> <span class="keyword">this</span>.precomputed.doubles;

  <span class="keyword">var</span> doubles = [ <span class="keyword">this</span> ];
  <span class="keyword">var</span> acc = <span class="keyword">this</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; power; i += step) {
    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  <span class="keyword">return</span> {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = <span class="function"><span class="keyword">function</span> <span class="title">_getNAFPoints</span><span class="params">(wnd)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.precomputed &amp;&amp; <span class="keyword">this</span>.precomputed.naf)
    <span class="keyword">return</span> <span class="keyword">this</span>.precomputed.naf;

  <span class="keyword">var</span> res = [ <span class="keyword">this</span> ];
  <span class="keyword">var</span> max = (<span class="number">1</span> &lt;&lt; wnd) - <span class="number">1</span>;
  <span class="keyword">var</span> dbl = max === <span class="number">1</span> ? <span class="literal">null</span> : <span class="keyword">this</span>.dbl();
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; max; i++)
    res[i] = res[i - <span class="number">1</span>].add(dbl);
  <span class="keyword">return</span> {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = <span class="function"><span class="keyword">function</span> <span class="title">_getBeta</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="literal">null</span>;
};

BasePoint.prototype.dblp = <span class="function"><span class="keyword">function</span> <span class="title">dblp</span><span class="params">(k)</span> {</span>
  <span class="keyword">var</span> r = <span class="keyword">this</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; k; i++)
    r = r.dbl();
  <span class="keyword">return</span> r;
};
</code></pre>