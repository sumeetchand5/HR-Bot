<h1>inflight.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> wrappy = require(<span class="string">'wrappy'</span>)
<span class="keyword">var</span> reqs = Object.create(<span class="literal">null</span>)
<span class="keyword">var</span> once = require(<span class="string">'once'</span>)

module.exports = wrappy(inflight)

<span class="function"><span class="keyword">function</span> <span class="title">inflight</span> <span class="params">(key, cb)</span> {</span>
  <span class="keyword">if</span> (reqs[key]) {
    reqs[key].push(cb)
    <span class="keyword">return</span> <span class="literal">null</span>
  } <span class="keyword">else</span> {
    reqs[key] = [cb]
    <span class="keyword">return</span> makeres(key)
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">makeres</span> <span class="params">(key)</span> {</span>
  <span class="keyword">return</span> once(<span class="function"><span class="keyword">function</span> <span class="title">RES</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> cbs = reqs[key]
    <span class="keyword">var</span> len = cbs.length
    <span class="keyword">var</span> args = slice(arguments)

    <span class="comment">// XXX It's somewhat ambiguous whether a new callback added in this</span>
    <span class="comment">// pass should be queued for later execution if something in the</span>
    <span class="comment">// list of callbacks throws, or if it should just be discarded.</span>
    <span class="comment">// However, it's such an edge case that it hardly matters, and either</span>
    <span class="comment">// choice is likely as surprising as the other.</span>
    <span class="comment">// As it happens, we do go ahead and schedule it for later execution.</span>
    <span class="keyword">try</span> {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
        cbs[i].apply(<span class="literal">null</span>, args)
      }
    } <span class="keyword">finally</span> {
      <span class="keyword">if</span> (cbs.length > len) {
        <span class="comment">// added more in the interim.</span>
        <span class="comment">// de-zalgo, just in case, but don't call again.</span>
        cbs.splice(<span class="number">0</span>, len)
        process.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
          RES.apply(<span class="literal">null</span>, args)
        })
      } <span class="keyword">else</span> {
        <span class="keyword">delete</span> reqs[key]
      }
    }
  })
}

<span class="function"><span class="keyword">function</span> <span class="title">slice</span> <span class="params">(args)</span> {</span>
  <span class="keyword">var</span> length = args.length
  <span class="keyword">var</span> array = []

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) array[i] = args[i]
  <span class="keyword">return</span> array
}
</code></pre>