<h1>old.js</h1>
<pre><code class="lang-js"><span class="comment">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="comment">//</span>
<span class="comment">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="comment">// copy of this software and associated documentation files (the</span>
<span class="comment">// "Software"), to deal in the Software without restriction, including</span>
<span class="comment">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="comment">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="comment">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="comment">// following conditions:</span>
<span class="comment">//</span>
<span class="comment">// The above copyright notice and this permission notice shall be included</span>
<span class="comment">// in all copies or substantial portions of the Software.</span>
<span class="comment">//</span>
<span class="comment">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="comment">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="comment">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="comment">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="comment">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="comment">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="comment">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="keyword">var</span> pathModule = require(<span class="string">'path'</span>);
<span class="keyword">var</span> isWindows = process.platform === <span class="string">'win32'</span>;
<span class="keyword">var</span> fs = require(<span class="string">'fs'</span>);

<span class="comment">// JavaScript implementation of realpath, ported from node pre-v6</span>

<span class="keyword">var</span> DEBUG = process.env.NODE_DEBUG &amp;&amp; <span class="regexp">/fs/</span>.test(process.env.NODE_DEBUG);

<span class="function"><span class="keyword">function</span> <span class="title">rethrow</span><span class="params">()</span> {</span>
  <span class="comment">// Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and</span>
  <span class="comment">// is fairly slow to generate.</span>
  <span class="keyword">var</span> callback;
  <span class="keyword">if</span> (DEBUG) {
    <span class="keyword">var</span> backtrace = <span class="keyword">new</span> Error;
    callback = debugCallback;
  } <span class="keyword">else</span>
    callback = missingCallback;

  <span class="keyword">return</span> callback;

  <span class="function"><span class="keyword">function</span> <span class="title">debugCallback</span><span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  <span class="function"><span class="keyword">function</span> <span class="title">missingCallback</span><span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="keyword">if</span> (process.throwDeprecation)
        <span class="keyword">throw</span> err;  <span class="comment">// Forgot a callback but don't know where? Use NODE_DEBUG=fs</span>
      <span class="keyword">else</span> <span class="keyword">if</span> (!process.noDeprecation) {
        <span class="keyword">var</span> msg = <span class="string">'fs: missing callback '</span> + (err.stack || err.message);
        <span class="keyword">if</span> (process.traceDeprecation)
          console.trace(msg);
        <span class="keyword">else</span>
          console.error(msg);
      }
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">maybeCallback</span><span class="params">(cb)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">typeof</span> cb === <span class="string">'function'</span> ? cb : rethrow();
}

<span class="keyword">var</span> normalize = pathModule.normalize;

<span class="comment">// Regexp that finds the next partion of a (partial) path</span>
<span class="comment">// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']</span>
<span class="keyword">if</span> (isWindows) {
  <span class="keyword">var</span> nextPartRe = <span class="regexp">/(.*?)(?:[\/\\]+|$)/g</span>;
} <span class="keyword">else</span> {
  <span class="keyword">var</span> nextPartRe = <span class="regexp">/(.*?)(?:[\/]+|$)/g</span>;
}

<span class="comment">// Regex to find the device root, including trailing slash. E.g. 'c:\\'.</span>
<span class="keyword">if</span> (isWindows) {
  <span class="keyword">var</span> splitRootRe = <span class="regexp">/^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/</span>;
} <span class="keyword">else</span> {
  <span class="keyword">var</span> splitRootRe = <span class="regexp">/^[\/]*/</span>;
}

exports.realpathSync = <span class="function"><span class="keyword">function</span> <span class="title">realpathSync</span><span class="params">(p, cache)</span> {</span>
  <span class="comment">// make p is absolute</span>
  p = pathModule.resolve(p);

  <span class="keyword">if</span> (cache &amp;&amp; Object.prototype.hasOwnProperty.call(cache, p)) {
    <span class="keyword">return</span> cache[p];
  }

  <span class="keyword">var</span> original = p,
      seenLinks = {},
      knownHard = {};

  <span class="comment">// current character position in p</span>
  <span class="keyword">var</span> pos;
  <span class="comment">// the partial path so far, including a trailing slash if any</span>
  <span class="keyword">var</span> current;
  <span class="comment">// the partial path without a trailing slash (except when pointing at a root)</span>
  <span class="keyword">var</span> base;
  <span class="comment">// the partial path scanned in the previous round, with slash</span>
  <span class="keyword">var</span> previous;

  start();

  <span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> {</span>
    <span class="comment">// Skip over roots</span>
    <span class="keyword">var</span> m = splitRootRe.exec(p);
    pos = m[<span class="number">0</span>].length;
    current = m[<span class="number">0</span>];
    base = m[<span class="number">0</span>];
    previous = <span class="string">''</span>;

    <span class="comment">// On windows, check that the root exists. On unix there is no need.</span>
    <span class="keyword">if</span> (isWindows &amp;&amp; !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = <span class="literal">true</span>;
    }
  }

  <span class="comment">// walk down the path, swapping out linked pathparts for their real</span>
  <span class="comment">// values</span>
  <span class="comment">// NB: p.length changes.</span>
  <span class="keyword">while</span> (pos &lt; p.length) {
    <span class="comment">// find the next part</span>
    nextPartRe.lastIndex = pos;
    <span class="keyword">var</span> result = nextPartRe.exec(p);
    previous = current;
    current += result[<span class="number">0</span>];
    base = previous + result[<span class="number">1</span>];
    pos = nextPartRe.lastIndex;

    <span class="comment">// continue if not a symlink</span>
    <span class="keyword">if</span> (knownHard[base] || (cache &amp;&amp; cache[base] === base)) {
      <span class="keyword">continue</span>;
    }

    <span class="keyword">var</span> resolvedLink;
    <span class="keyword">if</span> (cache &amp;&amp; Object.prototype.hasOwnProperty.call(cache, base)) {
      <span class="comment">// some known symbolic link.  no need to stat again.</span>
      resolvedLink = cache[base];
    } <span class="keyword">else</span> {
      <span class="keyword">var</span> stat = fs.lstatSync(base);
      <span class="keyword">if</span> (!stat.isSymbolicLink()) {
        knownHard[base] = <span class="literal">true</span>;
        <span class="keyword">if</span> (cache) cache[base] = base;
        <span class="keyword">continue</span>;
      }

      <span class="comment">// read the link if it wasn't read before</span>
      <span class="comment">// dev/ino always return 0 on windows, so skip the check.</span>
      <span class="keyword">var</span> linkTarget = <span class="literal">null</span>;
      <span class="keyword">if</span> (!isWindows) {
        <span class="keyword">var</span> id = stat.dev.toString(<span class="number">32</span>) + <span class="string">':'</span> + stat.ino.toString(<span class="number">32</span>);
        <span class="keyword">if</span> (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      <span class="keyword">if</span> (linkTarget === <span class="literal">null</span>) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      <span class="comment">// track this, if given a cache.</span>
      <span class="keyword">if</span> (cache) cache[base] = resolvedLink;
      <span class="keyword">if</span> (!isWindows) seenLinks[id] = linkTarget;
    }

    <span class="comment">// resolve the link, then start over</span>
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  <span class="keyword">if</span> (cache) cache[original] = p;

  <span class="keyword">return</span> p;
};


exports.realpath = <span class="function"><span class="keyword">function</span> <span class="title">realpath</span><span class="params">(p, cache, cb)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> cb !== <span class="string">'function'</span>) {
    cb = maybeCallback(cache);
    cache = <span class="literal">null</span>;
  }

  <span class="comment">// make p is absolute</span>
  p = pathModule.resolve(p);

  <span class="keyword">if</span> (cache &amp;&amp; Object.prototype.hasOwnProperty.call(cache, p)) {
    <span class="keyword">return</span> process.nextTick(cb.bind(<span class="literal">null</span>, <span class="literal">null</span>, cache[p]));
  }

  <span class="keyword">var</span> original = p,
      seenLinks = {},
      knownHard = {};

  <span class="comment">// current character position in p</span>
  <span class="keyword">var</span> pos;
  <span class="comment">// the partial path so far, including a trailing slash if any</span>
  <span class="keyword">var</span> current;
  <span class="comment">// the partial path without a trailing slash (except when pointing at a root)</span>
  <span class="keyword">var</span> base;
  <span class="comment">// the partial path scanned in the previous round, with slash</span>
  <span class="keyword">var</span> previous;

  start();

  <span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">()</span> {</span>
    <span class="comment">// Skip over roots</span>
    <span class="keyword">var</span> m = splitRootRe.exec(p);
    pos = m[<span class="number">0</span>].length;
    current = m[<span class="number">0</span>];
    base = m[<span class="number">0</span>];
    previous = <span class="string">''</span>;

    <span class="comment">// On windows, check that the root exists. On unix there is no need.</span>
    <span class="keyword">if</span> (isWindows &amp;&amp; !knownHard[base]) {
      fs.lstat(base, <span class="keyword">function</span>(err) {
        <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);
        knownHard[base] = <span class="literal">true</span>;
        LOOP();
      });
    } <span class="keyword">else</span> {
      process.nextTick(LOOP);
    }
  }

  <span class="comment">// walk down the path, swapping out linked pathparts for their real</span>
  <span class="comment">// values</span>
  <span class="function"><span class="keyword">function</span> <span class="title">LOOP</span><span class="params">()</span> {</span>
    <span class="comment">// stop if scanned past end of path</span>
    <span class="keyword">if</span> (pos >= p.length) {
      <span class="keyword">if</span> (cache) cache[original] = p;
      <span class="keyword">return</span> cb(<span class="literal">null</span>, p);
    }

    <span class="comment">// find the next part</span>
    nextPartRe.lastIndex = pos;
    <span class="keyword">var</span> result = nextPartRe.exec(p);
    previous = current;
    current += result[<span class="number">0</span>];
    base = previous + result[<span class="number">1</span>];
    pos = nextPartRe.lastIndex;

    <span class="comment">// continue if not a symlink</span>
    <span class="keyword">if</span> (knownHard[base] || (cache &amp;&amp; cache[base] === base)) {
      <span class="keyword">return</span> process.nextTick(LOOP);
    }

    <span class="keyword">if</span> (cache &amp;&amp; Object.prototype.hasOwnProperty.call(cache, base)) {
      <span class="comment">// known symbolic link.  no need to stat again.</span>
      <span class="keyword">return</span> gotResolvedLink(cache[base]);
    }

    <span class="keyword">return</span> fs.lstat(base, gotStat);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">gotStat</span><span class="params">(err, stat)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);

    <span class="comment">// if not a symlink, skip to the next path part</span>
    <span class="keyword">if</span> (!stat.isSymbolicLink()) {
      knownHard[base] = <span class="literal">true</span>;
      <span class="keyword">if</span> (cache) cache[base] = base;
      <span class="keyword">return</span> process.nextTick(LOOP);
    }

    <span class="comment">// stat &amp; read the link if not read before</span>
    <span class="comment">// call gotTarget as soon as the link target is known</span>
    <span class="comment">// dev/ino always return 0 on windows, so skip the check.</span>
    <span class="keyword">if</span> (!isWindows) {
      <span class="keyword">var</span> id = stat.dev.toString(<span class="number">32</span>) + <span class="string">':'</span> + stat.ino.toString(<span class="number">32</span>);
      <span class="keyword">if</span> (seenLinks.hasOwnProperty(id)) {
        <span class="keyword">return</span> gotTarget(<span class="literal">null</span>, seenLinks[id], base);
      }
    }
    fs.stat(base, <span class="keyword">function</span>(err) {
      <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);

      fs.readlink(base, <span class="keyword">function</span>(err, target) {
        <span class="keyword">if</span> (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  <span class="function"><span class="keyword">function</span> <span class="title">gotTarget</span><span class="params">(err, target, base)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> cb(err);

    <span class="keyword">var</span> resolvedLink = pathModule.resolve(previous, target);
    <span class="keyword">if</span> (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">gotResolvedLink</span><span class="params">(resolvedLink)</span> {</span>
    <span class="comment">// resolve the link, then start over</span>
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};
</code></pre>