<h1>base64-vlq.js</h1>
<pre><code class="lang-js"><span class="comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
<span class="comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span>

<span class="keyword">var</span> base64 = require(<span class="string">'./base64'</span>);

<span class="comment">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span>
<span class="comment">// length quantities we use in the source map spec, the first bit is the sign,</span>
<span class="comment">// the next four bits are the actual value, and the 6th bit is the</span>
<span class="comment">// continuation bit. The continuation bit tells us whether there are more</span>
<span class="comment">// digits in this value following this digit.</span>
<span class="comment">//</span>
<span class="comment">//   Continuation</span>
<span class="comment">//   |    Sign</span>
<span class="comment">//   |    |</span>
<span class="comment">//   V    V</span>
<span class="comment">//   101011</span>

<span class="keyword">var</span> VLQ_BASE_SHIFT = <span class="number">5</span>;

<span class="comment">// binary: 100000</span>
<span class="keyword">var</span> VLQ_BASE = <span class="number">1</span> &lt;&lt; VLQ_BASE_SHIFT;

<span class="comment">// binary: 011111</span>
<span class="keyword">var</span> VLQ_BASE_MASK = VLQ_BASE - <span class="number">1</span>;

<span class="comment">// binary: 100000</span>
<span class="keyword">var</span> VLQ_CONTINUATION_BIT = VLQ_BASE;

<span class="comment">/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">toVLQSigned</span><span class="params">(aValue)</span> {</span>
  <span class="keyword">return</span> aValue &lt; <span class="number">0</span>
    ? ((-aValue) &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>
    : (aValue &lt;&lt; <span class="number">1</span>) + <span class="number">0</span>;
}

<span class="comment">/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">fromVLQSigned</span><span class="params">(aValue)</span> {</span>
  <span class="keyword">var</span> isNegative = (aValue &amp; <span class="number">1</span>) === <span class="number">1</span>;
  <span class="keyword">var</span> shifted = aValue >> <span class="number">1</span>;
  <span class="keyword">return</span> isNegative
    ? -shifted
    : shifted;
}

<span class="comment">/**
 * Returns the base 64 VLQ encoded value.
 */</span>
exports.encode = <span class="function"><span class="keyword">function</span> <span class="title">base64VLQ_encode</span><span class="params">(aValue)</span> {</span>
  <span class="keyword">var</span> encoded = <span class="string">""</span>;
  <span class="keyword">var</span> digit;

  <span class="keyword">var</span> vlq = toVLQSigned(aValue);

  <span class="keyword">do</span> {
    digit = vlq &amp; VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    <span class="keyword">if</span> (vlq > <span class="number">0</span>) {
      <span class="comment">// There are still more digits in this value, so we must make sure the</span>
      <span class="comment">// continuation bit is marked.</span>
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } <span class="keyword">while</span> (vlq > <span class="number">0</span>);

  <span class="keyword">return</span> encoded;
};

<span class="comment">/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */</span>
exports.decode = <span class="function"><span class="keyword">function</span> <span class="title">base64VLQ_decode</span><span class="params">(aStr, aIndex, aOutParam)</span> {</span>
  <span class="keyword">var</span> strLen = aStr.length;
  <span class="keyword">var</span> result = <span class="number">0</span>;
  <span class="keyword">var</span> shift = <span class="number">0</span>;
  <span class="keyword">var</span> continuation, digit;

  <span class="keyword">do</span> {
    <span class="keyword">if</span> (aIndex >= strLen) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Expected more digits in base 64 VLQ value."</span>);
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    <span class="keyword">if</span> (digit === -<span class="number">1</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Invalid base64 digit: "</span> + aStr.charAt(aIndex - <span class="number">1</span>));
    }

    continuation = !!(digit &amp; VLQ_CONTINUATION_BIT);
    digit &amp;= VLQ_BASE_MASK;
    result = result + (digit &lt;&lt; shift);
    shift += VLQ_BASE_SHIFT;
  } <span class="keyword">while</span> (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
</code></pre>