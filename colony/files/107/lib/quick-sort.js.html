<h1>quick-sort.js</h1>
<pre><code class="lang-js"><span class="comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
<span class="comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span>

<span class="comment">// It turns out that some (most?) JavaScript engines don't self-host</span>
<span class="comment">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span>
<span class="comment">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span>
<span class="comment">// custom comparator function, calling back and forth between the VM's C++ and</span>
<span class="comment">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span>
<span class="comment">// worse generated code for the comparator function than would be optimal. In</span>
<span class="comment">// fact, when sorting with a comparator, these costs outweigh the benefits of</span>
<span class="comment">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span>
<span class="comment">// a ~3500ms mean speed-up in `bench/bench.html`.</span>

<span class="comment">/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">swap</span><span class="params">(ary, x, y)</span> {</span>
  <span class="keyword">var</span> temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

<span class="comment">/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">randomIntInRange</span><span class="params">(low, high)</span> {</span>
  <span class="keyword">return</span> Math.round(low + (Math.random() * (high - low)));
}

<span class="comment">/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">doQuickSort</span><span class="params">(ary, comparator, p, r)</span> {</span>
  <span class="comment">// If our lower bound is less than our upper bound, we (1) partition the</span>
  <span class="comment">// array into two pieces and (2) recurse on each half. If it is not, this is</span>
  <span class="comment">// the empty array and our base case.</span>

  <span class="keyword">if</span> (p &lt; r) {
    <span class="comment">// (1) Partitioning.</span>
    <span class="comment">//</span>
    <span class="comment">// The partitioning chooses a pivot between `p` and `r` and moves all</span>
    <span class="comment">// elements that are less than or equal to the pivot to the before it, and</span>
    <span class="comment">// all the elements that are greater than it after it. The effect is that</span>
    <span class="comment">// once partition is done, the pivot is in the exact place it will be when</span>
    <span class="comment">// the array is put in sorted order, and it will not need to be moved</span>
    <span class="comment">// again. This runs in O(n) time.</span>

    <span class="comment">// Always choose a random pivot so that an input array which is reverse</span>
    <span class="comment">// sorted does not cause O(n^2) running time.</span>
    <span class="keyword">var</span> pivotIndex = randomIntInRange(p, r);
    <span class="keyword">var</span> i = p - <span class="number">1</span>;

    swap(ary, pivotIndex, r);
    <span class="keyword">var</span> pivot = ary[r];

    <span class="comment">// Immediately after `j` is incremented in this loop, the following hold</span>
    <span class="comment">// true:</span>
    <span class="comment">//</span>
    <span class="comment">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span>
    <span class="comment">//</span>
    <span class="comment">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> j = p; j &lt; r; j++) {
      <span class="keyword">if</span> (comparator(ary[j], pivot) &lt;= <span class="number">0</span>) {
        i += <span class="number">1</span>;
        swap(ary, i, j);
      }
    }

    swap(ary, i + <span class="number">1</span>, j);
    <span class="keyword">var</span> q = i + <span class="number">1</span>;

    <span class="comment">// (2) Recurse on each half.</span>

    doQuickSort(ary, comparator, p, q - <span class="number">1</span>);
    doQuickSort(ary, comparator, q + <span class="number">1</span>, r);
  }
}

<span class="comment">/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */</span>
exports.quickSort = <span class="function"><span class="keyword">function</span> <span class="params">(ary, comparator)</span> {</span>
  doQuickSort(ary, comparator, <span class="number">0</span>, ary.length - <span class="number">1</span>);
};
</code></pre>