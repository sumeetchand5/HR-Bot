<h1>source-map-consumer.js</h1>
<pre><code class="lang-js"><span class="comment">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
<span class="comment">/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */</span>

<span class="keyword">var</span> util = require(<span class="string">'./util'</span>);
<span class="keyword">var</span> binarySearch = require(<span class="string">'./binary-search'</span>);
<span class="keyword">var</span> ArraySet = require(<span class="string">'./array-set'</span>).ArraySet;
<span class="keyword">var</span> base64VLQ = require(<span class="string">'./base64-vlq'</span>);
<span class="keyword">var</span> quickSort = require(<span class="string">'./quick-sort'</span>).quickSort;

<span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer</span><span class="params">(aSourceMap)</span> {</span>
  <span class="keyword">var</span> sourceMap = aSourceMap;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> aSourceMap === <span class="string">'string'</span>) {
    sourceMap = JSON.parse(aSourceMap.replace(<span class="regexp">/^\)\]\}'/</span>, <span class="string">''</span>));
  }

  <span class="keyword">return</span> sourceMap.sections != <span class="literal">null</span>
    ? <span class="keyword">new</span> IndexedSourceMapConsumer(sourceMap)
    : <span class="keyword">new</span> BasicSourceMapConsumer(sourceMap);
}

SourceMapConsumer.fromSourceMap = <span class="keyword">function</span>(aSourceMap) {
  <span class="keyword">return</span> BasicSourceMapConsumer.fromSourceMap(aSourceMap);
}

<span class="comment">/**
 * The version of the source mapping spec that we are consuming.
 */</span>
SourceMapConsumer.prototype._version = <span class="number">3</span>;

<span class="comment">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span>
<span class="comment">// parsed mapping coordinates from the source map's "mappings" attribute. They</span>
<span class="comment">// are lazily instantiated, accessed via the `_generatedMappings` and</span>
<span class="comment">// `_originalMappings` getters respectively, and we only parse the mappings</span>
<span class="comment">// and create these arrays once queried for a source location. We jump through</span>
<span class="comment">// these hoops because there can be many thousands of mappings, and parsing</span>
<span class="comment">// them is expensive, so we only want to do it if we must.</span>
<span class="comment">//</span>
<span class="comment">// Each object in the arrays is of the form:</span>
<span class="comment">//</span>
<span class="comment">//     {</span>
<span class="comment">//       generatedLine: The line number in the generated code,</span>
<span class="comment">//       generatedColumn: The column number in the generated code,</span>
<span class="comment">//       source: The path to the original source file that generated this</span>
<span class="comment">//               chunk of code,</span>
<span class="comment">//       originalLine: The line number in the original source that</span>
<span class="comment">//                     corresponds to this chunk of generated code,</span>
<span class="comment">//       originalColumn: The column number in the original source that</span>
<span class="comment">//                       corresponds to this chunk of generated code,</span>
<span class="comment">//       name: The name of the original symbol which generated this chunk of</span>
<span class="comment">//             code.</span>
<span class="comment">//     }</span>
<span class="comment">//</span>
<span class="comment">// All properties except for `generatedLine` and `generatedColumn` can be</span>
<span class="comment">// `null`.</span>
<span class="comment">//</span>
<span class="comment">// `_generatedMappings` is ordered by the generated positions.</span>
<span class="comment">//</span>
<span class="comment">// `_originalMappings` is ordered by the original positions.</span>

SourceMapConsumer.prototype.__generatedMappings = <span class="literal">null</span>;
Object.defineProperty(SourceMapConsumer.prototype, <span class="string">'_generatedMappings'</span>, {
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.__generatedMappings) {
      <span class="keyword">this</span>._parseMappings(<span class="keyword">this</span>._mappings, <span class="keyword">this</span>.sourceRoot);
    }

    <span class="keyword">return</span> <span class="keyword">this</span>.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = <span class="literal">null</span>;
Object.defineProperty(SourceMapConsumer.prototype, <span class="string">'_originalMappings'</span>, {
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.__originalMappings) {
      <span class="keyword">this</span>._parseMappings(<span class="keyword">this</span>._mappings, <span class="keyword">this</span>.sourceRoot);
    }

    <span class="keyword">return</span> <span class="keyword">this</span>.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_charIsMappingSeparator</span><span class="params">(aStr, index)</span> {</span>
    <span class="keyword">var</span> c = aStr.charAt(index);
    <span class="keyword">return</span> c === <span class="string">";"</span> || c === <span class="string">","</span>;
  };

<span class="comment">/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */</span>
SourceMapConsumer.prototype._parseMappings =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_parseMappings</span><span class="params">(aStr, aSourceRoot)</span> {</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Subclasses must implement _parseMappings"</span>);
  };

SourceMapConsumer.GENERATED_ORDER = <span class="number">1</span>;
SourceMapConsumer.ORIGINAL_ORDER = <span class="number">2</span>;

SourceMapConsumer.GREATEST_LOWER_BOUND = <span class="number">1</span>;
SourceMapConsumer.LEAST_UPPER_BOUND = <span class="number">2</span>;

<span class="comment">/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */</span>
SourceMapConsumer.prototype.eachMapping =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_eachMapping</span><span class="params">(aCallback, aContext, aOrder)</span> {</span>
    <span class="keyword">var</span> context = aContext || <span class="literal">null</span>;
    <span class="keyword">var</span> order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    <span class="keyword">var</span> mappings;
    <span class="keyword">switch</span> (order) {
    <span class="keyword">case</span> SourceMapConsumer.GENERATED_ORDER:
      mappings = <span class="keyword">this</span>._generatedMappings;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> SourceMapConsumer.ORIGINAL_ORDER:
      mappings = <span class="keyword">this</span>._originalMappings;
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Unknown order of iteration."</span>);
    }

    <span class="keyword">var</span> sourceRoot = <span class="keyword">this</span>.sourceRoot;
    mappings.map(<span class="function"><span class="keyword">function</span> <span class="params">(mapping)</span> {</span>
      <span class="keyword">var</span> source = mapping.source === <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">this</span>._sources.at(mapping.source);
      <span class="keyword">if</span> (source != <span class="literal">null</span> &amp;&amp; sourceRoot != <span class="literal">null</span>) {
        source = util.join(sourceRoot, source);
      }
      <span class="keyword">return</span> {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === <span class="literal">null</span> ? <span class="literal">null</span> : <span class="keyword">this</span>._names.at(mapping.name)
      };
    }, <span class="keyword">this</span>).forEach(aCallback, context);
  };

<span class="comment">/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: Optional. the column number in the original source.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */</span>
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_allGeneratedPositionsFor</span><span class="params">(aArgs)</span> {</span>
    <span class="keyword">var</span> line = util.getArg(aArgs, <span class="string">'line'</span>);

    <span class="comment">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span>
    <span class="comment">// returns the index of the closest mapping less than the needle. By</span>
    <span class="comment">// setting needle.originalColumn to 0, we thus find the last mapping for</span>
    <span class="comment">// the given line, provided such a mapping exists.</span>
    <span class="keyword">var</span> needle = {
      source: util.getArg(aArgs, <span class="string">'source'</span>),
      originalLine: line,
      originalColumn: util.getArg(aArgs, <span class="string">'column'</span>, <span class="number">0</span>)
    };

    <span class="keyword">if</span> (<span class="keyword">this</span>.sourceRoot != <span class="literal">null</span>) {
      needle.source = util.relative(<span class="keyword">this</span>.sourceRoot, needle.source);
    }
    <span class="keyword">if</span> (!<span class="keyword">this</span>._sources.has(needle.source)) {
      <span class="keyword">return</span> [];
    }
    needle.source = <span class="keyword">this</span>._sources.indexOf(needle.source);

    <span class="keyword">var</span> mappings = [];

    <span class="keyword">var</span> index = <span class="keyword">this</span>._findMapping(needle,
                                  <span class="keyword">this</span>._originalMappings,
                                  <span class="string">"originalLine"</span>,
                                  <span class="string">"originalColumn"</span>,
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    <span class="keyword">if</span> (index >= <span class="number">0</span>) {
      <span class="keyword">var</span> mapping = <span class="keyword">this</span>._originalMappings[index];

      <span class="keyword">if</span> (aArgs.column === <span class="literal">undefined</span>) {
        <span class="keyword">var</span> originalLine = mapping.originalLine;

        <span class="comment">// Iterate until either we run out of mappings, or we run into</span>
        <span class="comment">// a mapping for a different line than the one we found. Since</span>
        <span class="comment">// mappings are sorted, this is guaranteed to find all mappings for</span>
        <span class="comment">// the line we found.</span>
        <span class="keyword">while</span> (mapping &amp;&amp; mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, <span class="string">'generatedLine'</span>, <span class="literal">null</span>),
            column: util.getArg(mapping, <span class="string">'generatedColumn'</span>, <span class="literal">null</span>),
            lastColumn: util.getArg(mapping, <span class="string">'lastGeneratedColumn'</span>, <span class="literal">null</span>)
          });

          mapping = <span class="keyword">this</span>._originalMappings[++index];
        }
      } <span class="keyword">else</span> {
        <span class="keyword">var</span> originalColumn = mapping.originalColumn;

        <span class="comment">// Iterate until either we run out of mappings, or we run into</span>
        <span class="comment">// a mapping for a different line than the one we were searching for.</span>
        <span class="comment">// Since mappings are sorted, this is guaranteed to find all mappings for</span>
        <span class="comment">// the line we are searching for.</span>
        <span class="keyword">while</span> (mapping &amp;&amp;
               mapping.originalLine === line &amp;&amp;
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, <span class="string">'generatedLine'</span>, <span class="literal">null</span>),
            column: util.getArg(mapping, <span class="string">'generatedColumn'</span>, <span class="literal">null</span>),
            lastColumn: util.getArg(mapping, <span class="string">'lastGeneratedColumn'</span>, <span class="literal">null</span>)
          });

          mapping = <span class="keyword">this</span>._originalMappings[++index];
        }
      }
    }

    <span class="keyword">return</span> mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

<span class="comment">/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The only parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">BasicSourceMapConsumer</span><span class="params">(aSourceMap)</span> {</span>
  <span class="keyword">var</span> sourceMap = aSourceMap;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> aSourceMap === <span class="string">'string'</span>) {
    sourceMap = JSON.parse(aSourceMap.replace(<span class="regexp">/^\)\]\}'/</span>, <span class="string">''</span>));
  }

  <span class="keyword">var</span> version = util.getArg(sourceMap, <span class="string">'version'</span>);
  <span class="keyword">var</span> sources = util.getArg(sourceMap, <span class="string">'sources'</span>);
  <span class="comment">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span>
  <span class="comment">// requires the array) to play nice here.</span>
  <span class="keyword">var</span> names = util.getArg(sourceMap, <span class="string">'names'</span>, []);
  <span class="keyword">var</span> sourceRoot = util.getArg(sourceMap, <span class="string">'sourceRoot'</span>, <span class="literal">null</span>);
  <span class="keyword">var</span> sourcesContent = util.getArg(sourceMap, <span class="string">'sourcesContent'</span>, <span class="literal">null</span>);
  <span class="keyword">var</span> mappings = util.getArg(sourceMap, <span class="string">'mappings'</span>);
  <span class="keyword">var</span> file = util.getArg(sourceMap, <span class="string">'file'</span>, <span class="literal">null</span>);

  <span class="comment">// Once again, Sass deviates from the spec and supplies the version as a</span>
  <span class="comment">// string rather than a number, so we use loose equality checking here.</span>
  <span class="keyword">if</span> (version != <span class="keyword">this</span>._version) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Unsupported version: '</span> + version);
  }

  sources = sources
    .map(String)
    <span class="comment">// Some source maps produce relative source paths like "./foo.js" instead of</span>
    <span class="comment">// "foo.js".  Normalize these first so that future comparisons will succeed.</span>
    <span class="comment">// See bugzil.la/1090768.</span>
    .map(util.normalize)
    <span class="comment">// Always ensure that absolute sources are internally stored relative to</span>
    <span class="comment">// the source root, if the source root is absolute. Not doing this would</span>
    <span class="comment">// be particularly problematic when the source root is a prefix of the</span>
    <span class="comment">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span>
    .map(<span class="function"><span class="keyword">function</span> <span class="params">(source)</span> {</span>
      <span class="keyword">return</span> sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  <span class="comment">// Pass `true` below to allow duplicate names and sources. While source maps</span>
  <span class="comment">// are intended to be compressed and deduplicated, the TypeScript compiler</span>
  <span class="comment">// sometimes generates source maps with duplicates in them. See Github issue</span>
  <span class="comment">// #72 and bugzil.la/889492.</span>
  <span class="keyword">this</span>._names = ArraySet.fromArray(names.map(String), <span class="literal">true</span>);
  <span class="keyword">this</span>._sources = ArraySet.fromArray(sources, <span class="literal">true</span>);

  <span class="keyword">this</span>.sourceRoot = sourceRoot;
  <span class="keyword">this</span>.sourcesContent = sourcesContent;
  <span class="keyword">this</span>._mappings = mappings;
  <span class="keyword">this</span>.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

<span class="comment">/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @returns BasicSourceMapConsumer
 */</span>
BasicSourceMapConsumer.fromSourceMap =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_fromSourceMap</span><span class="params">(aSourceMap)</span> {</span>
    <span class="keyword">var</span> smc = Object.create(BasicSourceMapConsumer.prototype);

    <span class="keyword">var</span> names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), <span class="literal">true</span>);
    <span class="keyword">var</span> sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), <span class="literal">true</span>);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;

    <span class="comment">// Because we are modifying the entries (by converting string sources and</span>
    <span class="comment">// names to indices into the sources and names ArraySets), we have to make</span>
    <span class="comment">// a copy of the entry or else bad things happen. Shared mutable state</span>
    <span class="comment">// strikes again! See github issue #191.</span>

    <span class="keyword">var</span> generatedMappings = aSourceMap._mappings.toArray().slice();
    <span class="keyword">var</span> destGeneratedMappings = smc.__generatedMappings = [];
    <span class="keyword">var</span> destOriginalMappings = smc.__originalMappings = [];

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = generatedMappings.length; i &lt; length; i++) {
      <span class="keyword">var</span> srcMapping = generatedMappings[i];
      <span class="keyword">var</span> destMapping = <span class="keyword">new</span> Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      <span class="keyword">if</span> (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        <span class="keyword">if</span> (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    <span class="keyword">return</span> smc;
  };

<span class="comment">/**
 * The version of the source mapping spec that we are consuming.
 */</span>
BasicSourceMapConsumer.prototype._version = <span class="number">3</span>;

<span class="comment">/**
 * The list of original sources.
 */</span>
Object.defineProperty(BasicSourceMapConsumer.prototype, <span class="string">'sources'</span>, {
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._sources.toArray().map(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
      <span class="keyword">return</span> <span class="keyword">this</span>.sourceRoot != <span class="literal">null</span> ? util.join(<span class="keyword">this</span>.sourceRoot, s) : s;
    }, <span class="keyword">this</span>);
  }
});

<span class="comment">/**
 * Provide the JIT with a nice shape / hidden class.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">Mapping</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.generatedLine = <span class="number">0</span>;
  <span class="keyword">this</span>.generatedColumn = <span class="number">0</span>;
  <span class="keyword">this</span>.source = <span class="literal">null</span>;
  <span class="keyword">this</span>.originalLine = <span class="literal">null</span>;
  <span class="keyword">this</span>.originalColumn = <span class="literal">null</span>;
  <span class="keyword">this</span>.name = <span class="literal">null</span>;
}

<span class="comment">/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */</span>
BasicSourceMapConsumer.prototype._parseMappings =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_parseMappings</span><span class="params">(aStr, aSourceRoot)</span> {</span>
    <span class="keyword">var</span> generatedLine = <span class="number">1</span>;
    <span class="keyword">var</span> previousGeneratedColumn = <span class="number">0</span>;
    <span class="keyword">var</span> previousOriginalLine = <span class="number">0</span>;
    <span class="keyword">var</span> previousOriginalColumn = <span class="number">0</span>;
    <span class="keyword">var</span> previousSource = <span class="number">0</span>;
    <span class="keyword">var</span> previousName = <span class="number">0</span>;
    <span class="keyword">var</span> length = aStr.length;
    <span class="keyword">var</span> index = <span class="number">0</span>;
    <span class="keyword">var</span> cachedSegments = {};
    <span class="keyword">var</span> temp = {};
    <span class="keyword">var</span> originalMappings = [];
    <span class="keyword">var</span> generatedMappings = [];
    <span class="keyword">var</span> mapping, str, segment, end, value;

    <span class="keyword">while</span> (index &lt; length) {
      <span class="keyword">if</span> (aStr.charAt(index) === <span class="string">';'</span>) {
        generatedLine++;
        index++;
        previousGeneratedColumn = <span class="number">0</span>;
      }
      <span class="keyword">else</span> <span class="keyword">if</span> (aStr.charAt(index) === <span class="string">','</span>) {
        index++;
      }
      <span class="keyword">else</span> {
        mapping = <span class="keyword">new</span> Mapping();
        mapping.generatedLine = generatedLine;

        <span class="comment">// Because each offset is encoded relative to the previous one,</span>
        <span class="comment">// many segments often have the same encoding. We can exploit this</span>
        <span class="comment">// fact by caching the parsed variable length fields of each segment,</span>
        <span class="comment">// allowing us to avoid a second parse if we encounter the same</span>
        <span class="comment">// segment again.</span>
        <span class="keyword">for</span> (end = index; end &lt; length; end++) {
          <span class="keyword">if</span> (<span class="keyword">this</span>._charIsMappingSeparator(aStr, end)) {
            <span class="keyword">break</span>;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        <span class="keyword">if</span> (segment) {
          index += str.length;
        } <span class="keyword">else</span> {
          segment = [];
          <span class="keyword">while</span> (index &lt; end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          <span class="keyword">if</span> (segment.length === <span class="number">2</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Found a source, but no line and column'</span>);
          }

          <span class="keyword">if</span> (segment.length === <span class="number">3</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Found a source and line, but no column'</span>);
          }

          cachedSegments[str] = segment;
        }

        <span class="comment">// Generated column.</span>
        mapping.generatedColumn = previousGeneratedColumn + segment[<span class="number">0</span>];
        previousGeneratedColumn = mapping.generatedColumn;

        <span class="keyword">if</span> (segment.length > <span class="number">1</span>) {
          <span class="comment">// Original source.</span>
          mapping.source = previousSource + segment[<span class="number">1</span>];
          previousSource += segment[<span class="number">1</span>];

          <span class="comment">// Original line.</span>
          mapping.originalLine = previousOriginalLine + segment[<span class="number">2</span>];
          previousOriginalLine = mapping.originalLine;
          <span class="comment">// Lines are stored 0-based</span>
          mapping.originalLine += <span class="number">1</span>;

          <span class="comment">// Original column.</span>
          mapping.originalColumn = previousOriginalColumn + segment[<span class="number">3</span>];
          previousOriginalColumn = mapping.originalColumn;

          <span class="keyword">if</span> (segment.length > <span class="number">4</span>) {
            <span class="comment">// Original name.</span>
            mapping.name = previousName + segment[<span class="number">4</span>];
            previousName += segment[<span class="number">4</span>];
          }
        }

        generatedMappings.push(mapping);
        <span class="keyword">if</span> (<span class="keyword">typeof</span> mapping.originalLine === <span class="string">'number'</span>) {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    <span class="keyword">this</span>.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    <span class="keyword">this</span>.__originalMappings = originalMappings;
  };

<span class="comment">/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */</span>
BasicSourceMapConsumer.prototype._findMapping =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_findMapping</span><span class="params">(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias)</span> {</span>
    <span class="comment">// To return the position we are searching for, we must first find the</span>
    <span class="comment">// mapping for the given position and then return the opposite position it</span>
    <span class="comment">// points to. Because the mappings are sorted, we can use binary search to</span>
    <span class="comment">// find the best mapping.</span>

    <span class="keyword">if</span> (aNeedle[aLineName] &lt;= <span class="number">0</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Line must be greater than or equal to 1, got '</span>
                          + aNeedle[aLineName]);
    }
    <span class="keyword">if</span> (aNeedle[aColumnName] &lt; <span class="number">0</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Column must be greater than or equal to 0, got '</span>
                          + aNeedle[aColumnName]);
    }

    <span class="keyword">return</span> binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

<span class="comment">/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */</span>
BasicSourceMapConsumer.prototype.computeColumnSpans =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_computeColumnSpans</span><span class="params">()</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; <span class="keyword">this</span>._generatedMappings.length; ++index) {
      <span class="keyword">var</span> mapping = <span class="keyword">this</span>._generatedMappings[index];

      <span class="comment">// Mappings do not contain a field for the last generated columnt. We</span>
      <span class="comment">// can come up with an optimistic estimate, however, by assuming that</span>
      <span class="comment">// mappings are contiguous (i.e. given two consecutive mappings, the</span>
      <span class="comment">// first mapping ends where the second one starts).</span>
      <span class="keyword">if</span> (index + <span class="number">1</span> &lt; <span class="keyword">this</span>._generatedMappings.length) {
        <span class="keyword">var</span> nextMapping = <span class="keyword">this</span>._generatedMappings[index + <span class="number">1</span>];

        <span class="keyword">if</span> (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - <span class="number">1</span>;
          <span class="keyword">continue</span>;
        }
      }

      <span class="comment">// The last mapping for each line spans the entire line.</span>
      mapping.lastGeneratedColumn = <span class="literal">Infinity</span>;
    }
  };

<span class="comment">/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */</span>
BasicSourceMapConsumer.prototype.originalPositionFor =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_originalPositionFor</span><span class="params">(aArgs)</span> {</span>
    <span class="keyword">var</span> needle = {
      generatedLine: util.getArg(aArgs, <span class="string">'line'</span>),
      generatedColumn: util.getArg(aArgs, <span class="string">'column'</span>)
    };

    <span class="keyword">var</span> index = <span class="keyword">this</span>._findMapping(
      needle,
      <span class="keyword">this</span>._generatedMappings,
      <span class="string">"generatedLine"</span>,
      <span class="string">"generatedColumn"</span>,
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, <span class="string">'bias'</span>, SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    <span class="keyword">if</span> (index >= <span class="number">0</span>) {
      <span class="keyword">var</span> mapping = <span class="keyword">this</span>._generatedMappings[index];

      <span class="keyword">if</span> (mapping.generatedLine === needle.generatedLine) {
        <span class="keyword">var</span> source = util.getArg(mapping, <span class="string">'source'</span>, <span class="literal">null</span>);
        <span class="keyword">if</span> (source !== <span class="literal">null</span>) {
          source = <span class="keyword">this</span>._sources.at(source);
          <span class="keyword">if</span> (<span class="keyword">this</span>.sourceRoot != <span class="literal">null</span>) {
            source = util.join(<span class="keyword">this</span>.sourceRoot, source);
          }
        }
        <span class="keyword">var</span> name = util.getArg(mapping, <span class="string">'name'</span>, <span class="literal">null</span>);
        <span class="keyword">if</span> (name !== <span class="literal">null</span>) {
          name = <span class="keyword">this</span>._names.at(name);
        }
        <span class="keyword">return</span> {
          source: source,
          line: util.getArg(mapping, <span class="string">'originalLine'</span>, <span class="literal">null</span>),
          column: util.getArg(mapping, <span class="string">'originalColumn'</span>, <span class="literal">null</span>),
          name: name
        };
      }
    }

    <span class="keyword">return</span> {
      source: <span class="literal">null</span>,
      line: <span class="literal">null</span>,
      column: <span class="literal">null</span>,
      name: <span class="literal">null</span>
    };
  };

<span class="comment">/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */</span>
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  <span class="function"><span class="keyword">function</span> <span class="title">BasicSourceMapConsumer_hasContentsOfAllSources</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.sourcesContent) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>.sourcesContent.length >= <span class="keyword">this</span>._sources.size() &amp;&amp;
      !<span class="keyword">this</span>.sourcesContent.some(<span class="function"><span class="keyword">function</span> <span class="params">(sc)</span> {</span> <span class="keyword">return</span> sc == <span class="literal">null</span>; });
  };

<span class="comment">/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */</span>
BasicSourceMapConsumer.prototype.sourceContentFor =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_sourceContentFor</span><span class="params">(aSource, nullOnMissing)</span> {</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.sourcesContent) {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }

    <span class="keyword">if</span> (<span class="keyword">this</span>.sourceRoot != <span class="literal">null</span>) {
      aSource = util.relative(<span class="keyword">this</span>.sourceRoot, aSource);
    }

    <span class="keyword">if</span> (<span class="keyword">this</span>._sources.has(aSource)) {
      <span class="keyword">return</span> <span class="keyword">this</span>.sourcesContent[<span class="keyword">this</span>._sources.indexOf(aSource)];
    }

    <span class="keyword">var</span> url;
    <span class="keyword">if</span> (<span class="keyword">this</span>.sourceRoot != <span class="literal">null</span>
        &amp;&amp; (url = util.urlParse(<span class="keyword">this</span>.sourceRoot))) {
      <span class="comment">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span>
      <span class="comment">// many users. We can help them out when they expect file:// URIs to</span>
      <span class="comment">// behave like it would if they were running a local HTTP server. See</span>
      <span class="comment">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span>
      <span class="keyword">var</span> fileUriAbsPath = aSource.replace(<span class="regexp">/^file:\/\//</span>, <span class="string">""</span>);
      <span class="keyword">if</span> (url.scheme == <span class="string">"file"</span>
          &amp;&amp; <span class="keyword">this</span>._sources.has(fileUriAbsPath)) {
        <span class="keyword">return</span> <span class="keyword">this</span>.sourcesContent[<span class="keyword">this</span>._sources.indexOf(fileUriAbsPath)]
      }

      <span class="keyword">if</span> ((!url.path || url.path == <span class="string">"/"</span>)
          &amp;&amp; <span class="keyword">this</span>._sources.has(<span class="string">"/"</span> + aSource)) {
        <span class="keyword">return</span> <span class="keyword">this</span>.sourcesContent[<span class="keyword">this</span>._sources.indexOf(<span class="string">"/"</span> + aSource)];
      }
    }

    <span class="comment">// This function is used recursively from</span>
    <span class="comment">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span>
    <span class="comment">// don't want to throw if we can't find the source - we just want to</span>
    <span class="comment">// return null, so we provide a flag to exit gracefully.</span>
    <span class="keyword">if</span> (nullOnMissing) {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
    <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'"'</span> + aSource + <span class="string">'" is not in the SourceMap.'</span>);
    }
  };

<span class="comment">/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */</span>
BasicSourceMapConsumer.prototype.generatedPositionFor =
  <span class="function"><span class="keyword">function</span> <span class="title">SourceMapConsumer_generatedPositionFor</span><span class="params">(aArgs)</span> {</span>
    <span class="keyword">var</span> source = util.getArg(aArgs, <span class="string">'source'</span>);
    <span class="keyword">if</span> (<span class="keyword">this</span>.sourceRoot != <span class="literal">null</span>) {
      source = util.relative(<span class="keyword">this</span>.sourceRoot, source);
    }
    <span class="keyword">if</span> (!<span class="keyword">this</span>._sources.has(source)) {
      <span class="keyword">return</span> {
        line: <span class="literal">null</span>,
        column: <span class="literal">null</span>,
        lastColumn: <span class="literal">null</span>
      };
    }
    source = <span class="keyword">this</span>._sources.indexOf(source);

    <span class="keyword">var</span> needle = {
      source: source,
      originalLine: util.getArg(aArgs, <span class="string">'line'</span>),
      originalColumn: util.getArg(aArgs, <span class="string">'column'</span>)
    };

    <span class="keyword">var</span> index = <span class="keyword">this</span>._findMapping(
      needle,
      <span class="keyword">this</span>._originalMappings,
      <span class="string">"originalLine"</span>,
      <span class="string">"originalColumn"</span>,
      util.compareByOriginalPositions,
      util.getArg(aArgs, <span class="string">'bias'</span>, SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    <span class="keyword">if</span> (index >= <span class="number">0</span>) {
      <span class="keyword">var</span> mapping = <span class="keyword">this</span>._originalMappings[index];

      <span class="keyword">if</span> (mapping.source === needle.source) {
        <span class="keyword">return</span> {
          line: util.getArg(mapping, <span class="string">'generatedLine'</span>, <span class="literal">null</span>),
          column: util.getArg(mapping, <span class="string">'generatedColumn'</span>, <span class="literal">null</span>),
          lastColumn: util.getArg(mapping, <span class="string">'lastGeneratedColumn'</span>, <span class="literal">null</span>)
        };
      }
    }

    <span class="keyword">return</span> {
      line: <span class="literal">null</span>,
      column: <span class="literal">null</span>,
      lastColumn: <span class="literal">null</span>
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

<span class="comment">/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The only parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">IndexedSourceMapConsumer</span><span class="params">(aSourceMap)</span> {</span>
  <span class="keyword">var</span> sourceMap = aSourceMap;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> aSourceMap === <span class="string">'string'</span>) {
    sourceMap = JSON.parse(aSourceMap.replace(<span class="regexp">/^\)\]\}'/</span>, <span class="string">''</span>));
  }

  <span class="keyword">var</span> version = util.getArg(sourceMap, <span class="string">'version'</span>);
  <span class="keyword">var</span> sections = util.getArg(sourceMap, <span class="string">'sections'</span>);

  <span class="keyword">if</span> (version != <span class="keyword">this</span>._version) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Unsupported version: '</span> + version);
  }

  <span class="keyword">this</span>._sources = <span class="keyword">new</span> ArraySet();
  <span class="keyword">this</span>._names = <span class="keyword">new</span> ArraySet();

  <span class="keyword">var</span> lastOffset = {
    line: -<span class="number">1</span>,
    column: <span class="number">0</span>
  };
  <span class="keyword">this</span>._sections = sections.map(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
    <span class="keyword">if</span> (s.url) {
      <span class="comment">// The url field will require support for asynchronicity.</span>
      <span class="comment">// See https://github.com/mozilla/source-map/issues/16</span>
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Support for url field in sections not implemented.'</span>);
    }
    <span class="keyword">var</span> offset = util.getArg(s, <span class="string">'offset'</span>);
    <span class="keyword">var</span> offsetLine = util.getArg(offset, <span class="string">'line'</span>);
    <span class="keyword">var</span> offsetColumn = util.getArg(offset, <span class="string">'column'</span>);

    <span class="keyword">if</span> (offsetLine &lt; lastOffset.line ||
        (offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Section offsets must be ordered and non-overlapping.'</span>);
    }
    lastOffset = offset;

    <span class="keyword">return</span> {
      generatedOffset: {
        <span class="comment">// The offset fields are 0-based, but we use 1-based indices when</span>
        <span class="comment">// encoding/decoding from VLQ.</span>
        generatedLine: offsetLine + <span class="number">1</span>,
        generatedColumn: offsetColumn + <span class="number">1</span>
      },
      consumer: <span class="keyword">new</span> SourceMapConsumer(util.getArg(s, <span class="string">'map'</span>))
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

<span class="comment">/**
 * The version of the source mapping spec that we are consuming.
 */</span>
IndexedSourceMapConsumer.prototype._version = <span class="number">3</span>;

<span class="comment">/**
 * The list of original sources.
 */</span>
Object.defineProperty(IndexedSourceMapConsumer.prototype, <span class="string">'sources'</span>, {
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> sources = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._sections.length; i++) {
      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>._sections[i].consumer.sources.length; j++) {
        sources.push(<span class="keyword">this</span>._sections[i].consumer.sources[j]);
      }
    }
    <span class="keyword">return</span> sources;
  }
});

<span class="comment">/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.
 *   - column: The column number in the generated source.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.
 *   - column: The column number in the original source, or null.
 *   - name: The original identifier, or null.
 */</span>
IndexedSourceMapConsumer.prototype.originalPositionFor =
  <span class="function"><span class="keyword">function</span> <span class="title">IndexedSourceMapConsumer_originalPositionFor</span><span class="params">(aArgs)</span> {</span>
    <span class="keyword">var</span> needle = {
      generatedLine: util.getArg(aArgs, <span class="string">'line'</span>),
      generatedColumn: util.getArg(aArgs, <span class="string">'column'</span>)
    };

    <span class="comment">// Find the section containing the generated position we're trying to map</span>
    <span class="comment">// to an original position.</span>
    <span class="keyword">var</span> sectionIndex = binarySearch.search(needle, <span class="keyword">this</span>._sections,
      <span class="keyword">function</span>(needle, section) {
        <span class="keyword">var</span> cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        <span class="keyword">if</span> (cmp) {
          <span class="keyword">return</span> cmp;
        }

        <span class="keyword">return</span> (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    <span class="keyword">var</span> section = <span class="keyword">this</span>._sections[sectionIndex];

    <span class="keyword">if</span> (!section) {
      <span class="keyword">return</span> {
        source: <span class="literal">null</span>,
        line: <span class="literal">null</span>,
        column: <span class="literal">null</span>,
        name: <span class="literal">null</span>
      };
    }

    <span class="keyword">return</span> section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - <span class="number">1</span>),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - <span class="number">1</span>
         : <span class="number">0</span>),
      bias: aArgs.bias
    });
  };

<span class="comment">/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */</span>
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  <span class="function"><span class="keyword">function</span> <span class="title">IndexedSourceMapConsumer_hasContentsOfAllSources</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._sections.every(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
      <span class="keyword">return</span> s.consumer.hasContentsOfAllSources();
    });
  };

<span class="comment">/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */</span>
IndexedSourceMapConsumer.prototype.sourceContentFor =
  <span class="function"><span class="keyword">function</span> <span class="title">IndexedSourceMapConsumer_sourceContentFor</span><span class="params">(aSource, nullOnMissing)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._sections.length; i++) {
      <span class="keyword">var</span> section = <span class="keyword">this</span>._sections[i];

      <span class="keyword">var</span> content = section.consumer.sourceContentFor(aSource, <span class="literal">true</span>);
      <span class="keyword">if</span> (content) {
        <span class="keyword">return</span> content;
      }
    }
    <span class="keyword">if</span> (nullOnMissing) {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
    <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'"'</span> + aSource + <span class="string">'" is not in the SourceMap.'</span>);
    }
  };

<span class="comment">/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.
 *   - column: The column number in the original source.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.
 *   - column: The column number in the generated source, or null.
 */</span>
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  <span class="function"><span class="keyword">function</span> <span class="title">IndexedSourceMapConsumer_generatedPositionFor</span><span class="params">(aArgs)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._sections.length; i++) {
      <span class="keyword">var</span> section = <span class="keyword">this</span>._sections[i];

      <span class="comment">// Only consider this section if the requested source is in the list of</span>
      <span class="comment">// sources of the consumer.</span>
      <span class="keyword">if</span> (section.consumer.sources.indexOf(util.getArg(aArgs, <span class="string">'source'</span>)) === -<span class="number">1</span>) {
        <span class="keyword">continue</span>;
      }
      <span class="keyword">var</span> generatedPosition = section.consumer.generatedPositionFor(aArgs);
      <span class="keyword">if</span> (generatedPosition) {
        <span class="keyword">var</span> ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - <span class="number">1</span>),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - <span class="number">1</span>
             : <span class="number">0</span>)
        };
        <span class="keyword">return</span> ret;
      }
    }

    <span class="keyword">return</span> {
      line: <span class="literal">null</span>,
      column: <span class="literal">null</span>
    };
  };

<span class="comment">/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */</span>
IndexedSourceMapConsumer.prototype._parseMappings =
  <span class="function"><span class="keyword">function</span> <span class="title">IndexedSourceMapConsumer_parseMappings</span><span class="params">(aStr, aSourceRoot)</span> {</span>
    <span class="keyword">this</span>.__generatedMappings = [];
    <span class="keyword">this</span>.__originalMappings = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>._sections.length; i++) {
      <span class="keyword">var</span> section = <span class="keyword">this</span>._sections[i];
      <span class="keyword">var</span> sectionMappings = section.consumer._generatedMappings;
      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; sectionMappings.length; j++) {
        <span class="keyword">var</span> mapping = sectionMappings[j];

        <span class="keyword">var</span> source = section.consumer._sources.at(mapping.source);
        <span class="keyword">if</span> (section.consumer.sourceRoot !== <span class="literal">null</span>) {
          source = util.join(section.consumer.sourceRoot, source);
        }
        <span class="keyword">this</span>._sources.add(source);
        source = <span class="keyword">this</span>._sources.indexOf(source);

        <span class="keyword">var</span> name = section.consumer._names.at(mapping.name);
        <span class="keyword">this</span>._names.add(name);
        name = <span class="keyword">this</span>._names.indexOf(name);

        <span class="comment">// The mappings coming from the consumer for the section have</span>
        <span class="comment">// generated positions relative to the start of the section, so we</span>
        <span class="comment">// need to offset them to be relative to the start of the concatenated</span>
        <span class="comment">// generated file.</span>
        <span class="keyword">var</span> adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - <span class="number">1</span>),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - <span class="number">1</span>
            : <span class="number">0</span>),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        <span class="keyword">this</span>.__generatedMappings.push(adjustedMapping);
        <span class="keyword">if</span> (<span class="keyword">typeof</span> adjustedMapping.originalLine === <span class="string">'number'</span>) {
          <span class="keyword">this</span>.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(<span class="keyword">this</span>.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(<span class="keyword">this</span>.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
</code></pre>