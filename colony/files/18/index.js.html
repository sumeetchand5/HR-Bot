<h1>index.js</h1>
<pre><code class="lang-js"><span class="string">'use strict'</span>;

<span class="keyword">var</span> Buffer = require(<span class="string">'buffer'</span>).Buffer;
<span class="keyword">var</span> Transform = require(<span class="string">'stream'</span>).Transform;
<span class="keyword">var</span> binding = require(<span class="string">'./binding'</span>);
<span class="keyword">var</span> util = require(<span class="string">'util'</span>);
<span class="keyword">var</span> assert = require(<span class="string">'assert'</span>).ok;
<span class="keyword">var</span> kMaxLength = require(<span class="string">'buffer'</span>).kMaxLength;
<span class="keyword">var</span> kRangeErrorMessage = <span class="string">'Cannot create final Buffer. It would be larger '</span> + <span class="string">'than 0x'</span> + kMaxLength.toString(<span class="number">16</span>) + <span class="string">' bytes'</span>;

<span class="comment">// zlib doesn't provide these, so kludge them in following the same</span>
<span class="comment">// const naming scheme zlib uses.</span>
binding.Z_MIN_WINDOWBITS = <span class="number">8</span>;
binding.Z_MAX_WINDOWBITS = <span class="number">15</span>;
binding.Z_DEFAULT_WINDOWBITS = <span class="number">15</span>;

<span class="comment">// fewer than 64 bytes per chunk is stupid.</span>
<span class="comment">// technically it could work with as few as 8, but even 64 bytes</span>
<span class="comment">// is absurdly low.  Usually a MB or more is best.</span>
binding.Z_MIN_CHUNK = <span class="number">64</span>;
binding.Z_MAX_CHUNK = <span class="literal">Infinity</span>;
binding.Z_DEFAULT_CHUNK = <span class="number">16</span> * <span class="number">1024</span>;

binding.Z_MIN_MEMLEVEL = <span class="number">1</span>;
binding.Z_MAX_MEMLEVEL = <span class="number">9</span>;
binding.Z_DEFAULT_MEMLEVEL = <span class="number">8</span>;

binding.Z_MIN_LEVEL = -<span class="number">1</span>;
binding.Z_MAX_LEVEL = <span class="number">9</span>;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

<span class="comment">// expose all the zlib constants</span>
<span class="keyword">var</span> bkeys = Object.keys(binding);
<span class="keyword">for</span> (<span class="keyword">var</span> bk = <span class="number">0</span>; bk &lt; bkeys.length; bk++) {
  <span class="keyword">var</span> bkey = bkeys[bk];
  <span class="keyword">if</span> (bkey.match(<span class="regexp">/^Z/</span>)) {
    Object.defineProperty(exports, bkey, {
      enumerable: <span class="literal">true</span>, value: binding[bkey], writable: <span class="literal">false</span>
    });
  }
}

<span class="comment">// translation table for return codes.</span>
<span class="keyword">var</span> codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

<span class="keyword">var</span> ckeys = Object.keys(codes);
<span class="keyword">for</span> (<span class="keyword">var</span> ck = <span class="number">0</span>; ck &lt; ckeys.length; ck++) {
  <span class="keyword">var</span> ckey = ckeys[ck];
  codes[codes[ckey]] = ckey;
}

Object.defineProperty(exports, <span class="string">'codes'</span>, {
  enumerable: <span class="literal">true</span>, value: Object.freeze(codes), writable: <span class="literal">false</span>
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Deflate(o);
};

exports.createInflate = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Inflate(o);
};

exports.createDeflateRaw = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> DeflateRaw(o);
};

exports.createInflateRaw = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> InflateRaw(o);
};

exports.createGzip = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Gzip(o);
};

exports.createGunzip = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Gunzip(o);
};

exports.createUnzip = <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Unzip(o);
};

<span class="comment">// Convenience methods.</span>
<span class="comment">// compress/decompress a string or buffer in one step.</span>
exports.deflate = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) {
    callback = opts;
    opts = {};
  }
  <span class="keyword">return</span> zlibBuffer(<span class="keyword">new</span> Deflate(opts), buffer, callback);
};

exports.deflateSync = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts)</span> {</span>
  <span class="keyword">return</span> zlibBufferSync(<span class="keyword">new</span> Deflate(opts), buffer);
};

exports.gzip = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) {
    callback = opts;
    opts = {};
  }
  <span class="keyword">return</span> zlibBuffer(<span class="keyword">new</span> Gzip(opts), buffer, callback);
};

exports.gzipSync = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts)</span> {</span>
  <span class="keyword">return</span> zlibBufferSync(<span class="keyword">new</span> Gzip(opts), buffer);
};

exports.deflateRaw = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) {
    callback = opts;
    opts = {};
  }
  <span class="keyword">return</span> zlibBuffer(<span class="keyword">new</span> DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts)</span> {</span>
  <span class="keyword">return</span> zlibBufferSync(<span class="keyword">new</span> DeflateRaw(opts), buffer);
};

exports.unzip = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) {
    callback = opts;
    opts = {};
  }
  <span class="keyword">return</span> zlibBuffer(<span class="keyword">new</span> Unzip(opts), buffer, callback);
};

exports.unzipSync = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts)</span> {</span>
  <span class="keyword">return</span> zlibBufferSync(<span class="keyword">new</span> Unzip(opts), buffer);
};

exports.inflate = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) {
    callback = opts;
    opts = {};
  }
  <span class="keyword">return</span> zlibBuffer(<span class="keyword">new</span> Inflate(opts), buffer, callback);
};

exports.inflateSync = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts)</span> {</span>
  <span class="keyword">return</span> zlibBufferSync(<span class="keyword">new</span> Inflate(opts), buffer);
};

exports.gunzip = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) {
    callback = opts;
    opts = {};
  }
  <span class="keyword">return</span> zlibBuffer(<span class="keyword">new</span> Gunzip(opts), buffer, callback);
};

exports.gunzipSync = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts)</span> {</span>
  <span class="keyword">return</span> zlibBufferSync(<span class="keyword">new</span> Gunzip(opts), buffer);
};

exports.inflateRaw = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts, callback)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts === <span class="string">'function'</span>) {
    callback = opts;
    opts = {};
  }
  <span class="keyword">return</span> zlibBuffer(<span class="keyword">new</span> InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = <span class="function"><span class="keyword">function</span> <span class="params">(buffer, opts)</span> {</span>
  <span class="keyword">return</span> zlibBufferSync(<span class="keyword">new</span> InflateRaw(opts), buffer);
};

<span class="function"><span class="keyword">function</span> <span class="title">zlibBuffer</span><span class="params">(engine, buffer, callback)</span> {</span>
  <span class="keyword">var</span> buffers = [];
  <span class="keyword">var</span> nread = <span class="number">0</span>;

  engine.on(<span class="string">'error'</span>, onError);
  engine.on(<span class="string">'end'</span>, onEnd);

  engine.end(buffer);
  flow();

  <span class="function"><span class="keyword">function</span> <span class="title">flow</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> chunk;
    <span class="keyword">while</span> (<span class="literal">null</span> !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once(<span class="string">'readable'</span>, flow);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onError</span><span class="params">(err)</span> {</span>
    engine.removeListener(<span class="string">'end'</span>, onEnd);
    engine.removeListener(<span class="string">'readable'</span>, flow);
    callback(err);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onEnd</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> buf;
    <span class="keyword">var</span> err = <span class="literal">null</span>;

    <span class="keyword">if</span> (nread >= kMaxLength) {
      err = <span class="keyword">new</span> RangeError(kRangeErrorMessage);
    } <span class="keyword">else</span> {
      buf = Buffer.concat(buffers, nread);
    }

    buffers = [];
    engine.close();
    callback(err, buf);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">zlibBufferSync</span><span class="params">(engine, buffer)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> buffer === <span class="string">'string'</span>) buffer = Buffer.from(buffer);

  <span class="keyword">if</span> (!Buffer.isBuffer(buffer)) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Not a string or buffer'</span>);

  <span class="keyword">var</span> flushFlag = engine._finishFlushFlag;

  <span class="keyword">return</span> engine._processChunk(buffer, flushFlag);
}

<span class="comment">// generic zlib</span>
<span class="comment">// minimal 2-byte header</span>
<span class="function"><span class="keyword">function</span> <span class="title">Deflate</span><span class="params">(opts)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Deflate)) <span class="keyword">return</span> <span class="keyword">new</span> Deflate(opts);
  Zlib.call(<span class="keyword">this</span>, opts, binding.DEFLATE);
}

<span class="function"><span class="keyword">function</span> <span class="title">Inflate</span><span class="params">(opts)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Inflate)) <span class="keyword">return</span> <span class="keyword">new</span> Inflate(opts);
  Zlib.call(<span class="keyword">this</span>, opts, binding.INFLATE);
}

<span class="comment">// gzip - bigger header, same deflate compression</span>
<span class="function"><span class="keyword">function</span> <span class="title">Gzip</span><span class="params">(opts)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Gzip)) <span class="keyword">return</span> <span class="keyword">new</span> Gzip(opts);
  Zlib.call(<span class="keyword">this</span>, opts, binding.GZIP);
}

<span class="function"><span class="keyword">function</span> <span class="title">Gunzip</span><span class="params">(opts)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Gunzip)) <span class="keyword">return</span> <span class="keyword">new</span> Gunzip(opts);
  Zlib.call(<span class="keyword">this</span>, opts, binding.GUNZIP);
}

<span class="comment">// raw - no header</span>
<span class="function"><span class="keyword">function</span> <span class="title">DeflateRaw</span><span class="params">(opts)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> DeflateRaw)) <span class="keyword">return</span> <span class="keyword">new</span> DeflateRaw(opts);
  Zlib.call(<span class="keyword">this</span>, opts, binding.DEFLATERAW);
}

<span class="function"><span class="keyword">function</span> <span class="title">InflateRaw</span><span class="params">(opts)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> InflateRaw)) <span class="keyword">return</span> <span class="keyword">new</span> InflateRaw(opts);
  Zlib.call(<span class="keyword">this</span>, opts, binding.INFLATERAW);
}

<span class="comment">// auto-detect header.</span>
<span class="function"><span class="keyword">function</span> <span class="title">Unzip</span><span class="params">(opts)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Unzip)) <span class="keyword">return</span> <span class="keyword">new</span> Unzip(opts);
  Zlib.call(<span class="keyword">this</span>, opts, binding.UNZIP);
}

<span class="function"><span class="keyword">function</span> <span class="title">isValidFlushFlag</span><span class="params">(flag)</span> {</span>
  <span class="keyword">return</span> flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
}

<span class="comment">// the Zlib class they all inherit from</span>
<span class="comment">// This thing manages the queue of requests, and returns</span>
<span class="comment">// true or false if there is anything in the queue when</span>
<span class="comment">// you call the .write() method.</span>

<span class="function"><span class="keyword">function</span> <span class="title">Zlib</span><span class="params">(opts, mode)</span> {</span>
  <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

  <span class="keyword">this</span>._opts = opts = opts || {};
  <span class="keyword">this</span>._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(<span class="keyword">this</span>, opts);

  <span class="keyword">if</span> (opts.flush &amp;&amp; !isValidFlushFlag(opts.flush)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid flush flag: '</span> + opts.flush);
  }
  <span class="keyword">if</span> (opts.finishFlush &amp;&amp; !isValidFlushFlag(opts.finishFlush)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid flush flag: '</span> + opts.finishFlush);
  }

  <span class="keyword">this</span>._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  <span class="keyword">this</span>._finishFlushFlag = <span class="keyword">typeof</span> opts.finishFlush !== <span class="string">'undefined'</span> ? opts.finishFlush : binding.Z_FINISH;

  <span class="keyword">if</span> (opts.chunkSize) {
    <span class="keyword">if</span> (opts.chunkSize &lt; exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid chunk size: '</span> + opts.chunkSize);
    }
  }

  <span class="keyword">if</span> (opts.windowBits) {
    <span class="keyword">if</span> (opts.windowBits &lt; exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid windowBits: '</span> + opts.windowBits);
    }
  }

  <span class="keyword">if</span> (opts.level) {
    <span class="keyword">if</span> (opts.level &lt; exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid compression level: '</span> + opts.level);
    }
  }

  <span class="keyword">if</span> (opts.memLevel) {
    <span class="keyword">if</span> (opts.memLevel &lt; exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid memLevel: '</span> + opts.memLevel);
    }
  }

  <span class="keyword">if</span> (opts.strategy) {
    <span class="keyword">if</span> (opts.strategy != exports.Z_FILTERED &amp;&amp; opts.strategy != exports.Z_HUFFMAN_ONLY &amp;&amp; opts.strategy != exports.Z_RLE &amp;&amp; opts.strategy != exports.Z_FIXED &amp;&amp; opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid strategy: '</span> + opts.strategy);
    }
  }

  <span class="keyword">if</span> (opts.dictionary) {
    <span class="keyword">if</span> (!Buffer.isBuffer(opts.dictionary)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Invalid dictionary: it should be a Buffer instance'</span>);
    }
  }

  <span class="keyword">this</span>._handle = <span class="keyword">new</span> binding.Zlib(mode);

  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">this</span>._hadError = <span class="literal">false</span>;
  <span class="keyword">this</span>._handle.onerror = <span class="function"><span class="keyword">function</span> <span class="params">(message, errno)</span> {</span>
    <span class="comment">// there is no way to cleanly recover.</span>
    <span class="comment">// continuing only obscures problems.</span>
    _close(self);
    self._hadError = <span class="literal">true</span>;

    <span class="keyword">var</span> error = <span class="keyword">new</span> Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit(<span class="string">'error'</span>, error);
  };

  <span class="keyword">var</span> level = exports.Z_DEFAULT_COMPRESSION;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts.level === <span class="string">'number'</span>) level = opts.level;

  <span class="keyword">var</span> strategy = exports.Z_DEFAULT_STRATEGY;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> opts.strategy === <span class="string">'number'</span>) strategy = opts.strategy;

  <span class="keyword">this</span>._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

  <span class="keyword">this</span>._buffer = Buffer.allocUnsafe(<span class="keyword">this</span>._chunkSize);
  <span class="keyword">this</span>._offset = <span class="number">0</span>;
  <span class="keyword">this</span>._level = level;
  <span class="keyword">this</span>._strategy = strategy;

  <span class="keyword">this</span>.once(<span class="string">'end'</span>, <span class="keyword">this</span>.close);

  Object.defineProperty(<span class="keyword">this</span>, <span class="string">'_closed'</span>, {
    get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">return</span> !_<span class="keyword">this</span>._handle;
    },
    configurable: <span class="literal">true</span>,
    enumerable: <span class="literal">true</span>
  });
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = <span class="function"><span class="keyword">function</span> <span class="params">(level, strategy, callback)</span> {</span>
  <span class="keyword">if</span> (level &lt; exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
    <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">'Invalid compression level: '</span> + level);
  }
  <span class="keyword">if</span> (strategy != exports.Z_FILTERED &amp;&amp; strategy != exports.Z_HUFFMAN_ONLY &amp;&amp; strategy != exports.Z_RLE &amp;&amp; strategy != exports.Z_FIXED &amp;&amp; strategy != exports.Z_DEFAULT_STRATEGY) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Invalid strategy: '</span> + strategy);
  }

  <span class="keyword">if</span> (<span class="keyword">this</span>._level !== level || <span class="keyword">this</span>._strategy !== strategy) {
    <span class="keyword">var</span> self = <span class="keyword">this</span>;
    <span class="keyword">this</span>.flush(binding.Z_SYNC_FLUSH, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      assert(self._handle, <span class="string">'zlib binding closed'</span>);
      self._handle.params(level, strategy);
      <span class="keyword">if</span> (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        <span class="keyword">if</span> (callback) callback();
      }
    });
  } <span class="keyword">else</span> {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  assert(<span class="keyword">this</span>._handle, <span class="string">'zlib binding closed'</span>);
  <span class="keyword">return</span> <span class="keyword">this</span>._handle.reset();
};

<span class="comment">// This is the _flush function called by the transform class,</span>
<span class="comment">// internally, when the last chunk has been written.</span>
Zlib.prototype._flush = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
  <span class="keyword">this</span>._transform(Buffer.alloc(<span class="number">0</span>), <span class="string">''</span>, callback);
};

Zlib.prototype.flush = <span class="function"><span class="keyword">function</span> <span class="params">(kind, callback)</span> {</span>
  <span class="keyword">var</span> _this2 = <span class="keyword">this</span>;

  <span class="keyword">var</span> ws = <span class="keyword">this</span>._writableState;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> kind === <span class="string">'function'</span> || kind === <span class="literal">undefined</span> &amp;&amp; !callback) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  <span class="keyword">if</span> (ws.ended) {
    <span class="keyword">if</span> (callback) process.nextTick(callback);
  } <span class="keyword">else</span> <span class="keyword">if</span> (ws.ending) {
    <span class="keyword">if</span> (callback) <span class="keyword">this</span>.once(<span class="string">'end'</span>, callback);
  } <span class="keyword">else</span> <span class="keyword">if</span> (ws.needDrain) {
    <span class="keyword">if</span> (callback) {
      <span class="keyword">this</span>.once(<span class="string">'drain'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> _this2.flush(kind, callback);
      });
    }
  } <span class="keyword">else</span> {
    <span class="keyword">this</span>._flushFlag = kind;
    <span class="keyword">this</span>.write(Buffer.alloc(<span class="number">0</span>), <span class="string">''</span>, callback);
  }
};

Zlib.prototype.close = <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> {</span>
  _close(<span class="keyword">this</span>, callback);
  process.nextTick(emitCloseNT, <span class="keyword">this</span>);
};

<span class="function"><span class="keyword">function</span> <span class="title">_close</span><span class="params">(engine, callback)</span> {</span>
  <span class="keyword">if</span> (callback) process.nextTick(callback);

  <span class="comment">// Caller may invoke .close after a zlib error (which will null _handle).</span>
  <span class="keyword">if</span> (!engine._handle) <span class="keyword">return</span>;

  engine._handle.close();
  engine._handle = <span class="literal">null</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">emitCloseNT</span><span class="params">(self)</span> {</span>
  self.emit(<span class="string">'close'</span>);
}

Zlib.prototype._transform = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding, cb)</span> {</span>
  <span class="keyword">var</span> flushFlag;
  <span class="keyword">var</span> ws = <span class="keyword">this</span>._writableState;
  <span class="keyword">var</span> ending = ws.ending || ws.ended;
  <span class="keyword">var</span> last = ending &amp;&amp; (!chunk || ws.length === chunk.length);

  <span class="keyword">if</span> (chunk !== <span class="literal">null</span> &amp;&amp; !Buffer.isBuffer(chunk)) <span class="keyword">return</span> cb(<span class="keyword">new</span> Error(<span class="string">'invalid input'</span>));

  <span class="keyword">if</span> (!<span class="keyword">this</span>._handle) <span class="keyword">return</span> cb(<span class="keyword">new</span> Error(<span class="string">'zlib binding closed'</span>));

  <span class="comment">// If it's the last chunk, or a final flush, we use the Z_FINISH flush flag</span>
  <span class="comment">// (or whatever flag was provided using opts.finishFlush).</span>
  <span class="comment">// If it's explicitly flushing at some other time, then we use</span>
  <span class="comment">// Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression</span>
  <span class="comment">// goodness.</span>
  <span class="keyword">if</span> (last) flushFlag = <span class="keyword">this</span>._finishFlushFlag;<span class="keyword">else</span> {
    flushFlag = <span class="keyword">this</span>._flushFlag;
    <span class="comment">// once we've flushed the last of the queue, stop flushing and</span>
    <span class="comment">// go back to the normal behavior.</span>
    <span class="keyword">if</span> (chunk.length >= ws.length) {
      <span class="keyword">this</span>._flushFlag = <span class="keyword">this</span>._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  <span class="keyword">this</span>._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, flushFlag, cb)</span> {</span>
  <span class="keyword">var</span> availInBefore = chunk &amp;&amp; chunk.length;
  <span class="keyword">var</span> availOutBefore = <span class="keyword">this</span>._chunkSize - <span class="keyword">this</span>._offset;
  <span class="keyword">var</span> inOff = <span class="number">0</span>;

  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="keyword">var</span> async = <span class="keyword">typeof</span> cb === <span class="string">'function'</span>;

  <span class="keyword">if</span> (!async) {
    <span class="keyword">var</span> buffers = [];
    <span class="keyword">var</span> nread = <span class="number">0</span>;

    <span class="keyword">var</span> error;
    <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(er)</span> {</span>
      error = er;
    });

    assert(<span class="keyword">this</span>._handle, <span class="string">'zlib binding closed'</span>);
    <span class="keyword">do</span> {
      <span class="keyword">var</span> res = <span class="keyword">this</span>._handle.writeSync(flushFlag, chunk, <span class="comment">// in</span>
      inOff, <span class="comment">// in_off</span>
      availInBefore, <span class="comment">// in_len</span>
      <span class="keyword">this</span>._buffer, <span class="comment">// out</span>
      <span class="keyword">this</span>._offset, <span class="comment">//out_off</span>
      availOutBefore); <span class="comment">// out_len</span>
    } <span class="keyword">while</span> (!<span class="keyword">this</span>._hadError &amp;&amp; callback(res[<span class="number">0</span>], res[<span class="number">1</span>]));

    <span class="keyword">if</span> (<span class="keyword">this</span>._hadError) {
      <span class="keyword">throw</span> error;
    }

    <span class="keyword">if</span> (nread >= kMaxLength) {
      _close(<span class="keyword">this</span>);
      <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(kRangeErrorMessage);
    }

    <span class="keyword">var</span> buf = Buffer.concat(buffers, nread);
    _close(<span class="keyword">this</span>);

    <span class="keyword">return</span> buf;
  }

  assert(<span class="keyword">this</span>._handle, <span class="string">'zlib binding closed'</span>);
  <span class="keyword">var</span> req = <span class="keyword">this</span>._handle.write(flushFlag, chunk, <span class="comment">// in</span>
  inOff, <span class="comment">// in_off</span>
  availInBefore, <span class="comment">// in_len</span>
  <span class="keyword">this</span>._buffer, <span class="comment">// out</span>
  <span class="keyword">this</span>._offset, <span class="comment">//out_off</span>
  availOutBefore); <span class="comment">// out_len</span>

  req.buffer = chunk;
  req.callback = callback;

  <span class="function"><span class="keyword">function</span> <span class="title">callback</span><span class="params">(availInAfter, availOutAfter)</span> {</span>
    <span class="comment">// When the callback is used in an async write, the callback's</span>
    <span class="comment">// context is the `req` object that was created. The req object</span>
    <span class="comment">// is === this._handle, and that's why it's important to null</span>
    <span class="comment">// out the values after they are done being used. `this._handle`</span>
    <span class="comment">// can stay in memory longer than the callback and buffer are needed.</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>) {
      <span class="keyword">this</span>.buffer = <span class="literal">null</span>;
      <span class="keyword">this</span>.callback = <span class="literal">null</span>;
    }

    <span class="keyword">if</span> (self._hadError) <span class="keyword">return</span>;

    <span class="keyword">var</span> have = availOutBefore - availOutAfter;
    assert(have >= <span class="number">0</span>, <span class="string">'have should not go down'</span>);

    <span class="keyword">if</span> (have > <span class="number">0</span>) {
      <span class="keyword">var</span> out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      <span class="comment">// serve some output to the consumer.</span>
      <span class="keyword">if</span> (async) {
        self.push(out);
      } <span class="keyword">else</span> {
        buffers.push(out);
        nread += out.length;
      }
    }

    <span class="comment">// exhausted the output buffer, or used all the input create a new one.</span>
    <span class="keyword">if</span> (availOutAfter === <span class="number">0</span> || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = <span class="number">0</span>;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    <span class="keyword">if</span> (availOutAfter === <span class="number">0</span>) {
      <span class="comment">// Not actually done.  Need to reprocess.</span>
      <span class="comment">// Also, update the availInBefore to the availInAfter value,</span>
      <span class="comment">// so that if we have to hit it a third (fourth, etc.) time,</span>
      <span class="comment">// it'll have the correct byte counts.</span>
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;

      <span class="keyword">if</span> (!async) <span class="keyword">return</span> <span class="literal">true</span>;

      <span class="keyword">var</span> newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
      newReq.callback = callback; <span class="comment">// this same function</span>
      newReq.buffer = chunk;
      <span class="keyword">return</span>;
    }

    <span class="keyword">if</span> (!async) <span class="keyword">return</span> <span class="literal">false</span>;

    <span class="comment">// finished with the chunk.</span>
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);</code></pre>