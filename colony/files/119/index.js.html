<h1>index.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> <span class="literal">undefined</span> = (<span class="keyword">void</span> <span class="number">0</span>); <span class="comment">// Paranoia</span>

<span class="comment">// Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to</span>
<span class="comment">// create, and consume so much memory, that the browser appears frozen.</span>
<span class="keyword">var</span> MAX_ARRAY_LENGTH = <span class="number">1e5</span>;

<span class="comment">// Approximations of internal ECMAScript conversion functions</span>
<span class="keyword">var</span> ECMAScript = (<span class="keyword">function</span>() {
  <span class="comment">// Stash a copy in case other scripts modify these</span>
  <span class="keyword">var</span> opts = Object.prototype.toString,
      ophop = Object.prototype.hasOwnProperty;

  <span class="keyword">return</span> {
    <span class="comment">// Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:</span>
    Class: <span class="keyword">function</span>(v) { <span class="keyword">return</span> opts.call(v).replace(<span class="regexp">/^\[object *|\]$/g</span>, <span class="string">''</span>); },
    HasProperty: <span class="keyword">function</span>(o, p) { <span class="keyword">return</span> p <span class="keyword">in</span> o; },
    HasOwnProperty: <span class="keyword">function</span>(o, p) { <span class="keyword">return</span> ophop.call(o, p); },
    IsCallable: <span class="keyword">function</span>(o) { <span class="keyword">return</span> <span class="keyword">typeof</span> o === <span class="string">'function'</span>; },
    ToInt32: <span class="keyword">function</span>(v) { <span class="keyword">return</span> v >> <span class="number">0</span>; },
    ToUint32: <span class="keyword">function</span>(v) { <span class="keyword">return</span> v >>> <span class="number">0</span>; }
  };
}());

<span class="comment">// Snapshot intrinsics</span>
<span class="keyword">var</span> LN2 = Math.LN2,
    abs = Math.abs,
    floor = Math.floor,
    log = Math.log,
    min = Math.min,
    pow = Math.pow,
    round = Math.round;

<span class="comment">// ES5: lock down object properties</span>
<span class="function"><span class="keyword">function</span> <span class="title">configureProperties</span><span class="params">(obj)</span> {</span>
  <span class="keyword">if</span> (getOwnPropNames &amp;&amp; defineProp) {
    <span class="keyword">var</span> props = getOwnPropNames(obj), i;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; props.length; i += <span class="number">1</span>) {
      defineProp(obj, props[i], {
        value: obj[props[i]],
        writable: <span class="literal">false</span>,
        enumerable: <span class="literal">false</span>,
        configurable: <span class="literal">false</span>
      });
    }
  }
}

<span class="comment">// emulate ES5 getter/setter API using legacy APIs</span>
<span class="comment">// http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx</span>
<span class="comment">// (second clause tests for Object.defineProperty() in IE&lt;9 that only supports extending DOM prototypes, but</span>
<span class="comment">// note that IE&lt;9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)</span>
<span class="keyword">var</span> defineProp
<span class="keyword">if</span> (Object.defineProperty &amp;&amp; (<span class="keyword">function</span>() {
      <span class="keyword">try</span> {
        Object.defineProperty({}, <span class="string">'x'</span>, {});
        <span class="keyword">return</span> <span class="literal">true</span>;
      } <span class="keyword">catch</span> (e) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }
    })()) {
  defineProp = Object.defineProperty;
} <span class="keyword">else</span> {
  defineProp = <span class="keyword">function</span>(o, p, desc) {
    <span class="keyword">if</span> (!o === Object(o)) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"Object.defineProperty called on non-object"</span>);
    <span class="keyword">if</span> (ECMAScript.HasProperty(desc, <span class="string">'get'</span>) &amp;&amp; Object.prototype.__defineGetter__) { Object.prototype.__defineGetter__.call(o, p, desc.get); }
    <span class="keyword">if</span> (ECMAScript.HasProperty(desc, <span class="string">'set'</span>) &amp;&amp; Object.prototype.__defineSetter__) { Object.prototype.__defineSetter__.call(o, p, desc.set); }
    <span class="keyword">if</span> (ECMAScript.HasProperty(desc, <span class="string">'value'</span>)) { o[p] = desc.value; }
    <span class="keyword">return</span> o;
  };
}

<span class="keyword">var</span> getOwnPropNames = Object.getOwnPropertyNames || <span class="function"><span class="keyword">function</span> <span class="params">(o)</span> {</span>
  <span class="keyword">if</span> (o !== Object(o)) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"Object.getOwnPropertyNames called on non-object"</span>);
  <span class="keyword">var</span> props = [], p;
  <span class="keyword">for</span> (p <span class="keyword">in</span> o) {
    <span class="keyword">if</span> (ECMAScript.HasOwnProperty(o, p)) {
      props.push(p);
    }
  }
  <span class="keyword">return</span> props;
};

<span class="comment">// ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)</span>
<span class="comment">// for index in 0 ... obj.length</span>
<span class="function"><span class="keyword">function</span> <span class="title">makeArrayAccessors</span><span class="params">(obj)</span> {</span>
  <span class="keyword">if</span> (!defineProp) { <span class="keyword">return</span>; }

  <span class="keyword">if</span> (obj.length > MAX_ARRAY_LENGTH) <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"Array too large for polyfill"</span>);

  <span class="function"><span class="keyword">function</span> <span class="title">makeArrayAccessor</span><span class="params">(index)</span> {</span>
    defineProp(obj, index, {
      <span class="string">'get'</span>: <span class="keyword">function</span>() { <span class="keyword">return</span> obj._getter(index); },
      <span class="string">'set'</span>: <span class="keyword">function</span>(v) { obj._setter(index, v); },
      enumerable: <span class="literal">true</span>,
      configurable: <span class="literal">false</span>
    });
  }

  <span class="keyword">var</span> i;
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; obj.length; i += <span class="number">1</span>) {
    makeArrayAccessor(i);
  }
}

<span class="comment">// Internal conversion functions:</span>
<span class="comment">//    pack&lt;Type>()   - take a number (interpreted as Type), output a byte array</span>
<span class="comment">//    unpack&lt;Type>() - take a byte array, output a Type-like number</span>

<span class="function"><span class="keyword">function</span> <span class="title">as_signed</span><span class="params">(value, bits)</span> {</span> <span class="keyword">var</span> s = <span class="number">32</span> - bits; <span class="keyword">return</span> (value &lt;&lt; s) >> s; }
<span class="function"><span class="keyword">function</span> <span class="title">as_unsigned</span><span class="params">(value, bits)</span> {</span> <span class="keyword">var</span> s = <span class="number">32</span> - bits; <span class="keyword">return</span> (value &lt;&lt; s) >>> s; }

<span class="function"><span class="keyword">function</span> <span class="title">packI8</span><span class="params">(n)</span> {</span> <span class="keyword">return</span> [n &amp; <span class="number">0xff</span>]; }
<span class="function"><span class="keyword">function</span> <span class="title">unpackI8</span><span class="params">(bytes)</span> {</span> <span class="keyword">return</span> as_signed(bytes[<span class="number">0</span>], <span class="number">8</span>); }

<span class="function"><span class="keyword">function</span> <span class="title">packU8</span><span class="params">(n)</span> {</span> <span class="keyword">return</span> [n &amp; <span class="number">0xff</span>]; }
<span class="function"><span class="keyword">function</span> <span class="title">unpackU8</span><span class="params">(bytes)</span> {</span> <span class="keyword">return</span> as_unsigned(bytes[<span class="number">0</span>], <span class="number">8</span>); }

<span class="function"><span class="keyword">function</span> <span class="title">packU8Clamped</span><span class="params">(n)</span> {</span> n = round(Number(n)); <span class="keyword">return</span> [n &lt; <span class="number">0</span> ? <span class="number">0</span> : n > <span class="number">0xff</span> ? <span class="number">0xff</span> : n &amp; <span class="number">0xff</span>]; }

<span class="function"><span class="keyword">function</span> <span class="title">packI16</span><span class="params">(n)</span> {</span> <span class="keyword">return</span> [(n >> <span class="number">8</span>) &amp; <span class="number">0xff</span>, n &amp; <span class="number">0xff</span>]; }
<span class="function"><span class="keyword">function</span> <span class="title">unpackI16</span><span class="params">(bytes)</span> {</span> <span class="keyword">return</span> as_signed(bytes[<span class="number">0</span>] &lt;&lt; <span class="number">8</span> | bytes[<span class="number">1</span>], <span class="number">16</span>); }

<span class="function"><span class="keyword">function</span> <span class="title">packU16</span><span class="params">(n)</span> {</span> <span class="keyword">return</span> [(n >> <span class="number">8</span>) &amp; <span class="number">0xff</span>, n &amp; <span class="number">0xff</span>]; }
<span class="function"><span class="keyword">function</span> <span class="title">unpackU16</span><span class="params">(bytes)</span> {</span> <span class="keyword">return</span> as_unsigned(bytes[<span class="number">0</span>] &lt;&lt; <span class="number">8</span> | bytes[<span class="number">1</span>], <span class="number">16</span>); }

<span class="function"><span class="keyword">function</span> <span class="title">packI32</span><span class="params">(n)</span> {</span> <span class="keyword">return</span> [(n >> <span class="number">24</span>) &amp; <span class="number">0xff</span>, (n >> <span class="number">16</span>) &amp; <span class="number">0xff</span>, (n >> <span class="number">8</span>) &amp; <span class="number">0xff</span>, n &amp; <span class="number">0xff</span>]; }
<span class="function"><span class="keyword">function</span> <span class="title">unpackI32</span><span class="params">(bytes)</span> {</span> <span class="keyword">return</span> as_signed(bytes[<span class="number">0</span>] &lt;&lt; <span class="number">24</span> | bytes[<span class="number">1</span>] &lt;&lt; <span class="number">16</span> | bytes[<span class="number">2</span>] &lt;&lt; <span class="number">8</span> | bytes[<span class="number">3</span>], <span class="number">32</span>); }

<span class="function"><span class="keyword">function</span> <span class="title">packU32</span><span class="params">(n)</span> {</span> <span class="keyword">return</span> [(n >> <span class="number">24</span>) &amp; <span class="number">0xff</span>, (n >> <span class="number">16</span>) &amp; <span class="number">0xff</span>, (n >> <span class="number">8</span>) &amp; <span class="number">0xff</span>, n &amp; <span class="number">0xff</span>]; }
<span class="function"><span class="keyword">function</span> <span class="title">unpackU32</span><span class="params">(bytes)</span> {</span> <span class="keyword">return</span> as_unsigned(bytes[<span class="number">0</span>] &lt;&lt; <span class="number">24</span> | bytes[<span class="number">1</span>] &lt;&lt; <span class="number">16</span> | bytes[<span class="number">2</span>] &lt;&lt; <span class="number">8</span> | bytes[<span class="number">3</span>], <span class="number">32</span>); }

<span class="function"><span class="keyword">function</span> <span class="title">packIEEE754</span><span class="params">(v, ebits, fbits)</span> {</span>

  <span class="keyword">var</span> bias = (<span class="number">1</span> &lt;&lt; (ebits - <span class="number">1</span>)) - <span class="number">1</span>,
      s, e, f, ln,
      i, bits, str, bytes;

  <span class="function"><span class="keyword">function</span> <span class="title">roundToEven</span><span class="params">(n)</span> {</span>
    <span class="keyword">var</span> w = floor(n), f = n - w;
    <span class="keyword">if</span> (f &lt; <span class="number">0.5</span>)
      <span class="keyword">return</span> w;
    <span class="keyword">if</span> (f > <span class="number">0.5</span>)
      <span class="keyword">return</span> w + <span class="number">1</span>;
    <span class="keyword">return</span> w % <span class="number">2</span> ? w + <span class="number">1</span> : w;
  }

  <span class="comment">// Compute sign, exponent, fraction</span>
  <span class="keyword">if</span> (v !== v) {
    <span class="comment">// NaN</span>
    <span class="comment">// http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping</span>
    e = (<span class="number">1</span> &lt;&lt; ebits) - <span class="number">1</span>; f = pow(<span class="number">2</span>, fbits - <span class="number">1</span>); s = <span class="number">0</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (v === <span class="literal">Infinity</span> || v === -<span class="literal">Infinity</span>) {
    e = (<span class="number">1</span> &lt;&lt; ebits) - <span class="number">1</span>; f = <span class="number">0</span>; s = (v &lt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (v === <span class="number">0</span>) {
    e = <span class="number">0</span>; f = <span class="number">0</span>; s = (<span class="number">1</span> / v === -<span class="literal">Infinity</span>) ? <span class="number">1</span> : <span class="number">0</span>;
  } <span class="keyword">else</span> {
    s = v &lt; <span class="number">0</span>;
    v = abs(v);

    <span class="keyword">if</span> (v >= pow(<span class="number">2</span>, <span class="number">1</span> - bias)) {
      e = min(floor(log(v) / LN2), <span class="number">1023</span>);
      f = roundToEven(v / pow(<span class="number">2</span>, e) * pow(<span class="number">2</span>, fbits));
      <span class="keyword">if</span> (f / pow(<span class="number">2</span>, fbits) >= <span class="number">2</span>) {
        e = e + <span class="number">1</span>;
        f = <span class="number">1</span>;
      }
      <span class="keyword">if</span> (e > bias) {
        <span class="comment">// Overflow</span>
        e = (<span class="number">1</span> &lt;&lt; ebits) - <span class="number">1</span>;
        f = <span class="number">0</span>;
      } <span class="keyword">else</span> {
        <span class="comment">// Normalized</span>
        e = e + bias;
        f = f - pow(<span class="number">2</span>, fbits);
      }
    } <span class="keyword">else</span> {
      <span class="comment">// Denormalized</span>
      e = <span class="number">0</span>;
      f = roundToEven(v / pow(<span class="number">2</span>, <span class="number">1</span> - bias - fbits));
    }
  }

  <span class="comment">// Pack sign, exponent, fraction</span>
  bits = [];
  <span class="keyword">for</span> (i = fbits; i; i -= <span class="number">1</span>) { bits.push(f % <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>); f = floor(f / <span class="number">2</span>); }
  <span class="keyword">for</span> (i = ebits; i; i -= <span class="number">1</span>) { bits.push(e % <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>); e = floor(e / <span class="number">2</span>); }
  bits.push(s ? <span class="number">1</span> : <span class="number">0</span>);
  bits.reverse();
  str = bits.join(<span class="string">''</span>);

  <span class="comment">// Bits to bytes</span>
  bytes = [];
  <span class="keyword">while</span> (str.length) {
    bytes.push(parseInt(str.substring(<span class="number">0</span>, <span class="number">8</span>), <span class="number">2</span>));
    str = str.substring(<span class="number">8</span>);
  }
  <span class="keyword">return</span> bytes;
}

<span class="function"><span class="keyword">function</span> <span class="title">unpackIEEE754</span><span class="params">(bytes, ebits, fbits)</span> {</span>

  <span class="comment">// Bytes to bits</span>
  <span class="keyword">var</span> bits = [], i, j, b, str,
      bias, s, e, f;

  <span class="keyword">for</span> (i = bytes.length; i; i -= <span class="number">1</span>) {
    b = bytes[i - <span class="number">1</span>];
    <span class="keyword">for</span> (j = <span class="number">8</span>; j; j -= <span class="number">1</span>) {
      bits.push(b % <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>); b = b >> <span class="number">1</span>;
    }
  }
  bits.reverse();
  str = bits.join(<span class="string">''</span>);

  <span class="comment">// Unpack sign, exponent, fraction</span>
  bias = (<span class="number">1</span> &lt;&lt; (ebits - <span class="number">1</span>)) - <span class="number">1</span>;
  s = parseInt(str.substring(<span class="number">0</span>, <span class="number">1</span>), <span class="number">2</span>) ? -<span class="number">1</span> : <span class="number">1</span>;
  e = parseInt(str.substring(<span class="number">1</span>, <span class="number">1</span> + ebits), <span class="number">2</span>);
  f = parseInt(str.substring(<span class="number">1</span> + ebits), <span class="number">2</span>);

  <span class="comment">// Produce number</span>
  <span class="keyword">if</span> (e === (<span class="number">1</span> &lt;&lt; ebits) - <span class="number">1</span>) {
    <span class="keyword">return</span> f !== <span class="number">0</span> ? <span class="literal">NaN</span> : s * <span class="literal">Infinity</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (e > <span class="number">0</span>) {
    <span class="comment">// Normalized</span>
    <span class="keyword">return</span> s * pow(<span class="number">2</span>, e - bias) * (<span class="number">1</span> + f / pow(<span class="number">2</span>, fbits));
  } <span class="keyword">else</span> <span class="keyword">if</span> (f !== <span class="number">0</span>) {
    <span class="comment">// Denormalized</span>
    <span class="keyword">return</span> s * pow(<span class="number">2</span>, -(bias - <span class="number">1</span>)) * (f / pow(<span class="number">2</span>, fbits));
  } <span class="keyword">else</span> {
    <span class="keyword">return</span> s &lt; <span class="number">0</span> ? -<span class="number">0</span> : <span class="number">0</span>;
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">unpackF64</span><span class="params">(b)</span> {</span> <span class="keyword">return</span> unpackIEEE754(b, <span class="number">11</span>, <span class="number">52</span>); }
<span class="function"><span class="keyword">function</span> <span class="title">packF64</span><span class="params">(v)</span> {</span> <span class="keyword">return</span> packIEEE754(v, <span class="number">11</span>, <span class="number">52</span>); }
<span class="function"><span class="keyword">function</span> <span class="title">unpackF32</span><span class="params">(b)</span> {</span> <span class="keyword">return</span> unpackIEEE754(b, <span class="number">8</span>, <span class="number">23</span>); }
<span class="function"><span class="keyword">function</span> <span class="title">packF32</span><span class="params">(v)</span> {</span> <span class="keyword">return</span> packIEEE754(v, <span class="number">8</span>, <span class="number">23</span>); }


<span class="comment">//</span>
<span class="comment">// 3 The ArrayBuffer Type</span>
<span class="comment">//</span>

(<span class="keyword">function</span>() {

  <span class="comment">/** @constructor */</span>
  <span class="keyword">var</span> ArrayBuffer = <span class="function"><span class="keyword">function</span> <span class="title">ArrayBuffer</span><span class="params">(length)</span> {</span>
    length = ECMAScript.ToInt32(length);
    <span class="keyword">if</span> (length &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">'ArrayBuffer size is not a small enough positive integer'</span>);

    <span class="keyword">this</span>.byteLength = length;
    <span class="keyword">this</span>._bytes = [];
    <span class="keyword">this</span>._bytes.length = length;

    <span class="keyword">var</span> i;
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.byteLength; i += <span class="number">1</span>) {
      <span class="keyword">this</span>._bytes[i] = <span class="number">0</span>;
    }

    configureProperties(<span class="keyword">this</span>);
  };

  exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer;

  <span class="comment">//</span>
  <span class="comment">// 4 The ArrayBufferView Type</span>
  <span class="comment">//</span>

  <span class="comment">// NOTE: this constructor is not exported</span>
  <span class="comment">/** @constructor */</span>
  <span class="keyword">var</span> ArrayBufferView = <span class="function"><span class="keyword">function</span> <span class="title">ArrayBufferView</span><span class="params">()</span> {</span>
    <span class="comment">//this.buffer = null;</span>
    <span class="comment">//this.byteOffset = 0;</span>
    <span class="comment">//this.byteLength = 0;</span>
  };

  <span class="comment">//</span>
  <span class="comment">// 5 The Typed Array View Types</span>
  <span class="comment">//</span>

  <span class="function"><span class="keyword">function</span> <span class="title">makeConstructor</span><span class="params">(bytesPerElement, pack, unpack)</span> {</span>
    <span class="comment">// Each TypedArray type requires a distinct constructor instance with</span>
    <span class="comment">// identical logic, which this produces.</span>

    <span class="keyword">var</span> ctor;
    ctor = <span class="keyword">function</span>(buffer, byteOffset, length) {
      <span class="keyword">var</span> array, sequence, i, s;

      <span class="keyword">if</span> (!arguments.length || <span class="keyword">typeof</span> arguments[<span class="number">0</span>] === <span class="string">'number'</span>) {
        <span class="comment">// Constructor(unsigned long length)</span>
        <span class="keyword">this</span>.length = ECMAScript.ToInt32(arguments[<span class="number">0</span>]);
        <span class="keyword">if</span> (length &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">'ArrayBufferView size is not a small enough positive integer'</span>);

        <span class="keyword">this</span>.byteLength = <span class="keyword">this</span>.length * <span class="keyword">this</span>.BYTES_PER_ELEMENT;
        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> ArrayBuffer(<span class="keyword">this</span>.byteLength);
        <span class="keyword">this</span>.byteOffset = <span class="number">0</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] === <span class="string">'object'</span> &amp;&amp; arguments[<span class="number">0</span>].constructor === ctor) {
        <span class="comment">// Constructor(TypedArray array)</span>
        array = arguments[<span class="number">0</span>];

        <span class="keyword">this</span>.length = array.length;
        <span class="keyword">this</span>.byteLength = <span class="keyword">this</span>.length * <span class="keyword">this</span>.BYTES_PER_ELEMENT;
        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> ArrayBuffer(<span class="keyword">this</span>.byteLength);
        <span class="keyword">this</span>.byteOffset = <span class="number">0</span>;

        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i += <span class="number">1</span>) {
          <span class="keyword">this</span>._setter(i, array._getter(i));
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] === <span class="string">'object'</span> &amp;&amp;
                 !(arguments[<span class="number">0</span>] <span class="keyword">instanceof</span> ArrayBuffer || ECMAScript.Class(arguments[<span class="number">0</span>]) === <span class="string">'ArrayBuffer'</span>)) {
        <span class="comment">// Constructor(sequence&lt;type> array)</span>
        sequence = arguments[<span class="number">0</span>];

        <span class="keyword">this</span>.length = ECMAScript.ToUint32(sequence.length);
        <span class="keyword">this</span>.byteLength = <span class="keyword">this</span>.length * <span class="keyword">this</span>.BYTES_PER_ELEMENT;
        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> ArrayBuffer(<span class="keyword">this</span>.byteLength);
        <span class="keyword">this</span>.byteOffset = <span class="number">0</span>;

        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i += <span class="number">1</span>) {
          s = sequence[i];
          <span class="keyword">this</span>._setter(i, Number(s));
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] === <span class="string">'object'</span> &amp;&amp;
                 (arguments[<span class="number">0</span>] <span class="keyword">instanceof</span> ArrayBuffer || ECMAScript.Class(arguments[<span class="number">0</span>]) === <span class="string">'ArrayBuffer'</span>)) {
        <span class="comment">// Constructor(ArrayBuffer buffer,</span>
        <span class="comment">//             optional unsigned long byteOffset, optional unsigned long length)</span>
        <span class="keyword">this</span>.buffer = buffer;

        <span class="keyword">this</span>.byteOffset = ECMAScript.ToUint32(byteOffset);
        <span class="keyword">if</span> (<span class="keyword">this</span>.byteOffset > <span class="keyword">this</span>.buffer.byteLength) {
          <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"byteOffset out of range"</span>);
        }

        <span class="keyword">if</span> (<span class="keyword">this</span>.byteOffset % <span class="keyword">this</span>.BYTES_PER_ELEMENT) {
          <span class="comment">// The given byteOffset must be a multiple of the element</span>
          <span class="comment">// size of the specific type, otherwise an exception is raised.</span>
          <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"ArrayBuffer length minus the byteOffset is not a multiple of the element size."</span>);
        }

        <span class="keyword">if</span> (arguments.length &lt; <span class="number">3</span>) {
          <span class="keyword">this</span>.byteLength = <span class="keyword">this</span>.buffer.byteLength - <span class="keyword">this</span>.byteOffset;

          <span class="keyword">if</span> (<span class="keyword">this</span>.byteLength % <span class="keyword">this</span>.BYTES_PER_ELEMENT) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"length of buffer minus byteOffset not a multiple of the element size"</span>);
          }
          <span class="keyword">this</span>.length = <span class="keyword">this</span>.byteLength / <span class="keyword">this</span>.BYTES_PER_ELEMENT;
        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.length = ECMAScript.ToUint32(length);
          <span class="keyword">this</span>.byteLength = <span class="keyword">this</span>.length * <span class="keyword">this</span>.BYTES_PER_ELEMENT;
        }

        <span class="keyword">if</span> ((<span class="keyword">this</span>.byteOffset + <span class="keyword">this</span>.byteLength) > <span class="keyword">this</span>.buffer.byteLength) {
          <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"byteOffset and length reference an area beyond the end of the buffer"</span>);
        }
      } <span class="keyword">else</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"Unexpected argument type(s)"</span>);
      }

      <span class="keyword">this</span>.constructor = ctor;

      configureProperties(<span class="keyword">this</span>);
      makeArrayAccessors(<span class="keyword">this</span>);
    };

    ctor.prototype = <span class="keyword">new</span> ArrayBufferView();
    ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
    ctor.prototype._pack = pack;
    ctor.prototype._unpack = unpack;
    ctor.BYTES_PER_ELEMENT = bytesPerElement;

    <span class="comment">// getter type (unsigned long index);</span>
    ctor.prototype._getter = <span class="keyword">function</span>(index) {
      <span class="keyword">if</span> (arguments.length &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string">"Not enough arguments"</span>);

      index = ECMAScript.ToUint32(index);
      <span class="keyword">if</span> (index >= <span class="keyword">this</span>.length) {
        <span class="keyword">return</span> <span class="literal">undefined</span>;
      }

      <span class="keyword">var</span> bytes = [], i, o;
      <span class="keyword">for</span> (i = <span class="number">0</span>, o = <span class="keyword">this</span>.byteOffset + index * <span class="keyword">this</span>.BYTES_PER_ELEMENT;
           i &lt; <span class="keyword">this</span>.BYTES_PER_ELEMENT;
           i += <span class="number">1</span>, o += <span class="number">1</span>) {
        bytes.push(<span class="keyword">this</span>.buffer._bytes[o]);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>._unpack(bytes);
    };

    <span class="comment">// NONSTANDARD: convenience alias for getter: type get(unsigned long index);</span>
    ctor.prototype.get = ctor.prototype._getter;

    <span class="comment">// setter void (unsigned long index, type value);</span>
    ctor.prototype._setter = <span class="keyword">function</span>(index, value) {
      <span class="keyword">if</span> (arguments.length &lt; <span class="number">2</span>) <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string">"Not enough arguments"</span>);

      index = ECMAScript.ToUint32(index);
      <span class="keyword">if</span> (index >= <span class="keyword">this</span>.length) {
        <span class="keyword">return</span> <span class="literal">undefined</span>;
      }

      <span class="keyword">var</span> bytes = <span class="keyword">this</span>._pack(value), i, o;
      <span class="keyword">for</span> (i = <span class="number">0</span>, o = <span class="keyword">this</span>.byteOffset + index * <span class="keyword">this</span>.BYTES_PER_ELEMENT;
           i &lt; <span class="keyword">this</span>.BYTES_PER_ELEMENT;
           i += <span class="number">1</span>, o += <span class="number">1</span>) {
        <span class="keyword">this</span>.buffer._bytes[o] = bytes[i];
      }
    };

    <span class="comment">// void set(TypedArray array, optional unsigned long offset);</span>
    <span class="comment">// void set(sequence&lt;type> array, optional unsigned long offset);</span>
    ctor.prototype.set = <span class="keyword">function</span>(index, value) {
      <span class="keyword">if</span> (arguments.length &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string">"Not enough arguments"</span>);
      <span class="keyword">var</span> array, sequence, offset, len,
          i, s, d,
          byteOffset, byteLength, tmp;

      <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] === <span class="string">'object'</span> &amp;&amp; arguments[<span class="number">0</span>].constructor === <span class="keyword">this</span>.constructor) {
        <span class="comment">// void set(TypedArray array, optional unsigned long offset);</span>
        array = arguments[<span class="number">0</span>];
        offset = ECMAScript.ToUint32(arguments[<span class="number">1</span>]);

        <span class="keyword">if</span> (offset + array.length > <span class="keyword">this</span>.length) {
          <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"Offset plus length of array is out of range"</span>);
        }

        byteOffset = <span class="keyword">this</span>.byteOffset + offset * <span class="keyword">this</span>.BYTES_PER_ELEMENT;
        byteLength = array.length * <span class="keyword">this</span>.BYTES_PER_ELEMENT;

        <span class="keyword">if</span> (array.buffer === <span class="keyword">this</span>.buffer) {
          tmp = [];
          <span class="keyword">for</span> (i = <span class="number">0</span>, s = array.byteOffset; i &lt; byteLength; i += <span class="number">1</span>, s += <span class="number">1</span>) {
            tmp[i] = array.buffer._bytes[s];
          }
          <span class="keyword">for</span> (i = <span class="number">0</span>, d = byteOffset; i &lt; byteLength; i += <span class="number">1</span>, d += <span class="number">1</span>) {
            <span class="keyword">this</span>.buffer._bytes[d] = tmp[i];
          }
        } <span class="keyword">else</span> {
          <span class="keyword">for</span> (i = <span class="number">0</span>, s = array.byteOffset, d = byteOffset;
               i &lt; byteLength; i += <span class="number">1</span>, s += <span class="number">1</span>, d += <span class="number">1</span>) {
            <span class="keyword">this</span>.buffer._bytes[d] = array.buffer._bytes[s];
          }
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> arguments[<span class="number">0</span>].length !== <span class="string">'undefined'</span>) {
        <span class="comment">// void set(sequence&lt;type> array, optional unsigned long offset);</span>
        sequence = arguments[<span class="number">0</span>];
        len = ECMAScript.ToUint32(sequence.length);
        offset = ECMAScript.ToUint32(arguments[<span class="number">1</span>]);

        <span class="keyword">if</span> (offset + len > <span class="keyword">this</span>.length) {
          <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"Offset plus length of array is out of range"</span>);
        }

        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) {
          s = sequence[i];
          <span class="keyword">this</span>._setter(offset + i, Number(s));
        }
      } <span class="keyword">else</span> {
        <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"Unexpected argument type(s)"</span>);
      }
    };

    <span class="comment">// TypedArray subarray(long begin, optional long end);</span>
    ctor.prototype.subarray = <span class="keyword">function</span>(start, end) {
      <span class="function"><span class="keyword">function</span> <span class="title">clamp</span><span class="params">(v, min, max)</span> {</span> <span class="keyword">return</span> v &lt; min ? min : v > max ? max : v; }

      start = ECMAScript.ToInt32(start);
      end = ECMAScript.ToInt32(end);

      <span class="keyword">if</span> (arguments.length &lt; <span class="number">1</span>) { start = <span class="number">0</span>; }
      <span class="keyword">if</span> (arguments.length &lt; <span class="number">2</span>) { end = <span class="keyword">this</span>.length; }

      <span class="keyword">if</span> (start &lt; <span class="number">0</span>) { start = <span class="keyword">this</span>.length + start; }
      <span class="keyword">if</span> (end &lt; <span class="number">0</span>) { end = <span class="keyword">this</span>.length + end; }

      start = clamp(start, <span class="number">0</span>, <span class="keyword">this</span>.length);
      end = clamp(end, <span class="number">0</span>, <span class="keyword">this</span>.length);

      <span class="keyword">var</span> len = end - start;
      <span class="keyword">if</span> (len &lt; <span class="number">0</span>) {
        len = <span class="number">0</span>;
      }

      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor(
        <span class="keyword">this</span>.buffer, <span class="keyword">this</span>.byteOffset + start * <span class="keyword">this</span>.BYTES_PER_ELEMENT, len);
    };

    <span class="keyword">return</span> ctor;
  }

  <span class="keyword">var</span> Int8Array = makeConstructor(<span class="number">1</span>, packI8, unpackI8);
  <span class="keyword">var</span> Uint8Array = makeConstructor(<span class="number">1</span>, packU8, unpackU8);
  <span class="keyword">var</span> Uint8ClampedArray = makeConstructor(<span class="number">1</span>, packU8Clamped, unpackU8);
  <span class="keyword">var</span> Int16Array = makeConstructor(<span class="number">2</span>, packI16, unpackI16);
  <span class="keyword">var</span> Uint16Array = makeConstructor(<span class="number">2</span>, packU16, unpackU16);
  <span class="keyword">var</span> Int32Array = makeConstructor(<span class="number">4</span>, packI32, unpackI32);
  <span class="keyword">var</span> Uint32Array = makeConstructor(<span class="number">4</span>, packU32, unpackU32);
  <span class="keyword">var</span> Float32Array = makeConstructor(<span class="number">4</span>, packF32, unpackF32);
  <span class="keyword">var</span> Float64Array = makeConstructor(<span class="number">8</span>, packF64, unpackF64);

  exports.Int8Array = exports.Int8Array || Int8Array;
  exports.Uint8Array = exports.Uint8Array || Uint8Array;
  exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray;
  exports.Int16Array = exports.Int16Array || Int16Array;
  exports.Uint16Array = exports.Uint16Array || Uint16Array;
  exports.Int32Array = exports.Int32Array || Int32Array;
  exports.Uint32Array = exports.Uint32Array || Uint32Array;
  exports.Float32Array = exports.Float32Array || Float32Array;
  exports.Float64Array = exports.Float64Array || Float64Array;
}());

<span class="comment">//</span>
<span class="comment">// 6 The DataView View Type</span>
<span class="comment">//</span>

(<span class="keyword">function</span>() {
  <span class="function"><span class="keyword">function</span> <span class="title">r</span><span class="params">(array, index)</span> {</span>
    <span class="keyword">return</span> ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
  }

  <span class="keyword">var</span> IS_BIG_ENDIAN = (<span class="keyword">function</span>() {
    <span class="keyword">var</span> u16array = <span class="keyword">new</span>(exports.Uint16Array)([<span class="number">0x1234</span>]),
        u8array = <span class="keyword">new</span>(exports.Uint8Array)(u16array.buffer);
    <span class="keyword">return</span> r(u8array, <span class="number">0</span>) === <span class="number">0x12</span>;
  }());

  <span class="comment">// Constructor(ArrayBuffer buffer,</span>
  <span class="comment">//             optional unsigned long byteOffset,</span>
  <span class="comment">//             optional unsigned long byteLength)</span>
  <span class="comment">/** @constructor */</span>
  <span class="keyword">var</span> DataView = <span class="function"><span class="keyword">function</span> <span class="title">DataView</span><span class="params">(buffer, byteOffset, byteLength)</span> {</span>
    <span class="keyword">if</span> (arguments.length === <span class="number">0</span>) {
      buffer = <span class="keyword">new</span> exports.ArrayBuffer(<span class="number">0</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (!(buffer <span class="keyword">instanceof</span> exports.ArrayBuffer || ECMAScript.Class(buffer) === <span class="string">'ArrayBuffer'</span>)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"TypeError"</span>);
    }

    <span class="keyword">this</span>.buffer = buffer || <span class="keyword">new</span> exports.ArrayBuffer(<span class="number">0</span>);

    <span class="keyword">this</span>.byteOffset = ECMAScript.ToUint32(byteOffset);
    <span class="keyword">if</span> (<span class="keyword">this</span>.byteOffset > <span class="keyword">this</span>.buffer.byteLength) {
      <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"byteOffset out of range"</span>);
    }

    <span class="keyword">if</span> (arguments.length &lt; <span class="number">3</span>) {
      <span class="keyword">this</span>.byteLength = <span class="keyword">this</span>.buffer.byteLength - <span class="keyword">this</span>.byteOffset;
    } <span class="keyword">else</span> {
      <span class="keyword">this</span>.byteLength = ECMAScript.ToUint32(byteLength);
    }

    <span class="keyword">if</span> ((<span class="keyword">this</span>.byteOffset + <span class="keyword">this</span>.byteLength) > <span class="keyword">this</span>.buffer.byteLength) {
      <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"byteOffset and length reference an area beyond the end of the buffer"</span>);
    }

    configureProperties(<span class="keyword">this</span>);
  };

  <span class="function"><span class="keyword">function</span> <span class="title">makeGetter</span><span class="params">(arrayType)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">function</span>(byteOffset, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);

      <span class="keyword">if</span> (byteOffset + arrayType.BYTES_PER_ELEMENT > <span class="keyword">this</span>.byteLength) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"Array index out of range"</span>);
      }
      byteOffset += <span class="keyword">this</span>.byteOffset;

      <span class="keyword">var</span> uint8Array = <span class="keyword">new</span> exports.Uint8Array(<span class="keyword">this</span>.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),
          bytes = [], i;
      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrayType.BYTES_PER_ELEMENT; i += <span class="number">1</span>) {
        bytes.push(r(uint8Array, i));
      }

      <span class="keyword">if</span> (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      <span class="keyword">return</span> r(<span class="keyword">new</span> arrayType(<span class="keyword">new</span> exports.Uint8Array(bytes).buffer), <span class="number">0</span>);
    };
  }

  DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
  DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
  DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
  DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
  DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
  DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
  DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
  DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);

  <span class="function"><span class="keyword">function</span> <span class="title">makeSetter</span><span class="params">(arrayType)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">function</span>(byteOffset, value, littleEndian) {

      byteOffset = ECMAScript.ToUint32(byteOffset);
      <span class="keyword">if</span> (byteOffset + arrayType.BYTES_PER_ELEMENT > <span class="keyword">this</span>.byteLength) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RangeError(<span class="string">"Array index out of range"</span>);
      }

      <span class="comment">// Get bytes</span>
      <span class="keyword">var</span> typeArray = <span class="keyword">new</span> arrayType([value]),
          byteArray = <span class="keyword">new</span> exports.Uint8Array(typeArray.buffer),
          bytes = [], i, byteView;

      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arrayType.BYTES_PER_ELEMENT; i += <span class="number">1</span>) {
        bytes.push(r(byteArray, i));
      }

      <span class="comment">// Flip if necessary</span>
      <span class="keyword">if</span> (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
        bytes.reverse();
      }

      <span class="comment">// Write them</span>
      byteView = <span class="keyword">new</span> exports.Uint8Array(<span class="keyword">this</span>.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
      byteView.set(bytes);
    };
  }

  DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
  DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
  DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
  DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
  DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
  DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
  DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
  DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);

  exports.DataView = exports.DataView || DataView;

}());
</code></pre>