<h1>index.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> PassThrough = require(<span class="string">'readable-stream'</span>).PassThrough
<span class="keyword">var</span> Readable = require(<span class="string">'readable-stream'</span>).Readable
<span class="keyword">var</span> duplexer = require(<span class="string">'duplexer2'</span>)

module.exports = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> streams
  <span class="keyword">if</span>(arguments.length == <span class="number">1</span> &amp;&amp; Array.isArray(arguments[<span class="number">0</span>])) {
    streams = arguments[<span class="number">0</span>]
  } <span class="keyword">else</span> {
    streams = [].slice.call(arguments)
  }
  <span class="keyword">return</span> combine(streams)
}

module.exports.obj = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> streams
  <span class="keyword">if</span>(arguments.length == <span class="number">1</span> &amp;&amp; Array.isArray(arguments[<span class="number">0</span>])) {
    streams = arguments[<span class="number">0</span>]
  } <span class="keyword">else</span> {
    streams = [].slice.call(arguments)
  }
  <span class="keyword">return</span> combine(streams, { objectMode: <span class="literal">true</span> })
}

  
<span class="function"><span class="keyword">function</span> <span class="title">combine</span> <span class="params">(streams, opts)</span> {</span>

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; streams.length; i++)
    streams[i] = wrap(streams[i], opts)

  <span class="keyword">if</span>(streams.length == <span class="number">0</span>)
    <span class="keyword">return</span> <span class="keyword">new</span> PassThrough(opts)
  <span class="keyword">else</span> <span class="keyword">if</span>(streams.length == <span class="number">1</span>)
    <span class="keyword">return</span> streams[<span class="number">0</span>]

  <span class="keyword">var</span> first = streams[<span class="number">0</span>]
    , last = streams[streams.length - <span class="number">1</span>]
    , thepipe = duplexer(opts, first, last)

  <span class="comment">//pipe all the streams together</span>

  <span class="function"><span class="keyword">function</span> <span class="title">recurse</span> <span class="params">(streams)</span> {</span>
    <span class="keyword">if</span>(streams.length &lt; <span class="number">2</span>)
      <span class="keyword">return</span>
    streams[<span class="number">0</span>].pipe(streams[<span class="number">1</span>])
    recurse(streams.slice(<span class="number">1</span>))
  }

  recurse(streams)

  <span class="function"><span class="keyword">function</span> <span class="title">onerror</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> args = [].slice.call(arguments)
    args.unshift(<span class="string">'error'</span>)
    thepipe.emit.apply(thepipe, args)
  }

  <span class="comment">//es.duplex already reemits the error from the first and last stream.</span>
  <span class="comment">//add a listener for the inner streams in the pipeline.</span>
  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; streams.length - <span class="number">1</span>; i ++)
    streams[i].on(<span class="string">'error'</span>, onerror)

  <span class="keyword">return</span> thepipe
}

<span class="function"><span class="keyword">function</span> <span class="title">wrap</span> <span class="params">(tr, opts)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> tr.read === <span class="string">'function'</span>) <span class="keyword">return</span> tr
  <span class="keyword">return</span> <span class="keyword">new</span> Readable(opts).wrap(tr)
}
</code></pre>