<h1>path.js</h1>
<pre><code class="lang-js"><span class="comment">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="comment">//</span>
<span class="comment">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="comment">// copy of this software and associated documentation files (the</span>
<span class="comment">// "Software"), to deal in the Software without restriction, including</span>
<span class="comment">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="comment">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="comment">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="comment">// following conditions:</span>
<span class="comment">//</span>
<span class="comment">// The above copyright notice and this permission notice shall be included</span>
<span class="comment">// in all copies or substantial portions of the Software.</span>
<span class="comment">//</span>
<span class="comment">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="comment">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="comment">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="comment">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="comment">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="comment">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="comment">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>


<span class="keyword">var</span> isWindows = process.platform === <span class="string">'win32'</span>;
<span class="keyword">var</span> util = require(<span class="string">'util'</span>);

<span class="keyword">var</span> _path = require(<span class="string">'path'</span>);

<span class="comment">// we are new enough we already have this from the system, just export the</span>
<span class="comment">// system then</span>
<span class="keyword">if</span> (_path.posix) {
  module.exports = _path;
  <span class="keyword">return</span>;
}

<span class="comment">// resolves . and .. elements in a path array with directory names there</span>
<span class="comment">// must be no slashes or device names (c:\) in the array</span>
<span class="comment">// (so also no leading and trailing slashes - it does not distinguish</span>
<span class="comment">// relative and absolute paths)</span>
<span class="function"><span class="keyword">function</span> <span class="title">normalizeArray</span><span class="params">(parts, allowAboveRoot)</span> {</span>
  <span class="keyword">var</span> res = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parts.length; i++) {
    <span class="keyword">var</span> p = parts[i];

    <span class="comment">// ignore empty parts</span>
    <span class="keyword">if</span> (!p || p === <span class="string">'.'</span>)
      <span class="keyword">continue</span>;

    <span class="keyword">if</span> (p === <span class="string">'..'</span>) {
      <span class="keyword">if</span> (res.length &amp;&amp; res[res.length - <span class="number">1</span>] !== <span class="string">'..'</span>) {
        res.pop();
      } <span class="keyword">else</span> <span class="keyword">if</span> (allowAboveRoot) {
        res.push(<span class="string">'..'</span>);
      }
    } <span class="keyword">else</span> {
      res.push(p);
    }
  }

  <span class="keyword">return</span> res;
}

<span class="comment">// Regex to split a windows path into three parts: [*, device, slash,</span>
<span class="comment">// tail] windows-only</span>
<span class="keyword">var</span> splitDeviceRe =
    <span class="regexp">/^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/</span>;

<span class="comment">// Regex to split the tail part of the above into [*, dir, basename, ext]</span>
<span class="keyword">var</span> splitTailRe =
    <span class="regexp">/^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/</span>;

<span class="keyword">var</span> win32 = {};

<span class="comment">// Function to split a filename into [root, dir, basename, ext]</span>
<span class="function"><span class="keyword">function</span> <span class="title">win32SplitPath</span><span class="params">(filename)</span> {</span>
  <span class="comment">// Separate device+slash from tail</span>
  <span class="keyword">var</span> result = splitDeviceRe.exec(filename),
      device = (result[<span class="number">1</span>] || <span class="string">''</span>) + (result[<span class="number">2</span>] || <span class="string">''</span>),
      tail = result[<span class="number">3</span>] || <span class="string">''</span>;
  <span class="comment">// Split the tail into dir, basename and extension</span>
  <span class="keyword">var</span> result2 = splitTailRe.exec(tail),
      dir = result2[<span class="number">1</span>],
      basename = result2[<span class="number">2</span>],
      ext = result2[<span class="number">3</span>];
  <span class="keyword">return</span> [device, dir, basename, ext];
}

<span class="keyword">var</span> normalizeUNCRoot = <span class="keyword">function</span>(device) {
  <span class="keyword">return</span> <span class="string">'\\\\'</span> + device.replace(<span class="regexp">/^[\\\/]+/</span>, <span class="string">''</span>).replace(<span class="regexp">/[\\\/]+/g</span>, <span class="string">'\\'</span>);
};

<span class="comment">// path.resolve([from ...], to)</span>
win32.resolve = <span class="keyword">function</span>() {
  <span class="keyword">var</span> resolvedDevice = <span class="string">''</span>,
      resolvedTail = <span class="string">''</span>,
      resolvedAbsolute = <span class="literal">false</span>;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = arguments.length - <span class="number">1</span>; i >= -<span class="number">1</span>; i--) {
    <span class="keyword">var</span> path;
    <span class="keyword">if</span> (i >= <span class="number">0</span>) {
      path = arguments[i];
    } <span class="keyword">else</span> <span class="keyword">if</span> (!resolvedDevice) {
      path = process.cwd();
    } <span class="keyword">else</span> {
      <span class="comment">// Windows has the concept of drive-specific current working</span>
      <span class="comment">// directories. If we've resolved a drive letter but not yet an</span>
      <span class="comment">// absolute path, get cwd for that drive. We're sure the device is not</span>
      <span class="comment">// an unc path at this points, because unc paths are always absolute.</span>
      path = process.env[<span class="string">'='</span> + resolvedDevice];
      <span class="comment">// Verify that a drive-local cwd was found and that it actually points</span>
      <span class="comment">// to our drive. If not, default to the drive's root.</span>
      <span class="keyword">if</span> (!path || path.substr(<span class="number">0</span>, <span class="number">3</span>).toLowerCase() !==
          resolvedDevice.toLowerCase() + <span class="string">'\\'</span>) {
        path = resolvedDevice + <span class="string">'\\'</span>;
      }
    }

    <span class="comment">// Skip empty and invalid entries</span>
    <span class="keyword">if</span> (!util.isString(path)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Arguments to path.resolve must be strings'</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (!path) {
      <span class="keyword">continue</span>;
    }

    <span class="keyword">var</span> result = splitDeviceRe.exec(path),
        device = result[<span class="number">1</span>] || <span class="string">''</span>,
        isUnc = device &amp;&amp; device.charAt(<span class="number">1</span>) !== <span class="string">':'</span>,
        isAbsolute = win32.isAbsolute(path),
        tail = result[<span class="number">3</span>];

    <span class="keyword">if</span> (device &amp;&amp;
        resolvedDevice &amp;&amp;
        device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      <span class="comment">// This path points to another device so it is not applicable</span>
      <span class="keyword">continue</span>;
    }

    <span class="keyword">if</span> (!resolvedDevice) {
      resolvedDevice = device;
    }
    <span class="keyword">if</span> (!resolvedAbsolute) {
      resolvedTail = tail + <span class="string">'\\'</span> + resolvedTail;
      resolvedAbsolute = isAbsolute;
    }

    <span class="keyword">if</span> (resolvedDevice &amp;&amp; resolvedAbsolute) {
      <span class="keyword">break</span>;
    }
  }

  <span class="comment">// Convert slashes to backslashes when `resolvedDevice` points to an UNC</span>
  <span class="comment">// root. Also squash multiple slashes into a single one where appropriate.</span>
  <span class="keyword">if</span> (isUnc) {
    resolvedDevice = normalizeUNCRoot(resolvedDevice);
  }

  <span class="comment">// At this point the path should be resolved to a full absolute path,</span>
  <span class="comment">// but handle relative paths to be safe (might happen when process.cwd()</span>
  <span class="comment">// fails)</span>

  <span class="comment">// Normalize the tail path</span>
  resolvedTail = normalizeArray(resolvedTail.split(<span class="regexp">/[\\\/]+/</span>),
                                !resolvedAbsolute).join(<span class="string">'\\'</span>);

  <span class="comment">// If device is a drive letter, we'll normalize to lower case.</span>
  <span class="keyword">if</span> (resolvedDevice &amp;&amp; resolvedDevice.charAt(<span class="number">1</span>) === <span class="string">':'</span>) {
    resolvedDevice = resolvedDevice[<span class="number">0</span>].toLowerCase() +
        resolvedDevice.substr(<span class="number">1</span>);
  }

  <span class="keyword">return</span> (resolvedDevice + (resolvedAbsolute ? <span class="string">'\\'</span> : <span class="string">''</span>) + resolvedTail) ||
         <span class="string">'.'</span>;
};


win32.normalize = <span class="keyword">function</span>(path) {
  <span class="keyword">var</span> result = splitDeviceRe.exec(path),
      device = result[<span class="number">1</span>] || <span class="string">''</span>,
      isUnc = device &amp;&amp; device.charAt(<span class="number">1</span>) !== <span class="string">':'</span>,
      isAbsolute = win32.isAbsolute(path),
      tail = result[<span class="number">3</span>],
      trailingSlash = <span class="regexp">/[\\\/]$/</span>.test(tail);

  <span class="comment">// If device is a drive letter, we'll normalize to lower case.</span>
  <span class="keyword">if</span> (device &amp;&amp; device.charAt(<span class="number">1</span>) === <span class="string">':'</span>) {
    device = device[<span class="number">0</span>].toLowerCase() + device.substr(<span class="number">1</span>);
  }

  <span class="comment">// Normalize the tail path</span>
  tail = normalizeArray(tail.split(<span class="regexp">/[\\\/]+/</span>), !isAbsolute).join(<span class="string">'\\'</span>);

  <span class="keyword">if</span> (!tail &amp;&amp; !isAbsolute) {
    tail = <span class="string">'.'</span>;
  }
  <span class="keyword">if</span> (tail &amp;&amp; trailingSlash) {
    tail += <span class="string">'\\'</span>;
  }

  <span class="comment">// Convert slashes to backslashes when `device` points to an UNC root.</span>
  <span class="comment">// Also squash multiple slashes into a single one where appropriate.</span>
  <span class="keyword">if</span> (isUnc) {
    device = normalizeUNCRoot(device);
  }

  <span class="keyword">return</span> device + (isAbsolute ? <span class="string">'\\'</span> : <span class="string">''</span>) + tail;
};


win32.isAbsolute = <span class="keyword">function</span>(path) {
  <span class="keyword">var</span> result = splitDeviceRe.exec(path),
      device = result[<span class="number">1</span>] || <span class="string">''</span>,
      isUnc = !!device &amp;&amp; device.charAt(<span class="number">1</span>) !== <span class="string">':'</span>;
  <span class="comment">// UNC paths are always absolute</span>
  <span class="keyword">return</span> !!result[<span class="number">2</span>] || isUnc;
};

win32.join = <span class="keyword">function</span>() {
  <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(p)</span> {</span>
    <span class="keyword">if</span> (!util.isString(p)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Arguments to path.join must be strings'</span>);
    }
    <span class="keyword">return</span> p;
  }

  <span class="keyword">var</span> paths = Array.prototype.filter.call(arguments, f);
  <span class="keyword">var</span> joined = paths.join(<span class="string">'\\'</span>);

  <span class="comment">// Make sure that the joined path doesn't start with two slashes, because</span>
  <span class="comment">// normalize() will mistake it for an UNC path then.</span>
  <span class="comment">//</span>
  <span class="comment">// This step is skipped when it is very clear that the user actually</span>
  <span class="comment">// intended to point at an UNC path. This is assumed when the first</span>
  <span class="comment">// non-empty string arguments starts with exactly two slashes followed by</span>
  <span class="comment">// at least one more non-slash character.</span>
  <span class="comment">//</span>
  <span class="comment">// Note that for normalize() to treat a path as an UNC path it needs to</span>
  <span class="comment">// have at least 2 components, so we don't filter for that here.</span>
  <span class="comment">// This means that the user can use join to construct UNC paths from</span>
  <span class="comment">// a server name and a share name; for example:</span>
  <span class="comment">//   path.join('//server', 'share') -> '\\\\server\\share\')</span>
  <span class="keyword">if</span> (!<span class="regexp">/^[\\\/]{2}[^\\\/]/</span>.test(paths[<span class="number">0</span>])) {
    joined = joined.replace(<span class="regexp">/^[\\\/]{2,}/</span>, <span class="string">'\\'</span>);
  }

  <span class="keyword">return</span> win32.normalize(joined);
};


<span class="comment">// path.relative(from, to)</span>
<span class="comment">// it will solve the relative path from 'from' to 'to', for instance:</span>
<span class="comment">// from = 'C:\\orandea\\test\\aaa'</span>
<span class="comment">// to = 'C:\\orandea\\impl\\bbb'</span>
<span class="comment">// The output of the function should be: '..\\..\\impl\\bbb'</span>
win32.relative = <span class="keyword">function</span>(from, to) {
  from = win32.resolve(from);
  to = win32.resolve(to);

  <span class="comment">// windows is not case sensitive</span>
  <span class="keyword">var</span> lowerFrom = from.toLowerCase();
  <span class="keyword">var</span> lowerTo = to.toLowerCase();

  <span class="function"><span class="keyword">function</span> <span class="title">trim</span><span class="params">(arr)</span> {</span>
    <span class="keyword">var</span> start = <span class="number">0</span>;
    <span class="keyword">for</span> (; start &lt; arr.length; start++) {
      <span class="keyword">if</span> (arr[start] !== <span class="string">''</span>) <span class="keyword">break</span>;
    }

    <span class="keyword">var</span> end = arr.length - <span class="number">1</span>;
    <span class="keyword">for</span> (; end >= <span class="number">0</span>; end--) {
      <span class="keyword">if</span> (arr[end] !== <span class="string">''</span>) <span class="keyword">break</span>;
    }

    <span class="keyword">if</span> (start > end) <span class="keyword">return</span> [];
    <span class="keyword">return</span> arr.slice(start, end + <span class="number">1</span>);
  }

  <span class="keyword">var</span> toParts = trim(to.split(<span class="string">'\\'</span>));

  <span class="keyword">var</span> lowerFromParts = trim(lowerFrom.split(<span class="string">'\\'</span>));
  <span class="keyword">var</span> lowerToParts = trim(lowerTo.split(<span class="string">'\\'</span>));

  <span class="keyword">var</span> length = Math.min(lowerFromParts.length, lowerToParts.length);
  <span class="keyword">var</span> samePartsLength = length;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) {
    <span class="keyword">if</span> (lowerFromParts[i] !== lowerToParts[i]) {
      samePartsLength = i;
      <span class="keyword">break</span>;
    }
  }

  <span class="keyword">if</span> (samePartsLength == <span class="number">0</span>) {
    <span class="keyword">return</span> to;
  }

  <span class="keyword">var</span> outputParts = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = samePartsLength; i &lt; lowerFromParts.length; i++) {
    outputParts.push(<span class="string">'..'</span>);
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  <span class="keyword">return</span> outputParts.join(<span class="string">'\\'</span>);
};


win32._makeLong = <span class="keyword">function</span>(path) {
  <span class="comment">// Note: this will *probably* throw somewhere.</span>
  <span class="keyword">if</span> (!util.isString(path))
    <span class="keyword">return</span> path;

  <span class="keyword">if</span> (!path) {
    <span class="keyword">return</span> <span class="string">''</span>;
  }

  <span class="keyword">var</span> resolvedPath = win32.resolve(path);

  <span class="keyword">if</span> (<span class="regexp">/^[a-zA-Z]\:\\/.test(resolvedPath)) {
    /</span><span class="regexp">/ path is local filesystem path, which needs to be converted
    /</span><span class="regexp">/ to long UNC path.
    return '\\\\?\\' + resolvedPath;
  } else if (/</span>^\\\\[^?.]/.test(resolvedPath)) {
    <span class="comment">// path is network UNC path, which needs to be converted</span>
    <span class="comment">// to long UNC path.</span>
    <span class="keyword">return</span> <span class="string">'\\\\?\\UNC\\'</span> + resolvedPath.substring(<span class="number">2</span>);
  }

  <span class="keyword">return</span> path;
};


win32.dirname = <span class="keyword">function</span>(path) {
  <span class="keyword">var</span> result = win32SplitPath(path),
      root = result[<span class="number">0</span>],
      dir = result[<span class="number">1</span>];

  <span class="keyword">if</span> (!root &amp;&amp; !dir) {
    <span class="comment">// No dirname whatsoever</span>
    <span class="keyword">return</span> <span class="string">'.'</span>;
  }

  <span class="keyword">if</span> (dir) {
    <span class="comment">// It has a dirname, strip trailing slash</span>
    dir = dir.substr(<span class="number">0</span>, dir.length - <span class="number">1</span>);
  }

  <span class="keyword">return</span> root + dir;
};


win32.basename = <span class="keyword">function</span>(path, ext) {
  <span class="keyword">var</span> f = win32SplitPath(path)[<span class="number">2</span>];
  <span class="comment">// TODO: make this comparison case-insensitive on windows?</span>
  <span class="keyword">if</span> (ext &amp;&amp; f.substr(-<span class="number">1</span> * ext.length) === ext) {
    f = f.substr(<span class="number">0</span>, f.length - ext.length);
  }
  <span class="keyword">return</span> f;
};


win32.extname = <span class="keyword">function</span>(path) {
  <span class="keyword">return</span> win32SplitPath(path)[<span class="number">3</span>];
};


win32.format = <span class="keyword">function</span>(pathObject) {
  <span class="keyword">if</span> (!util.isObject(pathObject)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(
        <span class="string">"Parameter 'pathObject' must be an object, not "</span> + <span class="keyword">typeof</span> pathObject
    );
  }

  <span class="keyword">var</span> root = pathObject.root || <span class="string">''</span>;

  <span class="keyword">if</span> (!util.isString(root)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(
        <span class="string">"'pathObject.root' must be a string or undefined, not "</span> +
        <span class="keyword">typeof</span> pathObject.root
    );
  }

  <span class="keyword">var</span> dir = pathObject.dir;
  <span class="keyword">var</span> base = pathObject.base || <span class="string">''</span>;
  <span class="keyword">if</span> (dir.slice(dir.length - <span class="number">1</span>, dir.length) === win32.sep) {
    <span class="keyword">return</span> dir + base;
  }

  <span class="keyword">if</span> (dir) {
    <span class="keyword">return</span> dir + win32.sep + base;
  }

  <span class="keyword">return</span> base;
};


win32.parse = <span class="keyword">function</span>(pathString) {
  <span class="keyword">if</span> (!util.isString(pathString)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(
        <span class="string">"Parameter 'pathString' must be a string, not "</span> + <span class="keyword">typeof</span> pathString
    );
  }
  <span class="keyword">var</span> allParts = win32SplitPath(pathString);
  <span class="keyword">if</span> (!allParts || allParts.length !== <span class="number">4</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"Invalid path '"</span> + pathString + <span class="string">"'"</span>);
  }
  <span class="keyword">return</span> {
    root: allParts[<span class="number">0</span>],
    dir: allParts[<span class="number">0</span>] + allParts[<span class="number">1</span>].slice(<span class="number">0</span>, allParts[<span class="number">1</span>].length - <span class="number">1</span>),
    base: allParts[<span class="number">2</span>],
    ext: allParts[<span class="number">3</span>],
    name: allParts[<span class="number">2</span>].slice(<span class="number">0</span>, allParts[<span class="number">2</span>].length - allParts[<span class="number">3</span>].length)
  };
};


win32.sep = <span class="string">'\\'</span>;
win32.delimiter = <span class="string">';'</span>;


<span class="comment">// Split a filename into [root, dir, basename, ext], unix version</span>
<span class="comment">// 'root' is just a slash, or nothing.</span>
<span class="keyword">var</span> splitPathRe =
    <span class="regexp">/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/</span>;
<span class="keyword">var</span> posix = {};


<span class="function"><span class="keyword">function</span> <span class="title">posixSplitPath</span><span class="params">(filename)</span> {</span>
  <span class="keyword">return</span> splitPathRe.exec(filename).slice(<span class="number">1</span>);
}


<span class="comment">// path.resolve([from ...], to)</span>
<span class="comment">// posix version</span>
posix.resolve = <span class="keyword">function</span>() {
  <span class="keyword">var</span> resolvedPath = <span class="string">''</span>,
      resolvedAbsolute = <span class="literal">false</span>;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = arguments.length - <span class="number">1</span>; i >= -<span class="number">1</span> &amp;&amp; !resolvedAbsolute; i--) {
    <span class="keyword">var</span> path = (i >= <span class="number">0</span>) ? arguments[i] : process.cwd();

    <span class="comment">// Skip empty and invalid entries</span>
    <span class="keyword">if</span> (!util.isString(path)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Arguments to path.resolve must be strings'</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (!path) {
      <span class="keyword">continue</span>;
    }

    resolvedPath = path + <span class="string">'/'</span> + resolvedPath;
    resolvedAbsolute = path.charAt(<span class="number">0</span>) === <span class="string">'/'</span>;
  }

  <span class="comment">// At this point the path should be resolved to a full absolute path, but</span>
  <span class="comment">// handle relative paths to be safe (might happen when process.cwd() fails)</span>

  <span class="comment">// Normalize the path</span>
  resolvedPath = normalizeArray(resolvedPath.split(<span class="string">'/'</span>),
                                !resolvedAbsolute).join(<span class="string">'/'</span>);

  <span class="keyword">return</span> ((resolvedAbsolute ? <span class="string">'/'</span> : <span class="string">''</span>) + resolvedPath) || <span class="string">'.'</span>;
};

<span class="comment">// path.normalize(path)</span>
<span class="comment">// posix version</span>
posix.normalize = <span class="keyword">function</span>(path) {
  <span class="keyword">var</span> isAbsolute = posix.isAbsolute(path),
      trailingSlash = path.substr(-<span class="number">1</span>) === <span class="string">'/'</span>;

  <span class="comment">// Normalize the path</span>
  path = normalizeArray(path.split(<span class="string">'/'</span>), !isAbsolute).join(<span class="string">'/'</span>);

  <span class="keyword">if</span> (!path &amp;&amp; !isAbsolute) {
    path = <span class="string">'.'</span>;
  }
  <span class="keyword">if</span> (path &amp;&amp; trailingSlash) {
    path += <span class="string">'/'</span>;
  }

  <span class="keyword">return</span> (isAbsolute ? <span class="string">'/'</span> : <span class="string">''</span>) + path;
};

<span class="comment">// posix version</span>
posix.isAbsolute = <span class="keyword">function</span>(path) {
  <span class="keyword">return</span> path.charAt(<span class="number">0</span>) === <span class="string">'/'</span>;
};

<span class="comment">// posix version</span>
posix.join = <span class="keyword">function</span>() {
  <span class="keyword">var</span> path = <span class="string">''</span>;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) {
    <span class="keyword">var</span> segment = arguments[i];
    <span class="keyword">if</span> (!util.isString(segment)) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Arguments to path.join must be strings'</span>);
    }
    <span class="keyword">if</span> (segment) {
      <span class="keyword">if</span> (!path) {
        path += segment;
      } <span class="keyword">else</span> {
        path += <span class="string">'/'</span> + segment;
      }
    }
  }
  <span class="keyword">return</span> posix.normalize(path);
};


<span class="comment">// path.relative(from, to)</span>
<span class="comment">// posix version</span>
posix.relative = <span class="keyword">function</span>(from, to) {
  from = posix.resolve(from).substr(<span class="number">1</span>);
  to = posix.resolve(to).substr(<span class="number">1</span>);

  <span class="function"><span class="keyword">function</span> <span class="title">trim</span><span class="params">(arr)</span> {</span>
    <span class="keyword">var</span> start = <span class="number">0</span>;
    <span class="keyword">for</span> (; start &lt; arr.length; start++) {
      <span class="keyword">if</span> (arr[start] !== <span class="string">''</span>) <span class="keyword">break</span>;
    }

    <span class="keyword">var</span> end = arr.length - <span class="number">1</span>;
    <span class="keyword">for</span> (; end >= <span class="number">0</span>; end--) {
      <span class="keyword">if</span> (arr[end] !== <span class="string">''</span>) <span class="keyword">break</span>;
    }

    <span class="keyword">if</span> (start > end) <span class="keyword">return</span> [];
    <span class="keyword">return</span> arr.slice(start, end + <span class="number">1</span>);
  }

  <span class="keyword">var</span> fromParts = trim(from.split(<span class="string">'/'</span>));
  <span class="keyword">var</span> toParts = trim(to.split(<span class="string">'/'</span>));

  <span class="keyword">var</span> length = Math.min(fromParts.length, toParts.length);
  <span class="keyword">var</span> samePartsLength = length;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) {
    <span class="keyword">if</span> (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      <span class="keyword">break</span>;
    }
  }

  <span class="keyword">var</span> outputParts = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = samePartsLength; i &lt; fromParts.length; i++) {
    outputParts.push(<span class="string">'..'</span>);
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  <span class="keyword">return</span> outputParts.join(<span class="string">'/'</span>);
};


posix._makeLong = <span class="keyword">function</span>(path) {
  <span class="keyword">return</span> path;
};


posix.dirname = <span class="keyword">function</span>(path) {
  <span class="keyword">var</span> result = posixSplitPath(path),
      root = result[<span class="number">0</span>],
      dir = result[<span class="number">1</span>];

  <span class="keyword">if</span> (!root &amp;&amp; !dir) {
    <span class="comment">// No dirname whatsoever</span>
    <span class="keyword">return</span> <span class="string">'.'</span>;
  }

  <span class="keyword">if</span> (dir) {
    <span class="comment">// It has a dirname, strip trailing slash</span>
    dir = dir.substr(<span class="number">0</span>, dir.length - <span class="number">1</span>);
  }

  <span class="keyword">return</span> root + dir;
};


posix.basename = <span class="keyword">function</span>(path, ext) {
  <span class="keyword">var</span> f = posixSplitPath(path)[<span class="number">2</span>];
  <span class="comment">// TODO: make this comparison case-insensitive on windows?</span>
  <span class="keyword">if</span> (ext &amp;&amp; f.substr(-<span class="number">1</span> * ext.length) === ext) {
    f = f.substr(<span class="number">0</span>, f.length - ext.length);
  }
  <span class="keyword">return</span> f;
};


posix.extname = <span class="keyword">function</span>(path) {
  <span class="keyword">return</span> posixSplitPath(path)[<span class="number">3</span>];
};


posix.format = <span class="keyword">function</span>(pathObject) {
  <span class="keyword">if</span> (!util.isObject(pathObject)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(
        <span class="string">"Parameter 'pathObject' must be an object, not "</span> + <span class="keyword">typeof</span> pathObject
    );
  }

  <span class="keyword">var</span> root = pathObject.root || <span class="string">''</span>;

  <span class="keyword">if</span> (!util.isString(root)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(
        <span class="string">"'pathObject.root' must be a string or undefined, not "</span> +
        <span class="keyword">typeof</span> pathObject.root
    );
  }

  <span class="keyword">var</span> dir = pathObject.dir ? pathObject.dir + posix.sep : <span class="string">''</span>;
  <span class="keyword">var</span> base = pathObject.base || <span class="string">''</span>;
  <span class="keyword">return</span> dir + base;
};


posix.parse = <span class="keyword">function</span>(pathString) {
  <span class="keyword">if</span> (!util.isString(pathString)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(
        <span class="string">"Parameter 'pathString' must be a string, not "</span> + <span class="keyword">typeof</span> pathString
    );
  }
  <span class="keyword">var</span> allParts = posixSplitPath(pathString);
  <span class="keyword">if</span> (!allParts || allParts.length !== <span class="number">4</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">"Invalid path '"</span> + pathString + <span class="string">"'"</span>);
  }
  allParts[<span class="number">1</span>] = allParts[<span class="number">1</span>] || <span class="string">''</span>;
  allParts[<span class="number">2</span>] = allParts[<span class="number">2</span>] || <span class="string">''</span>;
  allParts[<span class="number">3</span>] = allParts[<span class="number">3</span>] || <span class="string">''</span>;

  <span class="keyword">return</span> {
    root: allParts[<span class="number">0</span>],
    dir: allParts[<span class="number">0</span>] + allParts[<span class="number">1</span>].slice(<span class="number">0</span>, allParts[<span class="number">1</span>].length - <span class="number">1</span>),
    base: allParts[<span class="number">2</span>],
    ext: allParts[<span class="number">3</span>],
    name: allParts[<span class="number">2</span>].slice(<span class="number">0</span>, allParts[<span class="number">2</span>].length - allParts[<span class="number">3</span>].length)
  };
};


posix.sep = <span class="string">'/'</span>;
posix.delimiter = <span class="string">':'</span>;


<span class="keyword">if</span> (isWindows)
  module.exports = win32;
<span class="keyword">else</span> <span class="comment">/* posix */</span>
  module.exports = posix;

module.exports.posix = posix;
module.exports.win32 = win32;
</code></pre>