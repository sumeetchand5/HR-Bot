<h1>_stream_transform.js</h1>
<pre><code class="lang-js"><span class="comment">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="comment">//</span>
<span class="comment">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="comment">// copy of this software and associated documentation files (the</span>
<span class="comment">// "Software"), to deal in the Software without restriction, including</span>
<span class="comment">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="comment">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="comment">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="comment">// following conditions:</span>
<span class="comment">//</span>
<span class="comment">// The above copyright notice and this permission notice shall be included</span>
<span class="comment">// in all copies or substantial portions of the Software.</span>
<span class="comment">//</span>
<span class="comment">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="comment">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="comment">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="comment">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="comment">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="comment">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="comment">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="comment">// a transform stream is a readable/writable stream where you do</span>
<span class="comment">// something with the data.  Sometimes it's called a "filter",</span>
<span class="comment">// but that's not a great name for it, since that implies a thing where</span>
<span class="comment">// some bits pass through, and others are simply ignored.  (That would</span>
<span class="comment">// be a valid example of a transform, of course.)</span>
<span class="comment">//</span>
<span class="comment">// While the output is causally related to the input, it's not a</span>
<span class="comment">// necessarily symmetric or synchronous transformation.  For example,</span>
<span class="comment">// a zlib stream might take multiple plain-text writes(), and then</span>
<span class="comment">// emit a single compressed chunk some time in the future.</span>
<span class="comment">//</span>
<span class="comment">// Here's how this works:</span>
<span class="comment">//</span>
<span class="comment">// The Transform stream has all the aspects of the readable and writable</span>
<span class="comment">// stream classes.  When you write(chunk), that calls _write(chunk,cb)</span>
<span class="comment">// internally, and returns false if there's a lot of pending writes</span>
<span class="comment">// buffered up.  When you call read(), that calls _read(n) until</span>
<span class="comment">// there's enough pending readable data buffered up.</span>
<span class="comment">//</span>
<span class="comment">// In a transform stream, the written data is placed in a buffer.  When</span>
<span class="comment">// _read(n) is called, it transforms the queued up data, calling the</span>
<span class="comment">// buffered _write cb's as it consumes chunks.  If consuming a single</span>
<span class="comment">// written chunk would result in multiple output chunks, then the first</span>
<span class="comment">// outputted bit calls the readcb, and subsequent chunks just go into</span>
<span class="comment">// the read buffer, and will cause it to emit 'readable' if necessary.</span>
<span class="comment">//</span>
<span class="comment">// This way, back-pressure is actually determined by the reading side,</span>
<span class="comment">// since _read has to be called to start processing a new chunk.  However,</span>
<span class="comment">// a pathological inflate type of transform can cause excessive buffering</span>
<span class="comment">// here.  For example, imagine a stream where every byte of input is</span>
<span class="comment">// interpreted as an integer from 0-255, and then results in that many</span>
<span class="comment">// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in</span>
<span class="comment">// 1kb of data being output.  In this case, you could write a very small</span>
<span class="comment">// amount of input, and end up with a very large amount of output.  In</span>
<span class="comment">// such a pathological inflating mechanism, there'd be no way to tell</span>
<span class="comment">// the system to stop doing the transform.  A single 4MB write could</span>
<span class="comment">// cause the system to run out of memory.</span>
<span class="comment">//</span>
<span class="comment">// However, even in such a pathological case, only a single written chunk</span>
<span class="comment">// would be consumed, and then the rest would wait (un-transformed) until</span>
<span class="comment">// the results of the previous transformed chunk were consumed.</span>

<span class="string">'use strict'</span>;

module.exports = Transform;

<span class="keyword">var</span> Duplex = require(<span class="string">'./_stream_duplex'</span>);

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> util = require(<span class="string">'core-util-is'</span>);
util.inherits = require(<span class="string">'inherits'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

util.inherits(Transform, Duplex);

<span class="function"><span class="keyword">function</span> <span class="title">afterTransform</span><span class="params">(er, data)</span> {</span>
  <span class="keyword">var</span> ts = <span class="keyword">this</span>._transformState;
  ts.transforming = <span class="literal">false</span>;

  <span class="keyword">var</span> cb = ts.writecb;

  <span class="keyword">if</span> (!cb) {
    <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">'write callback called multiple times'</span>));
  }

  ts.writechunk = <span class="literal">null</span>;
  ts.writecb = <span class="literal">null</span>;

  <span class="keyword">if</span> (data != <span class="literal">null</span>) <span class="comment">// single equals check for both `null` and `undefined`</span>
    <span class="keyword">this</span>.push(data);

  cb(er);

  <span class="keyword">var</span> rs = <span class="keyword">this</span>._readableState;
  rs.reading = <span class="literal">false</span>;
  <span class="keyword">if</span> (rs.needReadable || rs.length &lt; rs.highWaterMark) {
    <span class="keyword">this</span>._read(rs.highWaterMark);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">Transform</span><span class="params">(options)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Transform)) <span class="keyword">return</span> <span class="keyword">new</span> Transform(options);

  Duplex.call(<span class="keyword">this</span>, options);

  <span class="keyword">this</span>._transformState = {
    afterTransform: afterTransform.bind(<span class="keyword">this</span>),
    needTransform: <span class="literal">false</span>,
    transforming: <span class="literal">false</span>,
    writecb: <span class="literal">null</span>,
    writechunk: <span class="literal">null</span>,
    writeencoding: <span class="literal">null</span>
  };

  <span class="comment">// start out asking for a readable event once data is transformed.</span>
  <span class="keyword">this</span>._readableState.needReadable = <span class="literal">true</span>;

  <span class="comment">// we have implemented the _read method, and done the other things</span>
  <span class="comment">// that Readable wants before the first _read call, so unset the</span>
  <span class="comment">// sync guard flag.</span>
  <span class="keyword">this</span>._readableState.sync = <span class="literal">false</span>;

  <span class="keyword">if</span> (options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.transform === <span class="string">'function'</span>) <span class="keyword">this</span>._transform = options.transform;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.flush === <span class="string">'function'</span>) <span class="keyword">this</span>._flush = options.flush;
  }

  <span class="comment">// When the writable side finishes, then flush out anything remaining.</span>
  <span class="keyword">this</span>.on(<span class="string">'prefinish'</span>, prefinish);
}

<span class="function"><span class="keyword">function</span> <span class="title">prefinish</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._flush === <span class="string">'function'</span>) {
    <span class="keyword">this</span>._flush(<span class="function"><span class="keyword">function</span> <span class="params">(er, data)</span> {</span>
      done(_<span class="keyword">this</span>, er, data);
    });
  } <span class="keyword">else</span> {
    done(<span class="keyword">this</span>, <span class="literal">null</span>, <span class="literal">null</span>);
  }
}

Transform.prototype.push = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding)</span> {</span>
  <span class="keyword">this</span>._transformState.needTransform = <span class="literal">false</span>;
  <span class="keyword">return</span> Duplex.prototype.push.call(<span class="keyword">this</span>, chunk, encoding);
};

<span class="comment">// This is the part where you do stuff!</span>
<span class="comment">// override this function in implementation classes.</span>
<span class="comment">// 'chunk' is an input chunk.</span>
<span class="comment">//</span>
<span class="comment">// Call `push(newChunk)` to pass along transformed output</span>
<span class="comment">// to the readable side.  You may call 'push' zero or more times.</span>
<span class="comment">//</span>
<span class="comment">// Call `cb(err)` when you are done with this chunk.  If you pass</span>
<span class="comment">// an error, then that'll put the hurt on the whole operation.  If you</span>
<span class="comment">// never call cb(), then you'll never get another chunk.</span>
Transform.prototype._transform = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding, cb)</span> {</span>
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'_transform() is not implemented'</span>);
};

Transform.prototype._write = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding, cb)</span> {</span>
  <span class="keyword">var</span> ts = <span class="keyword">this</span>._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  <span class="keyword">if</span> (!ts.transforming) {
    <span class="keyword">var</span> rs = <span class="keyword">this</span>._readableState;
    <span class="keyword">if</span> (ts.needTransform || rs.needReadable || rs.length &lt; rs.highWaterMark) <span class="keyword">this</span>._read(rs.highWaterMark);
  }
};

<span class="comment">// Doesn't matter what the args are here.</span>
<span class="comment">// _transform does all the work.</span>
<span class="comment">// That we got here means that the readable side wants more data.</span>
Transform.prototype._read = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
  <span class="keyword">var</span> ts = <span class="keyword">this</span>._transformState;

  <span class="keyword">if</span> (ts.writechunk !== <span class="literal">null</span> &amp;&amp; ts.writecb &amp;&amp; !ts.transforming) {
    ts.transforming = <span class="literal">true</span>;
    <span class="keyword">this</span>._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } <span class="keyword">else</span> {
    <span class="comment">// mark that we need a transform, so that any data that comes in</span>
    <span class="comment">// will get processed, now that we've asked for it.</span>
    ts.needTransform = <span class="literal">true</span>;
  }
};

Transform.prototype._destroy = <span class="function"><span class="keyword">function</span> <span class="params">(err, cb)</span> {</span>
  <span class="keyword">var</span> _this2 = <span class="keyword">this</span>;

  Duplex.prototype._destroy.call(<span class="keyword">this</span>, err, <span class="function"><span class="keyword">function</span> <span class="params">(err2)</span> {</span>
    cb(err2);
    _this2.emit(<span class="string">'close'</span>);
  });
};

<span class="function"><span class="keyword">function</span> <span class="title">done</span><span class="params">(stream, er, data)</span> {</span>
  <span class="keyword">if</span> (er) <span class="keyword">return</span> stream.emit(<span class="string">'error'</span>, er);

  <span class="keyword">if</span> (data != <span class="literal">null</span>) <span class="comment">// single equals check for both `null` and `undefined`</span>
    stream.push(data);

  <span class="comment">// if there's nothing in the write buffer, then that means</span>
  <span class="comment">// that nothing more will ever be provided</span>
  <span class="keyword">if</span> (stream._writableState.length) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Calling transform done when ws.length != 0'</span>);

  <span class="keyword">if</span> (stream._transformState.transforming) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Calling transform done when still transforming'</span>);

  <span class="keyword">return</span> stream.push(<span class="literal">null</span>);
}</code></pre>