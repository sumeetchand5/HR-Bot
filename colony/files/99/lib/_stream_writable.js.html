<h1>_stream_writable.js</h1>
<pre><code class="lang-js"><span class="comment">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="comment">//</span>
<span class="comment">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="comment">// copy of this software and associated documentation files (the</span>
<span class="comment">// "Software"), to deal in the Software without restriction, including</span>
<span class="comment">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="comment">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="comment">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="comment">// following conditions:</span>
<span class="comment">//</span>
<span class="comment">// The above copyright notice and this permission notice shall be included</span>
<span class="comment">// in all copies or substantial portions of the Software.</span>
<span class="comment">//</span>
<span class="comment">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="comment">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="comment">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="comment">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="comment">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="comment">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="comment">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="comment">// A bit simpler than readable streams.</span>
<span class="comment">// Implement an async ._write(chunk, encoding, cb), and it'll handle all</span>
<span class="comment">// the drain event emission and buffering.</span>

<span class="string">'use strict'</span>;

<span class="comment">/*&lt;replacement>*/</span>

<span class="keyword">var</span> pna = require(<span class="string">'process-nextick-args'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

module.exports = Writable;

<span class="comment">/* &lt;replacement> */</span>
<span class="function"><span class="keyword">function</span> <span class="title">WriteReq</span><span class="params">(chunk, encoding, cb)</span> {</span>
  <span class="keyword">this</span>.chunk = chunk;
  <span class="keyword">this</span>.encoding = encoding;
  <span class="keyword">this</span>.callback = cb;
  <span class="keyword">this</span>.next = <span class="literal">null</span>;
}

<span class="comment">// It seems a linked list but it is not</span>
<span class="comment">// there will be only 2 of these for each stream</span>
<span class="function"><span class="keyword">function</span> <span class="title">CorkedRequest</span><span class="params">(state)</span> {</span>
  <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

  <span class="keyword">this</span>.next = <span class="literal">null</span>;
  <span class="keyword">this</span>.entry = <span class="literal">null</span>;
  <span class="keyword">this</span>.finish = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    onCorkedFinish(_<span class="keyword">this</span>, state);
  };
}
<span class="comment">/* &lt;/replacement> */</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> asyncWrite = !process.browser &amp;&amp; [<span class="string">'v0.10'</span>, <span class="string">'v0.9.'</span>].indexOf(process.version.slice(<span class="number">0</span>, <span class="number">5</span>)) > -<span class="number">1</span> ? setImmediate : pna.nextTick;
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> Duplex;
<span class="comment">/*&lt;/replacement>*/</span>

Writable.WritableState = WritableState;

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> util = require(<span class="string">'core-util-is'</span>);
util.inherits = require(<span class="string">'inherits'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> internalUtil = {
  deprecate: require(<span class="string">'util-deprecate'</span>)
};
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> Stream = require(<span class="string">'./internal/streams/stream'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>

<span class="keyword">var</span> Buffer = require(<span class="string">'safe-buffer'</span>).Buffer;
<span class="keyword">var</span> OurUint8Array = global.Uint8Array || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
<span class="function"><span class="keyword">function</span> <span class="title">_uint8ArrayToBuffer</span><span class="params">(chunk)</span> {</span>
  <span class="keyword">return</span> Buffer.from(chunk);
}
<span class="function"><span class="keyword">function</span> <span class="title">_isUint8Array</span><span class="params">(obj)</span> {</span>
  <span class="keyword">return</span> Buffer.isBuffer(obj) || obj <span class="keyword">instanceof</span> OurUint8Array;
}

<span class="comment">/*&lt;/replacement>*/</span>

<span class="keyword">var</span> destroyImpl = require(<span class="string">'./internal/streams/destroy'</span>);

util.inherits(Writable, Stream);

<span class="function"><span class="keyword">function</span> <span class="title">nop</span><span class="params">()</span> {</span>}

<span class="function"><span class="keyword">function</span> <span class="title">WritableState</span><span class="params">(options, stream)</span> {</span>
  Duplex = Duplex || require(<span class="string">'./_stream_duplex'</span>);

  options = options || {};

  <span class="comment">// Duplex streams are both readable and writable, but share</span>
  <span class="comment">// the same options object.</span>
  <span class="comment">// However, some cases require setting options to different</span>
  <span class="comment">// values for the readable and the writable sides of the duplex stream.</span>
  <span class="comment">// These options can be provided separately as readableXXX and writableXXX.</span>
  <span class="keyword">var</span> isDuplex = stream <span class="keyword">instanceof</span> Duplex;

  <span class="comment">// object stream flag to indicate whether or not this stream</span>
  <span class="comment">// contains buffers or objects.</span>
  <span class="keyword">this</span>.objectMode = !!options.objectMode;

  <span class="keyword">if</span> (isDuplex) <span class="keyword">this</span>.objectMode = <span class="keyword">this</span>.objectMode || !!options.writableObjectMode;

  <span class="comment">// the point at which write() starts returning false</span>
  <span class="comment">// Note: 0 is a valid value, means that we always return false if</span>
  <span class="comment">// the entire buffer is not flushed immediately on write()</span>
  <span class="keyword">var</span> hwm = options.highWaterMark;
  <span class="keyword">var</span> writableHwm = options.writableHighWaterMark;
  <span class="keyword">var</span> defaultHwm = <span class="keyword">this</span>.objectMode ? <span class="number">16</span> : <span class="number">16</span> * <span class="number">1024</span>;

  <span class="keyword">if</span> (hwm || hwm === <span class="number">0</span>) <span class="keyword">this</span>.highWaterMark = hwm;<span class="keyword">else</span> <span class="keyword">if</span> (isDuplex &amp;&amp; (writableHwm || writableHwm === <span class="number">0</span>)) <span class="keyword">this</span>.highWaterMark = writableHwm;<span class="keyword">else</span> <span class="keyword">this</span>.highWaterMark = defaultHwm;

  <span class="comment">// cast to ints.</span>
  <span class="keyword">this</span>.highWaterMark = Math.floor(<span class="keyword">this</span>.highWaterMark);

  <span class="comment">// if _final has been called</span>
  <span class="keyword">this</span>.finalCalled = <span class="literal">false</span>;

  <span class="comment">// drain event flag.</span>
  <span class="keyword">this</span>.needDrain = <span class="literal">false</span>;
  <span class="comment">// at the start of calling end()</span>
  <span class="keyword">this</span>.ending = <span class="literal">false</span>;
  <span class="comment">// when end() has been called, and returned</span>
  <span class="keyword">this</span>.ended = <span class="literal">false</span>;
  <span class="comment">// when 'finish' is emitted</span>
  <span class="keyword">this</span>.finished = <span class="literal">false</span>;

  <span class="comment">// has it been destroyed</span>
  <span class="keyword">this</span>.destroyed = <span class="literal">false</span>;

  <span class="comment">// should we decode strings into buffers before passing to _write?</span>
  <span class="comment">// this is here so that some node-core streams can optimize string</span>
  <span class="comment">// handling at a lower level.</span>
  <span class="keyword">var</span> noDecode = options.decodeStrings === <span class="literal">false</span>;
  <span class="keyword">this</span>.decodeStrings = !noDecode;

  <span class="comment">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="comment">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="comment">// Everything else in the universe uses 'utf8', though.</span>
  <span class="keyword">this</span>.defaultEncoding = options.defaultEncoding || <span class="string">'utf8'</span>;

  <span class="comment">// not an actual buffer we keep track of, but a measurement</span>
  <span class="comment">// of how much we're waiting to get pushed to some underlying</span>
  <span class="comment">// socket or file.</span>
  <span class="keyword">this</span>.length = <span class="number">0</span>;

  <span class="comment">// a flag to see when we're in the middle of a write.</span>
  <span class="keyword">this</span>.writing = <span class="literal">false</span>;

  <span class="comment">// when true all writes will be buffered until .uncork() call</span>
  <span class="keyword">this</span>.corked = <span class="number">0</span>;

  <span class="comment">// a flag to be able to tell if the onwrite cb is called immediately,</span>
  <span class="comment">// or on a later tick.  We set this to true at first, because any</span>
  <span class="comment">// actions that shouldn't happen until "later" should generally also</span>
  <span class="comment">// not happen before the first write call.</span>
  <span class="keyword">this</span>.sync = <span class="literal">true</span>;

  <span class="comment">// a flag to know if we're processing previously buffered items, which</span>
  <span class="comment">// may call the _write() callback in the same tick, so that we don't</span>
  <span class="comment">// end up in an overlapped onwrite situation.</span>
  <span class="keyword">this</span>.bufferProcessing = <span class="literal">false</span>;

  <span class="comment">// the callback that's passed to _write(chunk,cb)</span>
  <span class="keyword">this</span>.onwrite = <span class="function"><span class="keyword">function</span> <span class="params">(er)</span> {</span>
    onwrite(stream, er);
  };

  <span class="comment">// the callback that the user supplies to write(chunk,encoding,cb)</span>
  <span class="keyword">this</span>.writecb = <span class="literal">null</span>;

  <span class="comment">// the amount that is being written when _write is called.</span>
  <span class="keyword">this</span>.writelen = <span class="number">0</span>;

  <span class="keyword">this</span>.bufferedRequest = <span class="literal">null</span>;
  <span class="keyword">this</span>.lastBufferedRequest = <span class="literal">null</span>;

  <span class="comment">// number of pending user-supplied write callbacks</span>
  <span class="comment">// this must be 0 before 'finish' can be emitted</span>
  <span class="keyword">this</span>.pendingcb = <span class="number">0</span>;

  <span class="comment">// emit prefinish if the only thing we're waiting for is _write cbs</span>
  <span class="comment">// This is relevant for synchronous Transform streams</span>
  <span class="keyword">this</span>.prefinished = <span class="literal">false</span>;

  <span class="comment">// True if the error was already emitted and should not be thrown again</span>
  <span class="keyword">this</span>.errorEmitted = <span class="literal">false</span>;

  <span class="comment">// count buffered requests</span>
  <span class="keyword">this</span>.bufferedRequestCount = <span class="number">0</span>;

  <span class="comment">// allocate the first CorkedRequest, there is always</span>
  <span class="comment">// one allocated and free to use, and we maintain at most two</span>
  <span class="keyword">this</span>.corkedRequestsFree = <span class="keyword">new</span> CorkedRequest(<span class="keyword">this</span>);
}

WritableState.prototype.getBuffer = <span class="function"><span class="keyword">function</span> <span class="title">getBuffer</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> current = <span class="keyword">this</span>.bufferedRequest;
  <span class="keyword">var</span> out = [];
  <span class="keyword">while</span> (current) {
    out.push(current);
    current = current.next;
  }
  <span class="keyword">return</span> out;
};

(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">try</span> {
    Object.defineProperty(WritableState.prototype, <span class="string">'buffer'</span>, {
      get: internalUtil.deprecate(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.getBuffer();
      }, <span class="string">'_writableState.buffer is deprecated. Use _writableState.getBuffer '</span> + <span class="string">'instead.'</span>, <span class="string">'DEP0003'</span>)
    });
  } <span class="keyword">catch</span> (_) {}
})();

<span class="comment">// Test _writableState for inheritance to account for Duplex streams,</span>
<span class="comment">// whose prototype chain only points to Readable.</span>
<span class="keyword">var</span> realHasInstance;
<span class="keyword">if</span> (<span class="keyword">typeof</span> Symbol === <span class="string">'function'</span> &amp;&amp; Symbol.hasInstance &amp;&amp; <span class="keyword">typeof</span> Function.prototype[Symbol.hasInstance] === <span class="string">'function'</span>) {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: <span class="function"><span class="keyword">function</span> <span class="params">(object)</span> {</span>
      <span class="keyword">if</span> (realHasInstance.call(<span class="keyword">this</span>, object)) <span class="keyword">return</span> <span class="literal">true</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span> !== Writable) <span class="keyword">return</span> <span class="literal">false</span>;

      <span class="keyword">return</span> object &amp;&amp; object._writableState <span class="keyword">instanceof</span> WritableState;
    }
  });
} <span class="keyword">else</span> {
  realHasInstance = <span class="function"><span class="keyword">function</span> <span class="params">(object)</span> {</span>
    <span class="keyword">return</span> object <span class="keyword">instanceof</span> <span class="keyword">this</span>;
  };
}

<span class="function"><span class="keyword">function</span> <span class="title">Writable</span><span class="params">(options)</span> {</span>
  Duplex = Duplex || require(<span class="string">'./_stream_duplex'</span>);

  <span class="comment">// Writable ctor is applied to Duplexes, too.</span>
  <span class="comment">// `realHasInstance` is necessary because using plain `instanceof`</span>
  <span class="comment">// would return false, as no `_writableState` property is attached.</span>

  <span class="comment">// Trying to use the custom `instanceof` for Writable here will also break the</span>
  <span class="comment">// Node.js LazyTransform implementation, which has a non-trivial getter for</span>
  <span class="comment">// `_writableState` that would lead to infinite recursion.</span>
  <span class="keyword">if</span> (!realHasInstance.call(Writable, <span class="keyword">this</span>) &amp;&amp; !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Duplex)) {
    <span class="keyword">return</span> <span class="keyword">new</span> Writable(options);
  }

  <span class="keyword">this</span>._writableState = <span class="keyword">new</span> WritableState(options, <span class="keyword">this</span>);

  <span class="comment">// legacy.</span>
  <span class="keyword">this</span>.writable = <span class="literal">true</span>;

  <span class="keyword">if</span> (options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.write === <span class="string">'function'</span>) <span class="keyword">this</span>._write = options.write;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.writev === <span class="string">'function'</span>) <span class="keyword">this</span>._writev = options.writev;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.destroy === <span class="string">'function'</span>) <span class="keyword">this</span>._destroy = options.destroy;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.final === <span class="string">'function'</span>) <span class="keyword">this</span>._final = options.final;
  }

  Stream.call(<span class="keyword">this</span>);
}

<span class="comment">// Otherwise people can pipe Writable streams, which is just wrong.</span>
Writable.prototype.pipe = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">this</span>.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">'Cannot pipe, not readable'</span>));
};

<span class="function"><span class="keyword">function</span> <span class="title">writeAfterEnd</span><span class="params">(stream, cb)</span> {</span>
  <span class="keyword">var</span> er = <span class="keyword">new</span> Error(<span class="string">'write after end'</span>);
  <span class="comment">// TODO: defer error events consistently everywhere, not just the cb</span>
  stream.emit(<span class="string">'error'</span>, er);
  pna.nextTick(cb, er);
}

<span class="comment">// Checks that a user-supplied chunk is valid, especially for the particular</span>
<span class="comment">// mode the stream is in. Currently this means that `null` is never accepted</span>
<span class="comment">// and undefined/non-string values are only allowed in object mode.</span>
<span class="function"><span class="keyword">function</span> <span class="title">validChunk</span><span class="params">(stream, state, chunk, cb)</span> {</span>
  <span class="keyword">var</span> valid = <span class="literal">true</span>;
  <span class="keyword">var</span> er = <span class="literal">false</span>;

  <span class="keyword">if</span> (chunk === <span class="literal">null</span>) {
    er = <span class="keyword">new</span> TypeError(<span class="string">'May not write null values to stream'</span>);
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk !== <span class="string">'string'</span> &amp;&amp; chunk !== <span class="literal">undefined</span> &amp;&amp; !state.objectMode) {
    er = <span class="keyword">new</span> TypeError(<span class="string">'Invalid non-string/buffer chunk'</span>);
  }
  <span class="keyword">if</span> (er) {
    stream.emit(<span class="string">'error'</span>, er);
    pna.nextTick(cb, er);
    valid = <span class="literal">false</span>;
  }
  <span class="keyword">return</span> valid;
}

Writable.prototype.write = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding, cb)</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._writableState;
  <span class="keyword">var</span> ret = <span class="literal">false</span>;
  <span class="keyword">var</span> isBuf = !state.objectMode &amp;&amp; _isUint8Array(chunk);

  <span class="keyword">if</span> (isBuf &amp;&amp; !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> encoding === <span class="string">'function'</span>) {
    cb = encoding;
    encoding = <span class="literal">null</span>;
  }

  <span class="keyword">if</span> (isBuf) encoding = <span class="string">'buffer'</span>;<span class="keyword">else</span> <span class="keyword">if</span> (!encoding) encoding = state.defaultEncoding;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> cb !== <span class="string">'function'</span>) cb = nop;

  <span class="keyword">if</span> (state.ended) writeAfterEnd(<span class="keyword">this</span>, cb);<span class="keyword">else</span> <span class="keyword">if</span> (isBuf || validChunk(<span class="keyword">this</span>, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(<span class="keyword">this</span>, state, isBuf, chunk, encoding, cb);
  }

  <span class="keyword">return</span> ret;
};

Writable.prototype.cork = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._writableState;

  state.corked++;
};

Writable.prototype.uncork = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._writableState;

  <span class="keyword">if</span> (state.corked) {
    state.corked--;

    <span class="keyword">if</span> (!state.writing &amp;&amp; !state.corked &amp;&amp; !state.finished &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) clearBuffer(<span class="keyword">this</span>, state);
  }
};

Writable.prototype.setDefaultEncoding = <span class="function"><span class="keyword">function</span> <span class="title">setDefaultEncoding</span><span class="params">(encoding)</span> {</span>
  <span class="comment">// node::ParseEncoding() requires lower case.</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> encoding === <span class="string">'string'</span>) encoding = encoding.toLowerCase();
  <span class="keyword">if</span> (!([<span class="string">'hex'</span>, <span class="string">'utf8'</span>, <span class="string">'utf-8'</span>, <span class="string">'ascii'</span>, <span class="string">'binary'</span>, <span class="string">'base64'</span>, <span class="string">'ucs2'</span>, <span class="string">'ucs-2'</span>, <span class="string">'utf16le'</span>, <span class="string">'utf-16le'</span>, <span class="string">'raw'</span>].indexOf((encoding + <span class="string">''</span>).toLowerCase()) > -<span class="number">1</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Unknown encoding: '</span> + encoding);
  <span class="keyword">this</span>._writableState.defaultEncoding = encoding;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="function"><span class="keyword">function</span> <span class="title">decodeChunk</span><span class="params">(state, chunk, encoding)</span> {</span>
  <span class="keyword">if</span> (!state.objectMode &amp;&amp; state.decodeStrings !== <span class="literal">false</span> &amp;&amp; <span class="keyword">typeof</span> chunk === <span class="string">'string'</span>) {
    chunk = Buffer.from(chunk, encoding);
  }
  <span class="keyword">return</span> chunk;
}

Object.defineProperty(Writable.prototype, <span class="string">'writableHighWaterMark'</span>, {
  <span class="comment">// making it explicit this property is not enumerable</span>
  <span class="comment">// because otherwise some prototype manipulation in</span>
  <span class="comment">// userland will fail</span>
  enumerable: <span class="literal">false</span>,
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._writableState.highWaterMark;
  }
});

<span class="comment">// if we're already writing something, then just put this</span>
<span class="comment">// in the queue, and wait our turn.  Otherwise, call _write</span>
<span class="comment">// If we return false, then we need a drain event, so set that flag.</span>
<span class="function"><span class="keyword">function</span> <span class="title">writeOrBuffer</span><span class="params">(stream, state, isBuf, chunk, encoding, cb)</span> {</span>
  <span class="keyword">if</span> (!isBuf) {
    <span class="keyword">var</span> newChunk = decodeChunk(state, chunk, encoding);
    <span class="keyword">if</span> (chunk !== newChunk) {
      isBuf = <span class="literal">true</span>;
      encoding = <span class="string">'buffer'</span>;
      chunk = newChunk;
    }
  }
  <span class="keyword">var</span> len = state.objectMode ? <span class="number">1</span> : chunk.length;

  state.length += len;

  <span class="keyword">var</span> ret = state.length &lt; state.highWaterMark;
  <span class="comment">// we must ensure that previous needDrain will not be reset to false.</span>
  <span class="keyword">if</span> (!ret) state.needDrain = <span class="literal">true</span>;

  <span class="keyword">if</span> (state.writing || state.corked) {
    <span class="keyword">var</span> last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: <span class="literal">null</span>
    };
    <span class="keyword">if</span> (last) {
      last.next = state.lastBufferedRequest;
    } <span class="keyword">else</span> {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += <span class="number">1</span>;
  } <span class="keyword">else</span> {
    doWrite(stream, state, <span class="literal">false</span>, len, chunk, encoding, cb);
  }

  <span class="keyword">return</span> ret;
}

<span class="function"><span class="keyword">function</span> <span class="title">doWrite</span><span class="params">(stream, state, writev, len, chunk, encoding, cb)</span> {</span>
  state.writelen = len;
  state.writecb = cb;
  state.writing = <span class="literal">true</span>;
  state.sync = <span class="literal">true</span>;
  <span class="keyword">if</span> (writev) stream._writev(chunk, state.onwrite);<span class="keyword">else</span> stream._write(chunk, encoding, state.onwrite);
  state.sync = <span class="literal">false</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">onwriteError</span><span class="params">(stream, state, sync, er, cb)</span> {</span>
  --state.pendingcb;

  <span class="keyword">if</span> (sync) {
    <span class="comment">// defer the callback if we are being called synchronously</span>
    <span class="comment">// to avoid piling up things on the stack</span>
    pna.nextTick(cb, er);
    <span class="comment">// this can emit finish, and it will always happen</span>
    <span class="comment">// after error</span>
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = <span class="literal">true</span>;
    stream.emit(<span class="string">'error'</span>, er);
  } <span class="keyword">else</span> {
    <span class="comment">// the caller expect this to happen before if</span>
    <span class="comment">// it is async</span>
    cb(er);
    stream._writableState.errorEmitted = <span class="literal">true</span>;
    stream.emit(<span class="string">'error'</span>, er);
    <span class="comment">// this can emit finish, but finish must</span>
    <span class="comment">// always follow error</span>
    finishMaybe(stream, state);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">onwriteStateUpdate</span><span class="params">(state)</span> {</span>
  state.writing = <span class="literal">false</span>;
  state.writecb = <span class="literal">null</span>;
  state.length -= state.writelen;
  state.writelen = <span class="number">0</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">onwrite</span><span class="params">(stream, er)</span> {</span>
  <span class="keyword">var</span> state = stream._writableState;
  <span class="keyword">var</span> sync = state.sync;
  <span class="keyword">var</span> cb = state.writecb;

  onwriteStateUpdate(state);

  <span class="keyword">if</span> (er) onwriteError(stream, state, sync, er, cb);<span class="keyword">else</span> {
    <span class="comment">// Check if we're actually ready to finish, but don't emit yet</span>
    <span class="keyword">var</span> finished = needFinish(state);

    <span class="keyword">if</span> (!finished &amp;&amp; !state.corked &amp;&amp; !state.bufferProcessing &amp;&amp; state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    <span class="keyword">if</span> (sync) {
      <span class="comment">/*&lt;replacement>*/</span>
      asyncWrite(afterWrite, stream, state, finished, cb);
      <span class="comment">/*&lt;/replacement>*/</span>
    } <span class="keyword">else</span> {
      afterWrite(stream, state, finished, cb);
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">afterWrite</span><span class="params">(stream, state, finished, cb)</span> {</span>
  <span class="keyword">if</span> (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

<span class="comment">// Must force callback to be called on nextTick, so that we don't</span>
<span class="comment">// emit 'drain' before the write() consumer gets the 'false' return</span>
<span class="comment">// value, and has a chance to attach a 'drain' listener.</span>
<span class="function"><span class="keyword">function</span> <span class="title">onwriteDrain</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (state.length === <span class="number">0</span> &amp;&amp; state.needDrain) {
    state.needDrain = <span class="literal">false</span>;
    stream.emit(<span class="string">'drain'</span>);
  }
}

<span class="comment">// if there's something in the buffer waiting, then process it</span>
<span class="function"><span class="keyword">function</span> <span class="title">clearBuffer</span><span class="params">(stream, state)</span> {</span>
  state.bufferProcessing = <span class="literal">true</span>;
  <span class="keyword">var</span> entry = state.bufferedRequest;

  <span class="keyword">if</span> (stream._writev &amp;&amp; entry &amp;&amp; entry.next) {
    <span class="comment">// Fast case, write everything using _writev()</span>
    <span class="keyword">var</span> l = state.bufferedRequestCount;
    <span class="keyword">var</span> buffer = <span class="keyword">new</span> Array(l);
    <span class="keyword">var</span> holder = state.corkedRequestsFree;
    holder.entry = entry;

    <span class="keyword">var</span> count = <span class="number">0</span>;
    <span class="keyword">var</span> allBuffers = <span class="literal">true</span>;
    <span class="keyword">while</span> (entry) {
      buffer[count] = entry;
      <span class="keyword">if</span> (!entry.isBuf) allBuffers = <span class="literal">false</span>;
      entry = entry.next;
      count += <span class="number">1</span>;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, <span class="literal">true</span>, state.length, buffer, <span class="string">''</span>, holder.finish);

    <span class="comment">// doWrite is almost always async, defer these to save a bit of time</span>
    <span class="comment">// as the hot path ends with doWrite</span>
    state.pendingcb++;
    state.lastBufferedRequest = <span class="literal">null</span>;
    <span class="keyword">if</span> (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = <span class="literal">null</span>;
    } <span class="keyword">else</span> {
      state.corkedRequestsFree = <span class="keyword">new</span> CorkedRequest(state);
    }
    state.bufferedRequestCount = <span class="number">0</span>;
  } <span class="keyword">else</span> {
    <span class="comment">// Slow case, write chunks one-by-one</span>
    <span class="keyword">while</span> (entry) {
      <span class="keyword">var</span> chunk = entry.chunk;
      <span class="keyword">var</span> encoding = entry.encoding;
      <span class="keyword">var</span> cb = entry.callback;
      <span class="keyword">var</span> len = state.objectMode ? <span class="number">1</span> : chunk.length;

      doWrite(stream, state, <span class="literal">false</span>, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      <span class="comment">// if we didn't call the onwrite immediately, then</span>
      <span class="comment">// it means that we need to wait until it does.</span>
      <span class="comment">// also, that means that the chunk and cb are currently</span>
      <span class="comment">// being processed, so move the buffer counter past them.</span>
      <span class="keyword">if</span> (state.writing) {
        <span class="keyword">break</span>;
      }
    }

    <span class="keyword">if</span> (entry === <span class="literal">null</span>) state.lastBufferedRequest = <span class="literal">null</span>;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = <span class="literal">false</span>;
}

Writable.prototype._write = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding, cb)</span> {</span>
  cb(<span class="keyword">new</span> Error(<span class="string">'_write() is not implemented'</span>));
};

Writable.prototype._writev = <span class="literal">null</span>;

Writable.prototype.end = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding, cb)</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._writableState;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">'function'</span>) {
    cb = chunk;
    chunk = <span class="literal">null</span>;
    encoding = <span class="literal">null</span>;
  } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> encoding === <span class="string">'function'</span>) {
    cb = encoding;
    encoding = <span class="literal">null</span>;
  }

  <span class="keyword">if</span> (chunk !== <span class="literal">null</span> &amp;&amp; chunk !== <span class="literal">undefined</span>) <span class="keyword">this</span>.write(chunk, encoding);

  <span class="comment">// .end() fully uncorks</span>
  <span class="keyword">if</span> (state.corked) {
    state.corked = <span class="number">1</span>;
    <span class="keyword">this</span>.uncork();
  }

  <span class="comment">// ignore unnecessary end() calls.</span>
  <span class="keyword">if</span> (!state.ending &amp;&amp; !state.finished) endWritable(<span class="keyword">this</span>, state, cb);
};

<span class="function"><span class="keyword">function</span> <span class="title">needFinish</span><span class="params">(state)</span> {</span>
  <span class="keyword">return</span> state.ending &amp;&amp; state.length === <span class="number">0</span> &amp;&amp; state.bufferedRequest === <span class="literal">null</span> &amp;&amp; !state.finished &amp;&amp; !state.writing;
}
<span class="function"><span class="keyword">function</span> <span class="title">callFinal</span><span class="params">(stream, state)</span> {</span>
  stream._final(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    state.pendingcb--;
    <span class="keyword">if</span> (err) {
      stream.emit(<span class="string">'error'</span>, err);
    }
    state.prefinished = <span class="literal">true</span>;
    stream.emit(<span class="string">'prefinish'</span>);
    finishMaybe(stream, state);
  });
}
<span class="function"><span class="keyword">function</span> <span class="title">prefinish</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (!state.prefinished &amp;&amp; !state.finalCalled) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> stream._final === <span class="string">'function'</span>) {
      state.pendingcb++;
      state.finalCalled = <span class="literal">true</span>;
      pna.nextTick(callFinal, stream, state);
    } <span class="keyword">else</span> {
      state.prefinished = <span class="literal">true</span>;
      stream.emit(<span class="string">'prefinish'</span>);
    }
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">finishMaybe</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">var</span> need = needFinish(state);
  <span class="keyword">if</span> (need) {
    prefinish(stream, state);
    <span class="keyword">if</span> (state.pendingcb === <span class="number">0</span>) {
      state.finished = <span class="literal">true</span>;
      stream.emit(<span class="string">'finish'</span>);
    }
  }
  <span class="keyword">return</span> need;
}

<span class="function"><span class="keyword">function</span> <span class="title">endWritable</span><span class="params">(stream, state, cb)</span> {</span>
  state.ending = <span class="literal">true</span>;
  finishMaybe(stream, state);
  <span class="keyword">if</span> (cb) {
    <span class="keyword">if</span> (state.finished) pna.nextTick(cb);<span class="keyword">else</span> stream.once(<span class="string">'finish'</span>, cb);
  }
  state.ended = <span class="literal">true</span>;
  stream.writable = <span class="literal">false</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">onCorkedFinish</span><span class="params">(corkReq, state, err)</span> {</span>
  <span class="keyword">var</span> entry = corkReq.entry;
  corkReq.entry = <span class="literal">null</span>;
  <span class="keyword">while</span> (entry) {
    <span class="keyword">var</span> cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  <span class="keyword">if</span> (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } <span class="keyword">else</span> {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, <span class="string">'destroyed'</span>, {
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>._writableState === <span class="literal">undefined</span>) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>._writableState.destroyed;
  },
  set: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
    <span class="comment">// we ignore the value if the stream</span>
    <span class="comment">// has not been initialized yet</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>._writableState) {
      <span class="keyword">return</span>;
    }

    <span class="comment">// backward compatibility, the user is explicitly</span>
    <span class="comment">// managing destroyed</span>
    <span class="keyword">this</span>._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = <span class="function"><span class="keyword">function</span> <span class="params">(err, cb)</span> {</span>
  <span class="keyword">this</span>.end();
  cb(err);
};</code></pre>