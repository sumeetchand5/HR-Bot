<h1>_stream_readable.js</h1>
<pre><code class="lang-js"><span class="comment">// Copyright Joyent, Inc. and other Node contributors.</span>
<span class="comment">//</span>
<span class="comment">// Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="comment">// copy of this software and associated documentation files (the</span>
<span class="comment">// "Software"), to deal in the Software without restriction, including</span>
<span class="comment">// without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="comment">// distribute, sublicense, and/or sell copies of the Software, and to permit</span>
<span class="comment">// persons to whom the Software is furnished to do so, subject to the</span>
<span class="comment">// following conditions:</span>
<span class="comment">//</span>
<span class="comment">// The above copyright notice and this permission notice shall be included</span>
<span class="comment">// in all copies or substantial portions of the Software.</span>
<span class="comment">//</span>
<span class="comment">// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS</span>
<span class="comment">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="comment">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span>
<span class="comment">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span>
<span class="comment">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span>
<span class="comment">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span>
<span class="comment">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span>

<span class="string">'use strict'</span>;

<span class="comment">/*&lt;replacement>*/</span>

<span class="keyword">var</span> pna = require(<span class="string">'process-nextick-args'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

module.exports = Readable;

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> isArray = require(<span class="string">'isarray'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> Duplex;
<span class="comment">/*&lt;/replacement>*/</span>

Readable.ReadableState = ReadableState;

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> EE = require(<span class="string">'events'</span>).EventEmitter;

<span class="keyword">var</span> EElistenerCount = <span class="function"><span class="keyword">function</span> <span class="params">(emitter, type)</span> {</span>
  <span class="keyword">return</span> emitter.listeners(type).length;
};
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> Stream = require(<span class="string">'./internal/streams/stream'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>

<span class="keyword">var</span> Buffer = require(<span class="string">'safe-buffer'</span>).Buffer;
<span class="keyword">var</span> OurUint8Array = global.Uint8Array || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
<span class="function"><span class="keyword">function</span> <span class="title">_uint8ArrayToBuffer</span><span class="params">(chunk)</span> {</span>
  <span class="keyword">return</span> Buffer.from(chunk);
}
<span class="function"><span class="keyword">function</span> <span class="title">_isUint8Array</span><span class="params">(obj)</span> {</span>
  <span class="keyword">return</span> Buffer.isBuffer(obj) || obj <span class="keyword">instanceof</span> OurUint8Array;
}

<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> util = require(<span class="string">'core-util-is'</span>);
util.inherits = require(<span class="string">'inherits'</span>);
<span class="comment">/*&lt;/replacement>*/</span>

<span class="comment">/*&lt;replacement>*/</span>
<span class="keyword">var</span> debugUtil = require(<span class="string">'util'</span>);
<span class="keyword">var</span> debug = <span class="keyword">void</span> <span class="number">0</span>;
<span class="keyword">if</span> (debugUtil &amp;&amp; debugUtil.debuglog) {
  debug = debugUtil.debuglog(<span class="string">'stream'</span>);
} <span class="keyword">else</span> {
  debug = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>};
}
<span class="comment">/*&lt;/replacement>*/</span>

<span class="keyword">var</span> BufferList = require(<span class="string">'./internal/streams/BufferList'</span>);
<span class="keyword">var</span> destroyImpl = require(<span class="string">'./internal/streams/destroy'</span>);
<span class="keyword">var</span> StringDecoder;

util.inherits(Readable, Stream);

<span class="keyword">var</span> kProxyEvents = [<span class="string">'error'</span>, <span class="string">'close'</span>, <span class="string">'destroy'</span>, <span class="string">'pause'</span>, <span class="string">'resume'</span>];

<span class="function"><span class="keyword">function</span> <span class="title">prependListener</span><span class="params">(emitter, event, fn)</span> {</span>
  <span class="comment">// Sadly this is not cacheable as some libraries bundle their own</span>
  <span class="comment">// event emitter implementation with them.</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> emitter.prependListener === <span class="string">'function'</span>) <span class="keyword">return</span> emitter.prependListener(event, fn);

  <span class="comment">// This is a hack to make sure that our error handler is attached before any</span>
  <span class="comment">// userland ones.  NEVER DO THIS. This is here only because this code needs</span>
  <span class="comment">// to continue to work with older versions of Node.js that do not include</span>
  <span class="comment">// the prependListener() method. The goal is to eventually remove this hack.</span>
  <span class="keyword">if</span> (!emitter._events || !emitter._events[event]) emitter.on(event, fn);<span class="keyword">else</span> <span class="keyword">if</span> (isArray(emitter._events[event])) emitter._events[event].unshift(fn);<span class="keyword">else</span> emitter._events[event] = [fn, emitter._events[event]];
}

<span class="function"><span class="keyword">function</span> <span class="title">ReadableState</span><span class="params">(options, stream)</span> {</span>
  Duplex = Duplex || require(<span class="string">'./_stream_duplex'</span>);

  options = options || {};

  <span class="comment">// Duplex streams are both readable and writable, but share</span>
  <span class="comment">// the same options object.</span>
  <span class="comment">// However, some cases require setting options to different</span>
  <span class="comment">// values for the readable and the writable sides of the duplex stream.</span>
  <span class="comment">// These options can be provided separately as readableXXX and writableXXX.</span>
  <span class="keyword">var</span> isDuplex = stream <span class="keyword">instanceof</span> Duplex;

  <span class="comment">// object stream flag. Used to make read(n) ignore n and to</span>
  <span class="comment">// make all the buffer merging and length checks go away</span>
  <span class="keyword">this</span>.objectMode = !!options.objectMode;

  <span class="keyword">if</span> (isDuplex) <span class="keyword">this</span>.objectMode = <span class="keyword">this</span>.objectMode || !!options.readableObjectMode;

  <span class="comment">// the point at which it stops calling _read() to fill the buffer</span>
  <span class="comment">// Note: 0 is a valid value, means "don't call _read preemptively ever"</span>
  <span class="keyword">var</span> hwm = options.highWaterMark;
  <span class="keyword">var</span> readableHwm = options.readableHighWaterMark;
  <span class="keyword">var</span> defaultHwm = <span class="keyword">this</span>.objectMode ? <span class="number">16</span> : <span class="number">16</span> * <span class="number">1024</span>;

  <span class="keyword">if</span> (hwm || hwm === <span class="number">0</span>) <span class="keyword">this</span>.highWaterMark = hwm;<span class="keyword">else</span> <span class="keyword">if</span> (isDuplex &amp;&amp; (readableHwm || readableHwm === <span class="number">0</span>)) <span class="keyword">this</span>.highWaterMark = readableHwm;<span class="keyword">else</span> <span class="keyword">this</span>.highWaterMark = defaultHwm;

  <span class="comment">// cast to ints.</span>
  <span class="keyword">this</span>.highWaterMark = Math.floor(<span class="keyword">this</span>.highWaterMark);

  <span class="comment">// A linked list is used to store data chunks instead of an array because the</span>
  <span class="comment">// linked list can remove elements from the beginning faster than</span>
  <span class="comment">// array.shift()</span>
  <span class="keyword">this</span>.buffer = <span class="keyword">new</span> BufferList();
  <span class="keyword">this</span>.length = <span class="number">0</span>;
  <span class="keyword">this</span>.pipes = <span class="literal">null</span>;
  <span class="keyword">this</span>.pipesCount = <span class="number">0</span>;
  <span class="keyword">this</span>.flowing = <span class="literal">null</span>;
  <span class="keyword">this</span>.ended = <span class="literal">false</span>;
  <span class="keyword">this</span>.endEmitted = <span class="literal">false</span>;
  <span class="keyword">this</span>.reading = <span class="literal">false</span>;

  <span class="comment">// a flag to be able to tell if the event 'readable'/'data' is emitted</span>
  <span class="comment">// immediately, or on a later tick.  We set this to true at first, because</span>
  <span class="comment">// any actions that shouldn't happen until "later" should generally also</span>
  <span class="comment">// not happen before the first read call.</span>
  <span class="keyword">this</span>.sync = <span class="literal">true</span>;

  <span class="comment">// whenever we return null, then we set a flag to say</span>
  <span class="comment">// that we're awaiting a 'readable' event emission.</span>
  <span class="keyword">this</span>.needReadable = <span class="literal">false</span>;
  <span class="keyword">this</span>.emittedReadable = <span class="literal">false</span>;
  <span class="keyword">this</span>.readableListening = <span class="literal">false</span>;
  <span class="keyword">this</span>.resumeScheduled = <span class="literal">false</span>;

  <span class="comment">// has it been destroyed</span>
  <span class="keyword">this</span>.destroyed = <span class="literal">false</span>;

  <span class="comment">// Crypto is kind of old and crusty.  Historically, its default string</span>
  <span class="comment">// encoding is 'binary' so we have to make this configurable.</span>
  <span class="comment">// Everything else in the universe uses 'utf8', though.</span>
  <span class="keyword">this</span>.defaultEncoding = options.defaultEncoding || <span class="string">'utf8'</span>;

  <span class="comment">// the number of writers that are awaiting a drain event in .pipe()s</span>
  <span class="keyword">this</span>.awaitDrain = <span class="number">0</span>;

  <span class="comment">// if true, a maybeReadMore has been scheduled</span>
  <span class="keyword">this</span>.readingMore = <span class="literal">false</span>;

  <span class="keyword">this</span>.decoder = <span class="literal">null</span>;
  <span class="keyword">this</span>.encoding = <span class="literal">null</span>;
  <span class="keyword">if</span> (options.encoding) {
    <span class="keyword">if</span> (!StringDecoder) StringDecoder = require(<span class="string">'string_decoder/'</span>).StringDecoder;
    <span class="keyword">this</span>.decoder = <span class="keyword">new</span> StringDecoder(options.encoding);
    <span class="keyword">this</span>.encoding = options.encoding;
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">Readable</span><span class="params">(options)</span> {</span>
  Duplex = Duplex || require(<span class="string">'./_stream_duplex'</span>);

  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Readable)) <span class="keyword">return</span> <span class="keyword">new</span> Readable(options);

  <span class="keyword">this</span>._readableState = <span class="keyword">new</span> ReadableState(options, <span class="keyword">this</span>);

  <span class="comment">// legacy</span>
  <span class="keyword">this</span>.readable = <span class="literal">true</span>;

  <span class="keyword">if</span> (options) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.read === <span class="string">'function'</span>) <span class="keyword">this</span>._read = options.read;

    <span class="keyword">if</span> (<span class="keyword">typeof</span> options.destroy === <span class="string">'function'</span>) <span class="keyword">this</span>._destroy = options.destroy;
  }

  Stream.call(<span class="keyword">this</span>);
}

Object.defineProperty(Readable.prototype, <span class="string">'destroyed'</span>, {
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>._readableState === <span class="literal">undefined</span>) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
    <span class="keyword">return</span> <span class="keyword">this</span>._readableState.destroyed;
  },
  set: <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
    <span class="comment">// we ignore the value if the stream</span>
    <span class="comment">// has not been initialized yet</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>._readableState) {
      <span class="keyword">return</span>;
    }

    <span class="comment">// backward compatibility, the user is explicitly</span>
    <span class="comment">// managing destroyed</span>
    <span class="keyword">this</span>._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = <span class="function"><span class="keyword">function</span> <span class="params">(err, cb)</span> {</span>
  <span class="keyword">this</span>.push(<span class="literal">null</span>);
  cb(err);
};

<span class="comment">// Manually shove something into the read() buffer.</span>
<span class="comment">// This returns true if the highWaterMark has not been hit yet,</span>
<span class="comment">// similar to how Writable.write() returns true if you should</span>
<span class="comment">// write() some more.</span>
Readable.prototype.push = <span class="function"><span class="keyword">function</span> <span class="params">(chunk, encoding)</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> skipChunkCheck;

  <span class="keyword">if</span> (!state.objectMode) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">'string'</span>) {
      encoding = encoding || state.defaultEncoding;
      <span class="keyword">if</span> (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = <span class="string">''</span>;
      }
      skipChunkCheck = <span class="literal">true</span>;
    }
  } <span class="keyword">else</span> {
    skipChunkCheck = <span class="literal">true</span>;
  }

  <span class="keyword">return</span> readableAddChunk(<span class="keyword">this</span>, chunk, encoding, <span class="literal">false</span>, skipChunkCheck);
};

<span class="comment">// Unshift should *always* be something directly out of read()</span>
Readable.prototype.unshift = <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
  <span class="keyword">return</span> readableAddChunk(<span class="keyword">this</span>, chunk, <span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">false</span>);
};

<span class="function"><span class="keyword">function</span> <span class="title">readableAddChunk</span><span class="params">(stream, chunk, encoding, addToFront, skipChunkCheck)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;
  <span class="keyword">if</span> (chunk === <span class="literal">null</span>) {
    state.reading = <span class="literal">false</span>;
    onEofChunk(stream, state);
  } <span class="keyword">else</span> {
    <span class="keyword">var</span> er;
    <span class="keyword">if</span> (!skipChunkCheck) er = chunkInvalid(state, chunk);
    <span class="keyword">if</span> (er) {
      stream.emit(<span class="string">'error'</span>, er);
    } <span class="keyword">else</span> <span class="keyword">if</span> (state.objectMode || chunk &amp;&amp; chunk.length > <span class="number">0</span>) {
      <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk !== <span class="string">'string'</span> &amp;&amp; !state.objectMode &amp;&amp; Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      <span class="keyword">if</span> (addToFront) {
        <span class="keyword">if</span> (state.endEmitted) stream.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">'stream.unshift() after end event'</span>));<span class="keyword">else</span> addChunk(stream, state, chunk, <span class="literal">true</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (state.ended) {
        stream.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">'stream.push() after EOF'</span>));
      } <span class="keyword">else</span> {
        state.reading = <span class="literal">false</span>;
        <span class="keyword">if</span> (state.decoder &amp;&amp; !encoding) {
          chunk = state.decoder.write(chunk);
          <span class="keyword">if</span> (state.objectMode || chunk.length !== <span class="number">0</span>) addChunk(stream, state, chunk, <span class="literal">false</span>);<span class="keyword">else</span> maybeReadMore(stream, state);
        } <span class="keyword">else</span> {
          addChunk(stream, state, chunk, <span class="literal">false</span>);
        }
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (!addToFront) {
      state.reading = <span class="literal">false</span>;
    }
  }

  <span class="keyword">return</span> needMoreData(state);
}

<span class="function"><span class="keyword">function</span> <span class="title">addChunk</span><span class="params">(stream, state, chunk, addToFront)</span> {</span>
  <span class="keyword">if</span> (state.flowing &amp;&amp; state.length === <span class="number">0</span> &amp;&amp; !state.sync) {
    stream.emit(<span class="string">'data'</span>, chunk);
    stream.read(<span class="number">0</span>);
  } <span class="keyword">else</span> {
    <span class="comment">// update the buffer info.</span>
    state.length += state.objectMode ? <span class="number">1</span> : chunk.length;
    <span class="keyword">if</span> (addToFront) state.buffer.unshift(chunk);<span class="keyword">else</span> state.buffer.push(chunk);

    <span class="keyword">if</span> (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

<span class="function"><span class="keyword">function</span> <span class="title">chunkInvalid</span><span class="params">(state, chunk)</span> {</span>
  <span class="keyword">var</span> er;
  <span class="keyword">if</span> (!_isUint8Array(chunk) &amp;&amp; <span class="keyword">typeof</span> chunk !== <span class="string">'string'</span> &amp;&amp; chunk !== <span class="literal">undefined</span> &amp;&amp; !state.objectMode) {
    er = <span class="keyword">new</span> TypeError(<span class="string">'Invalid non-string/buffer chunk'</span>);
  }
  <span class="keyword">return</span> er;
}

<span class="comment">// if it's past the high water mark, we can push in some more.</span>
<span class="comment">// Also, if we have no data yet, we can stand some</span>
<span class="comment">// more bytes.  This is to work around cases where hwm=0,</span>
<span class="comment">// such as the repl.  Also, if the push() triggered a</span>
<span class="comment">// readable event, and the user called read(largeNumber) such that</span>
<span class="comment">// needReadable was set, then we ought to push more, so that another</span>
<span class="comment">// 'readable' event will be triggered.</span>
<span class="function"><span class="keyword">function</span> <span class="title">needMoreData</span><span class="params">(state)</span> {</span>
  <span class="keyword">return</span> !state.ended &amp;&amp; (state.needReadable || state.length &lt; state.highWaterMark || state.length === <span class="number">0</span>);
}

Readable.prototype.isPaused = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>._readableState.flowing === <span class="literal">false</span>;
};

<span class="comment">// backwards compatibility.</span>
Readable.prototype.setEncoding = <span class="function"><span class="keyword">function</span> <span class="params">(enc)</span> {</span>
  <span class="keyword">if</span> (!StringDecoder) StringDecoder = require(<span class="string">'string_decoder/'</span>).StringDecoder;
  <span class="keyword">this</span>._readableState.decoder = <span class="keyword">new</span> StringDecoder(enc);
  <span class="keyword">this</span>._readableState.encoding = enc;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">// Don't raise the hwm > 8MB</span>
<span class="keyword">var</span> MAX_HWM = <span class="number">0x800000</span>;
<span class="function"><span class="keyword">function</span> <span class="title">computeNewHighWaterMark</span><span class="params">(n)</span> {</span>
  <span class="keyword">if</span> (n >= MAX_HWM) {
    n = MAX_HWM;
  } <span class="keyword">else</span> {
    <span class="comment">// Get the next highest power of 2 to prevent increasing hwm excessively in</span>
    <span class="comment">// tiny amounts</span>
    n--;
    n |= n >>> <span class="number">1</span>;
    n |= n >>> <span class="number">2</span>;
    n |= n >>> <span class="number">4</span>;
    n |= n >>> <span class="number">8</span>;
    n |= n >>> <span class="number">16</span>;
    n++;
  }
  <span class="keyword">return</span> n;
}

<span class="comment">// This function is designed to be inlinable, so please take care when making</span>
<span class="comment">// changes to the function body.</span>
<span class="function"><span class="keyword">function</span> <span class="title">howMuchToRead</span><span class="params">(n, state)</span> {</span>
  <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || state.length === <span class="number">0</span> &amp;&amp; state.ended) <span class="keyword">return</span> <span class="number">0</span>;
  <span class="keyword">if</span> (state.objectMode) <span class="keyword">return</span> <span class="number">1</span>;
  <span class="keyword">if</span> (n !== n) {
    <span class="comment">// Only flow one buffer at a time</span>
    <span class="keyword">if</span> (state.flowing &amp;&amp; state.length) <span class="keyword">return</span> state.buffer.head.data.length;<span class="keyword">else</span> <span class="keyword">return</span> state.length;
  }
  <span class="comment">// If we're asking for more than the current hwm, then raise the hwm.</span>
  <span class="keyword">if</span> (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  <span class="keyword">if</span> (n &lt;= state.length) <span class="keyword">return</span> n;
  <span class="comment">// Don't have enough</span>
  <span class="keyword">if</span> (!state.ended) {
    state.needReadable = <span class="literal">true</span>;
    <span class="keyword">return</span> <span class="number">0</span>;
  }
  <span class="keyword">return</span> state.length;
}

<span class="comment">// you can override either this method, or the async _read(n) below.</span>
Readable.prototype.read = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
  debug(<span class="string">'read'</span>, n);
  n = parseInt(n, <span class="number">10</span>);
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> nOrig = n;

  <span class="keyword">if</span> (n !== <span class="number">0</span>) state.emittedReadable = <span class="literal">false</span>;

  <span class="comment">// if we're doing read(0) to trigger a readable event, but we</span>
  <span class="comment">// already have a bunch of data in the buffer, then just trigger</span>
  <span class="comment">// the 'readable' event and move on.</span>
  <span class="keyword">if</span> (n === <span class="number">0</span> &amp;&amp; state.needReadable &amp;&amp; (state.length >= state.highWaterMark || state.ended)) {
    debug(<span class="string">'read: emitReadable'</span>, state.length, state.ended);
    <span class="keyword">if</span> (state.length === <span class="number">0</span> &amp;&amp; state.ended) endReadable(<span class="keyword">this</span>);<span class="keyword">else</span> emitReadable(<span class="keyword">this</span>);
    <span class="keyword">return</span> <span class="literal">null</span>;
  }

  n = howMuchToRead(n, state);

  <span class="comment">// if we've ended, and we're now clear, then finish it up.</span>
  <span class="keyword">if</span> (n === <span class="number">0</span> &amp;&amp; state.ended) {
    <span class="keyword">if</span> (state.length === <span class="number">0</span>) endReadable(<span class="keyword">this</span>);
    <span class="keyword">return</span> <span class="literal">null</span>;
  }

  <span class="comment">// All the actual chunk generation logic needs to be</span>
  <span class="comment">// *below* the call to _read.  The reason is that in certain</span>
  <span class="comment">// synthetic stream cases, such as passthrough streams, _read</span>
  <span class="comment">// may be a completely synchronous operation which may change</span>
  <span class="comment">// the state of the read buffer, providing enough data when</span>
  <span class="comment">// before there was *not* enough.</span>
  <span class="comment">//</span>
  <span class="comment">// So, the steps are:</span>
  <span class="comment">// 1. Figure out what the state of things will be after we do</span>
  <span class="comment">// a read from the buffer.</span>
  <span class="comment">//</span>
  <span class="comment">// 2. If that resulting state will trigger a _read, then call _read.</span>
  <span class="comment">// Note that this may be asynchronous, or synchronous.  Yes, it is</span>
  <span class="comment">// deeply ugly to write APIs this way, but that still doesn't mean</span>
  <span class="comment">// that the Readable class should behave improperly, as streams are</span>
  <span class="comment">// designed to be sync/async agnostic.</span>
  <span class="comment">// Take note if the _read call is sync or async (ie, if the read call</span>
  <span class="comment">// has returned yet), so that we know whether or not it's safe to emit</span>
  <span class="comment">// 'readable' etc.</span>
  <span class="comment">//</span>
  <span class="comment">// 3. Actually pull the requested chunks out of the buffer and return.</span>

  <span class="comment">// if we need a readable event, then we need to do some reading.</span>
  <span class="keyword">var</span> doRead = state.needReadable;
  debug(<span class="string">'need readable'</span>, doRead);

  <span class="comment">// if we currently have less than the highWaterMark, then also read some</span>
  <span class="keyword">if</span> (state.length === <span class="number">0</span> || state.length - n &lt; state.highWaterMark) {
    doRead = <span class="literal">true</span>;
    debug(<span class="string">'length less than watermark'</span>, doRead);
  }

  <span class="comment">// however, if we've ended, then there's no point, and if we're already</span>
  <span class="comment">// reading, then it's unnecessary.</span>
  <span class="keyword">if</span> (state.ended || state.reading) {
    doRead = <span class="literal">false</span>;
    debug(<span class="string">'reading or ended'</span>, doRead);
  } <span class="keyword">else</span> <span class="keyword">if</span> (doRead) {
    debug(<span class="string">'do read'</span>);
    state.reading = <span class="literal">true</span>;
    state.sync = <span class="literal">true</span>;
    <span class="comment">// if the length is currently zero, then we *need* a readable event.</span>
    <span class="keyword">if</span> (state.length === <span class="number">0</span>) state.needReadable = <span class="literal">true</span>;
    <span class="comment">// call internal read method</span>
    <span class="keyword">this</span>._read(state.highWaterMark);
    state.sync = <span class="literal">false</span>;
    <span class="comment">// If _read pushed data synchronously, then `reading` will be false,</span>
    <span class="comment">// and we need to re-evaluate how much data we can return to the user.</span>
    <span class="keyword">if</span> (!state.reading) n = howMuchToRead(nOrig, state);
  }

  <span class="keyword">var</span> ret;
  <span class="keyword">if</span> (n > <span class="number">0</span>) ret = fromList(n, state);<span class="keyword">else</span> ret = <span class="literal">null</span>;

  <span class="keyword">if</span> (ret === <span class="literal">null</span>) {
    state.needReadable = <span class="literal">true</span>;
    n = <span class="number">0</span>;
  } <span class="keyword">else</span> {
    state.length -= n;
  }

  <span class="keyword">if</span> (state.length === <span class="number">0</span>) {
    <span class="comment">// If we have nothing in the buffer, then we want to know</span>
    <span class="comment">// as soon as we *do* get something into the buffer.</span>
    <span class="keyword">if</span> (!state.ended) state.needReadable = <span class="literal">true</span>;

    <span class="comment">// If we tried to read() past the EOF, then emit end on the next tick.</span>
    <span class="keyword">if</span> (nOrig !== n &amp;&amp; state.ended) endReadable(<span class="keyword">this</span>);
  }

  <span class="keyword">if</span> (ret !== <span class="literal">null</span>) <span class="keyword">this</span>.emit(<span class="string">'data'</span>, ret);

  <span class="keyword">return</span> ret;
};

<span class="function"><span class="keyword">function</span> <span class="title">onEofChunk</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (state.ended) <span class="keyword">return</span>;
  <span class="keyword">if</span> (state.decoder) {
    <span class="keyword">var</span> chunk = state.decoder.end();
    <span class="keyword">if</span> (chunk &amp;&amp; chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? <span class="number">1</span> : chunk.length;
    }
  }
  state.ended = <span class="literal">true</span>;

  <span class="comment">// emit 'readable' now to make sure it gets picked up.</span>
  emitReadable(stream);
}

<span class="comment">// Don't emit readable right away in sync mode, because this can trigger</span>
<span class="comment">// another read() call => stack overflow.  This way, it might trigger</span>
<span class="comment">// a nextTick recursion warning, but that's not so bad.</span>
<span class="function"><span class="keyword">function</span> <span class="title">emitReadable</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;
  state.needReadable = <span class="literal">false</span>;
  <span class="keyword">if</span> (!state.emittedReadable) {
    debug(<span class="string">'emitReadable'</span>, state.flowing);
    state.emittedReadable = <span class="literal">true</span>;
    <span class="keyword">if</span> (state.sync) pna.nextTick(emitReadable_, stream);<span class="keyword">else</span> emitReadable_(stream);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">emitReadable_</span><span class="params">(stream)</span> {</span>
  debug(<span class="string">'emit readable'</span>);
  stream.emit(<span class="string">'readable'</span>);
  flow(stream);
}

<span class="comment">// at this point, the user has presumably seen the 'readable' event,</span>
<span class="comment">// and called read() to consume some data.  that may have triggered</span>
<span class="comment">// in turn another _read(n) call, in which case reading = true if</span>
<span class="comment">// it's in progress.</span>
<span class="comment">// However, if we're not ended, or reading, and the length &lt; hwm,</span>
<span class="comment">// then go ahead and try to read some more preemptively.</span>
<span class="function"><span class="keyword">function</span> <span class="title">maybeReadMore</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (!state.readingMore) {
    state.readingMore = <span class="literal">true</span>;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">maybeReadMore_</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">var</span> len = state.length;
  <span class="keyword">while</span> (!state.reading &amp;&amp; !state.flowing &amp;&amp; !state.ended &amp;&amp; state.length &lt; state.highWaterMark) {
    debug(<span class="string">'maybeReadMore read 0'</span>);
    stream.read(<span class="number">0</span>);
    <span class="keyword">if</span> (len === state.length)
      <span class="comment">// didn't get any data, stop spinning.</span>
      <span class="keyword">break</span>;<span class="keyword">else</span> len = state.length;
  }
  state.readingMore = <span class="literal">false</span>;
}

<span class="comment">// abstract method.  to be overridden in specific implementation classes.</span>
<span class="comment">// call cb(er, data) where data is &lt;= n in length.</span>
<span class="comment">// for virtual (non-string, non-buffer) streams, "length" is somewhat</span>
<span class="comment">// arbitrary, and perhaps not very meaningful.</span>
Readable.prototype._read = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
  <span class="keyword">this</span>.emit(<span class="string">'error'</span>, <span class="keyword">new</span> Error(<span class="string">'_read() is not implemented'</span>));
};

Readable.prototype.pipe = <span class="function"><span class="keyword">function</span> <span class="params">(dest, pipeOpts)</span> {</span>
  <span class="keyword">var</span> src = <span class="keyword">this</span>;
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;

  <span class="keyword">switch</span> (state.pipesCount) {
    <span class="keyword">case</span> <span class="number">0</span>:
      state.pipes = dest;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="number">1</span>:
      state.pipes = [state.pipes, dest];
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      state.pipes.push(dest);
      <span class="keyword">break</span>;
  }
  state.pipesCount += <span class="number">1</span>;
  debug(<span class="string">'pipe count=%d opts=%j'</span>, state.pipesCount, pipeOpts);

  <span class="keyword">var</span> doEnd = (!pipeOpts || pipeOpts.end !== <span class="literal">false</span>) &amp;&amp; dest !== process.stdout &amp;&amp; dest !== process.stderr;

  <span class="keyword">var</span> endFn = doEnd ? onend : unpipe;
  <span class="keyword">if</span> (state.endEmitted) pna.nextTick(endFn);<span class="keyword">else</span> src.once(<span class="string">'end'</span>, endFn);

  dest.on(<span class="string">'unpipe'</span>, onunpipe);
  <span class="function"><span class="keyword">function</span> <span class="title">onunpipe</span><span class="params">(readable, unpipeInfo)</span> {</span>
    debug(<span class="string">'onunpipe'</span>);
    <span class="keyword">if</span> (readable === src) {
      <span class="keyword">if</span> (unpipeInfo &amp;&amp; unpipeInfo.hasUnpiped === <span class="literal">false</span>) {
        unpipeInfo.hasUnpiped = <span class="literal">true</span>;
        cleanup();
      }
    }
  }

  <span class="function"><span class="keyword">function</span> <span class="title">onend</span><span class="params">()</span> {</span>
    debug(<span class="string">'onend'</span>);
    dest.end();
  }

  <span class="comment">// when the dest drains, it reduces the awaitDrain counter</span>
  <span class="comment">// on the source.  This would be more elegant with a .once()</span>
  <span class="comment">// handler in flow(), but adding and removing repeatedly is</span>
  <span class="comment">// too slow.</span>
  <span class="keyword">var</span> ondrain = pipeOnDrain(src);
  dest.on(<span class="string">'drain'</span>, ondrain);

  <span class="keyword">var</span> cleanedUp = <span class="literal">false</span>;
  <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span><span class="params">()</span> {</span>
    debug(<span class="string">'cleanup'</span>);
    <span class="comment">// cleanup event handlers once the pipe is broken</span>
    dest.removeListener(<span class="string">'close'</span>, onclose);
    dest.removeListener(<span class="string">'finish'</span>, onfinish);
    dest.removeListener(<span class="string">'drain'</span>, ondrain);
    dest.removeListener(<span class="string">'error'</span>, onerror);
    dest.removeListener(<span class="string">'unpipe'</span>, onunpipe);
    src.removeListener(<span class="string">'end'</span>, onend);
    src.removeListener(<span class="string">'end'</span>, unpipe);
    src.removeListener(<span class="string">'data'</span>, ondata);

    cleanedUp = <span class="literal">true</span>;

    <span class="comment">// if the reader is waiting for a drain event from this</span>
    <span class="comment">// specific writer, then it would cause it to never start</span>
    <span class="comment">// flowing again.</span>
    <span class="comment">// So, if this is awaiting a drain, then we just call it now.</span>
    <span class="comment">// If we don't know, then assume that we are waiting for one.</span>
    <span class="keyword">if</span> (state.awaitDrain &amp;&amp; (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  <span class="comment">// If the user pushes more data while we're writing to dest then we'll end up</span>
  <span class="comment">// in ondata again. However, we only want to increase awaitDrain once because</span>
  <span class="comment">// dest will only emit one 'drain' event for the multiple writes.</span>
  <span class="comment">// => Introduce a guard on increasing awaitDrain.</span>
  <span class="keyword">var</span> increasedAwaitDrain = <span class="literal">false</span>;
  src.on(<span class="string">'data'</span>, ondata);
  <span class="function"><span class="keyword">function</span> <span class="title">ondata</span><span class="params">(chunk)</span> {</span>
    debug(<span class="string">'ondata'</span>);
    increasedAwaitDrain = <span class="literal">false</span>;
    <span class="keyword">var</span> ret = dest.write(chunk);
    <span class="keyword">if</span> (<span class="literal">false</span> === ret &amp;&amp; !increasedAwaitDrain) {
      <span class="comment">// If the user unpiped during `dest.write()`, it is possible</span>
      <span class="comment">// to get stuck in a permanently paused state if that write</span>
      <span class="comment">// also returned false.</span>
      <span class="comment">// => Check whether `dest` is still a piping destination.</span>
      <span class="keyword">if</span> ((state.pipesCount === <span class="number">1</span> &amp;&amp; state.pipes === dest || state.pipesCount > <span class="number">1</span> &amp;&amp; indexOf(state.pipes, dest) !== -<span class="number">1</span>) &amp;&amp; !cleanedUp) {
        debug(<span class="string">'false write response, pause'</span>, src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = <span class="literal">true</span>;
      }
      src.pause();
    }
  }

  <span class="comment">// if the dest has an error, then stop piping into it.</span>
  <span class="comment">// however, don't suppress the throwing behavior for this.</span>
  <span class="function"><span class="keyword">function</span> <span class="title">onerror</span><span class="params">(er)</span> {</span>
    debug(<span class="string">'onerror'</span>, er);
    unpipe();
    dest.removeListener(<span class="string">'error'</span>, onerror);
    <span class="keyword">if</span> (EElistenerCount(dest, <span class="string">'error'</span>) === <span class="number">0</span>) dest.emit(<span class="string">'error'</span>, er);
  }

  <span class="comment">// Make sure our error handler is attached before userland ones.</span>
  prependListener(dest, <span class="string">'error'</span>, onerror);

  <span class="comment">// Both close and finish should trigger unpipe, but only once.</span>
  <span class="function"><span class="keyword">function</span> <span class="title">onclose</span><span class="params">()</span> {</span>
    dest.removeListener(<span class="string">'finish'</span>, onfinish);
    unpipe();
  }
  dest.once(<span class="string">'close'</span>, onclose);
  <span class="function"><span class="keyword">function</span> <span class="title">onfinish</span><span class="params">()</span> {</span>
    debug(<span class="string">'onfinish'</span>);
    dest.removeListener(<span class="string">'close'</span>, onclose);
    unpipe();
  }
  dest.once(<span class="string">'finish'</span>, onfinish);

  <span class="function"><span class="keyword">function</span> <span class="title">unpipe</span><span class="params">()</span> {</span>
    debug(<span class="string">'unpipe'</span>);
    src.unpipe(dest);
  }

  <span class="comment">// tell the dest that it's being piped to</span>
  dest.emit(<span class="string">'pipe'</span>, src);

  <span class="comment">// start the flow if it hasn't been started already.</span>
  <span class="keyword">if</span> (!state.flowing) {
    debug(<span class="string">'pipe resume'</span>);
    src.resume();
  }

  <span class="keyword">return</span> dest;
};

<span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrain</span><span class="params">(src)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">var</span> state = src._readableState;
    debug(<span class="string">'pipeOnDrain'</span>, state.awaitDrain);
    <span class="keyword">if</span> (state.awaitDrain) state.awaitDrain--;
    <span class="keyword">if</span> (state.awaitDrain === <span class="number">0</span> &amp;&amp; EElistenerCount(src, <span class="string">'data'</span>)) {
      state.flowing = <span class="literal">true</span>;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = <span class="function"><span class="keyword">function</span> <span class="params">(dest)</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> unpipeInfo = { hasUnpiped: <span class="literal">false</span> };

  <span class="comment">// if we're not piping anywhere, then do nothing.</span>
  <span class="keyword">if</span> (state.pipesCount === <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">this</span>;

  <span class="comment">// just one destination.  most common case.</span>
  <span class="keyword">if</span> (state.pipesCount === <span class="number">1</span>) {
    <span class="comment">// passed in one, but it's not the right one.</span>
    <span class="keyword">if</span> (dest &amp;&amp; dest !== state.pipes) <span class="keyword">return</span> <span class="keyword">this</span>;

    <span class="keyword">if</span> (!dest) dest = state.pipes;

    <span class="comment">// got a match.</span>
    state.pipes = <span class="literal">null</span>;
    state.pipesCount = <span class="number">0</span>;
    state.flowing = <span class="literal">false</span>;
    <span class="keyword">if</span> (dest) dest.emit(<span class="string">'unpipe'</span>, <span class="keyword">this</span>, unpipeInfo);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="comment">// slow case. multiple pipe destinations.</span>

  <span class="keyword">if</span> (!dest) {
    <span class="comment">// remove all.</span>
    <span class="keyword">var</span> dests = state.pipes;
    <span class="keyword">var</span> len = state.pipesCount;
    state.pipes = <span class="literal">null</span>;
    state.pipesCount = <span class="number">0</span>;
    state.flowing = <span class="literal">false</span>;

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
      dests[i].emit(<span class="string">'unpipe'</span>, <span class="keyword">this</span>, unpipeInfo);
    }<span class="keyword">return</span> <span class="keyword">this</span>;
  }

  <span class="comment">// try to find the right one.</span>
  <span class="keyword">var</span> index = indexOf(state.pipes, dest);
  <span class="keyword">if</span> (index === -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>;

  state.pipes.splice(index, <span class="number">1</span>);
  state.pipesCount -= <span class="number">1</span>;
  <span class="keyword">if</span> (state.pipesCount === <span class="number">1</span>) state.pipes = state.pipes[<span class="number">0</span>];

  dest.emit(<span class="string">'unpipe'</span>, <span class="keyword">this</span>, unpipeInfo);

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">// set up data events if they are asked for</span>
<span class="comment">// Ensure readable listeners eventually get something</span>
Readable.prototype.on = <span class="function"><span class="keyword">function</span> <span class="params">(ev, fn)</span> {</span>
  <span class="keyword">var</span> res = Stream.prototype.on.call(<span class="keyword">this</span>, ev, fn);

  <span class="keyword">if</span> (ev === <span class="string">'data'</span>) {
    <span class="comment">// Start flowing on next tick if stream isn't explicitly paused</span>
    <span class="keyword">if</span> (<span class="keyword">this</span>._readableState.flowing !== <span class="literal">false</span>) <span class="keyword">this</span>.resume();
  } <span class="keyword">else</span> <span class="keyword">if</span> (ev === <span class="string">'readable'</span>) {
    <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
    <span class="keyword">if</span> (!state.endEmitted &amp;&amp; !state.readableListening) {
      state.readableListening = state.needReadable = <span class="literal">true</span>;
      state.emittedReadable = <span class="literal">false</span>;
      <span class="keyword">if</span> (!state.reading) {
        pna.nextTick(nReadingNextTick, <span class="keyword">this</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (state.length) {
        emitReadable(<span class="keyword">this</span>);
      }
    }
  }

  <span class="keyword">return</span> res;
};
Readable.prototype.addListener = Readable.prototype.on;

<span class="function"><span class="keyword">function</span> <span class="title">nReadingNextTick</span><span class="params">(self)</span> {</span>
  debug(<span class="string">'readable nexttick read 0'</span>);
  self.read(<span class="number">0</span>);
}

<span class="comment">// pause() and resume() are remnants of the legacy readable stream API</span>
<span class="comment">// If the user uses them, then switch into old mode.</span>
Readable.prototype.resume = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">if</span> (!state.flowing) {
    debug(<span class="string">'resume'</span>);
    state.flowing = <span class="literal">true</span>;
    resume(<span class="keyword">this</span>, state);
  }
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="function"><span class="keyword">function</span> <span class="title">resume</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (!state.resumeScheduled) {
    state.resumeScheduled = <span class="literal">true</span>;
    pna.nextTick(resume_, stream, state);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">resume_</span><span class="params">(stream, state)</span> {</span>
  <span class="keyword">if</span> (!state.reading) {
    debug(<span class="string">'resume read 0'</span>);
    stream.read(<span class="number">0</span>);
  }

  state.resumeScheduled = <span class="literal">false</span>;
  state.awaitDrain = <span class="number">0</span>;
  stream.emit(<span class="string">'resume'</span>);
  flow(stream);
  <span class="keyword">if</span> (state.flowing &amp;&amp; !state.reading) stream.read(<span class="number">0</span>);
}

Readable.prototype.pause = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
  debug(<span class="string">'call pause flowing=%j'</span>, <span class="keyword">this</span>._readableState.flowing);
  <span class="keyword">if</span> (<span class="literal">false</span> !== <span class="keyword">this</span>._readableState.flowing) {
    debug(<span class="string">'pause'</span>);
    <span class="keyword">this</span>._readableState.flowing = <span class="literal">false</span>;
    <span class="keyword">this</span>.emit(<span class="string">'pause'</span>);
  }
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="function"><span class="keyword">function</span> <span class="title">flow</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;
  debug(<span class="string">'flow'</span>, state.flowing);
  <span class="keyword">while</span> (state.flowing &amp;&amp; stream.read() !== <span class="literal">null</span>) {}
}

<span class="comment">// wrap an old-style stream as the async data source.</span>
<span class="comment">// This is *not* part of the readable stream interface.</span>
<span class="comment">// It is an ugly unfortunate mess of history.</span>
Readable.prototype.wrap = <span class="function"><span class="keyword">function</span> <span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;

  <span class="keyword">var</span> state = <span class="keyword">this</span>._readableState;
  <span class="keyword">var</span> paused = <span class="literal">false</span>;

  stream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    debug(<span class="string">'wrapped end'</span>);
    <span class="keyword">if</span> (state.decoder &amp;&amp; !state.ended) {
      <span class="keyword">var</span> chunk = state.decoder.end();
      <span class="keyword">if</span> (chunk &amp;&amp; chunk.length) _<span class="keyword">this</span>.push(chunk);
    }

    _<span class="keyword">this</span>.push(<span class="literal">null</span>);
  });

  stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(chunk)</span> {</span>
    debug(<span class="string">'wrapped data'</span>);
    <span class="keyword">if</span> (state.decoder) chunk = state.decoder.write(chunk);

    <span class="comment">// don't skip over falsy values in objectMode</span>
    <span class="keyword">if</span> (state.objectMode &amp;&amp; (chunk === <span class="literal">null</span> || chunk === <span class="literal">undefined</span>)) <span class="keyword">return</span>;<span class="keyword">else</span> <span class="keyword">if</span> (!state.objectMode &amp;&amp; (!chunk || !chunk.length)) <span class="keyword">return</span>;

    <span class="keyword">var</span> ret = _<span class="keyword">this</span>.push(chunk);
    <span class="keyword">if</span> (!ret) {
      paused = <span class="literal">true</span>;
      stream.pause();
    }
  });

  <span class="comment">// proxy all the other methods.</span>
  <span class="comment">// important when wrapping filters and duplexes.</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> stream) {
    <span class="keyword">if</span> (<span class="keyword">this</span>[i] === <span class="literal">undefined</span> &amp;&amp; <span class="keyword">typeof</span> stream[i] === <span class="string">'function'</span>) {
      <span class="keyword">this</span>[i] = <span class="function"><span class="keyword">function</span> <span class="params">(method)</span> {</span>
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
          <span class="keyword">return</span> stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  <span class="comment">// proxy certain important events.</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], <span class="keyword">this</span>.emit.bind(<span class="keyword">this</span>, kProxyEvents[n]));
  }

  <span class="comment">// when we try to consume some more bytes, simply unpause the</span>
  <span class="comment">// underlying stream.</span>
  <span class="keyword">this</span>._read = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span> {</span>
    debug(<span class="string">'wrapped _read'</span>, n);
    <span class="keyword">if</span> (paused) {
      paused = <span class="literal">false</span>;
      stream.resume();
    }
  };

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

Object.defineProperty(Readable.prototype, <span class="string">'readableHighWaterMark'</span>, {
  <span class="comment">// making it explicit this property is not enumerable</span>
  <span class="comment">// because otherwise some prototype manipulation in</span>
  <span class="comment">// userland will fail</span>
  enumerable: <span class="literal">false</span>,
  get: <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._readableState.highWaterMark;
  }
});

<span class="comment">// exposed for testing purposes only.</span>
Readable._fromList = fromList;

<span class="comment">// Pluck off n bytes from an array of buffers.</span>
<span class="comment">// Length is the combined lengths of all the buffers in the list.</span>
<span class="comment">// This function is designed to be inlinable, so please take care when making</span>
<span class="comment">// changes to the function body.</span>
<span class="function"><span class="keyword">function</span> <span class="title">fromList</span><span class="params">(n, state)</span> {</span>
  <span class="comment">// nothing buffered</span>
  <span class="keyword">if</span> (state.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;

  <span class="keyword">var</span> ret;
  <span class="keyword">if</span> (state.objectMode) ret = state.buffer.shift();<span class="keyword">else</span> <span class="keyword">if</span> (!n || n >= state.length) {
    <span class="comment">// read it all, truncate the list</span>
    <span class="keyword">if</span> (state.decoder) ret = state.buffer.join(<span class="string">''</span>);<span class="keyword">else</span> <span class="keyword">if</span> (state.buffer.length === <span class="number">1</span>) ret = state.buffer.head.data;<span class="keyword">else</span> ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } <span class="keyword">else</span> {
    <span class="comment">// read part of list</span>
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  <span class="keyword">return</span> ret;
}

<span class="comment">// Extracts only enough buffered data to satisfy the amount requested.</span>
<span class="comment">// This function is designed to be inlinable, so please take care when making</span>
<span class="comment">// changes to the function body.</span>
<span class="function"><span class="keyword">function</span> <span class="title">fromListPartial</span><span class="params">(n, list, hasStrings)</span> {</span>
  <span class="keyword">var</span> ret;
  <span class="keyword">if</span> (n &lt; list.head.data.length) {
    <span class="comment">// slice is the same for buffers and strings</span>
    ret = list.head.data.slice(<span class="number">0</span>, n);
    list.head.data = list.head.data.slice(n);
  } <span class="keyword">else</span> <span class="keyword">if</span> (n === list.head.data.length) {
    <span class="comment">// first chunk is a perfect match</span>
    ret = list.shift();
  } <span class="keyword">else</span> {
    <span class="comment">// result spans more than one buffer</span>
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  <span class="keyword">return</span> ret;
}

<span class="comment">// Copies a specified amount of characters from the list of buffered data</span>
<span class="comment">// chunks.</span>
<span class="comment">// This function is designed to be inlinable, so please take care when making</span>
<span class="comment">// changes to the function body.</span>
<span class="function"><span class="keyword">function</span> <span class="title">copyFromBufferString</span><span class="params">(n, list)</span> {</span>
  <span class="keyword">var</span> p = list.head;
  <span class="keyword">var</span> c = <span class="number">1</span>;
  <span class="keyword">var</span> ret = p.data;
  n -= ret.length;
  <span class="keyword">while</span> (p = p.next) {
    <span class="keyword">var</span> str = p.data;
    <span class="keyword">var</span> nb = n > str.length ? str.length : n;
    <span class="keyword">if</span> (nb === str.length) ret += str;<span class="keyword">else</span> ret += str.slice(<span class="number">0</span>, n);
    n -= nb;
    <span class="keyword">if</span> (n === <span class="number">0</span>) {
      <span class="keyword">if</span> (nb === str.length) {
        ++c;
        <span class="keyword">if</span> (p.next) list.head = p.next;<span class="keyword">else</span> list.head = list.tail = <span class="literal">null</span>;
      } <span class="keyword">else</span> {
        list.head = p;
        p.data = str.slice(nb);
      }
      <span class="keyword">break</span>;
    }
    ++c;
  }
  list.length -= c;
  <span class="keyword">return</span> ret;
}

<span class="comment">// Copies a specified amount of bytes from the list of buffered data chunks.</span>
<span class="comment">// This function is designed to be inlinable, so please take care when making</span>
<span class="comment">// changes to the function body.</span>
<span class="function"><span class="keyword">function</span> <span class="title">copyFromBuffer</span><span class="params">(n, list)</span> {</span>
  <span class="keyword">var</span> ret = Buffer.allocUnsafe(n);
  <span class="keyword">var</span> p = list.head;
  <span class="keyword">var</span> c = <span class="number">1</span>;
  p.data.copy(ret);
  n -= p.data.length;
  <span class="keyword">while</span> (p = p.next) {
    <span class="keyword">var</span> buf = p.data;
    <span class="keyword">var</span> nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, <span class="number">0</span>, nb);
    n -= nb;
    <span class="keyword">if</span> (n === <span class="number">0</span>) {
      <span class="keyword">if</span> (nb === buf.length) {
        ++c;
        <span class="keyword">if</span> (p.next) list.head = p.next;<span class="keyword">else</span> list.head = list.tail = <span class="literal">null</span>;
      } <span class="keyword">else</span> {
        list.head = p;
        p.data = buf.slice(nb);
      }
      <span class="keyword">break</span>;
    }
    ++c;
  }
  list.length -= c;
  <span class="keyword">return</span> ret;
}

<span class="function"><span class="keyword">function</span> <span class="title">endReadable</span><span class="params">(stream)</span> {</span>
  <span class="keyword">var</span> state = stream._readableState;

  <span class="comment">// If we get here before consuming all the bytes, then that is a</span>
  <span class="comment">// bug in node.  Should never happen.</span>
  <span class="keyword">if</span> (state.length > <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'"endReadable()" called on non-empty stream'</span>);

  <span class="keyword">if</span> (!state.endEmitted) {
    state.ended = <span class="literal">true</span>;
    pna.nextTick(endReadableNT, state, stream);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">endReadableNT</span><span class="params">(state, stream)</span> {</span>
  <span class="comment">// Check that we didn't get one last unshift.</span>
  <span class="keyword">if</span> (!state.endEmitted &amp;&amp; state.length === <span class="number">0</span>) {
    state.endEmitted = <span class="literal">true</span>;
    stream.readable = <span class="literal">false</span>;
    stream.emit(<span class="string">'end'</span>);
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">indexOf</span><span class="params">(xs, x)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = xs.length; i &lt; l; i++) {
    <span class="keyword">if</span> (xs[i] === x) <span class="keyword">return</span> i;
  }
  <span class="keyword">return</span> -<span class="number">1</span>;
}</code></pre>