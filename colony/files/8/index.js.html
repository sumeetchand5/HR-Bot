<h1>index.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> concatMap = require(<span class="string">'concat-map'</span>);
<span class="keyword">var</span> balanced = require(<span class="string">'balanced-match'</span>);

module.exports = expandTop;

<span class="keyword">var</span> escSlash = <span class="string">'\0SLASH'</span>+Math.random()+<span class="string">'\0'</span>;
<span class="keyword">var</span> escOpen = <span class="string">'\0OPEN'</span>+Math.random()+<span class="string">'\0'</span>;
<span class="keyword">var</span> escClose = <span class="string">'\0CLOSE'</span>+Math.random()+<span class="string">'\0'</span>;
<span class="keyword">var</span> escComma = <span class="string">'\0COMMA'</span>+Math.random()+<span class="string">'\0'</span>;
<span class="keyword">var</span> escPeriod = <span class="string">'\0PERIOD'</span>+Math.random()+<span class="string">'\0'</span>;

<span class="function"><span class="keyword">function</span> <span class="title">numeric</span><span class="params">(str)</span> {</span>
  <span class="keyword">return</span> parseInt(str, <span class="number">10</span>) == str
    ? parseInt(str, <span class="number">10</span>)
    : str.charCodeAt(<span class="number">0</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">escapeBraces</span><span class="params">(str)</span> {</span>
  <span class="keyword">return</span> str.split(<span class="string">'\\\\'</span>).join(escSlash)
            .split(<span class="string">'\\{'</span>).join(escOpen)
            .split(<span class="string">'\\}'</span>).join(escClose)
            .split(<span class="string">'\\,'</span>).join(escComma)
            .split(<span class="string">'\\.'</span>).join(escPeriod);
}

<span class="function"><span class="keyword">function</span> <span class="title">unescapeBraces</span><span class="params">(str)</span> {</span>
  <span class="keyword">return</span> str.split(escSlash).join(<span class="string">'\\'</span>)
            .split(escOpen).join(<span class="string">'{'</span>)
            .split(escClose).join(<span class="string">'}'</span>)
            .split(escComma).join(<span class="string">','</span>)
            .split(escPeriod).join(<span class="string">'.'</span>);
}


<span class="comment">// Basically just str.split(","), but handling cases</span>
<span class="comment">// where we have nested braced sections, which should be</span>
<span class="comment">// treated as individual members, like {a,{b,c},d}</span>
<span class="function"><span class="keyword">function</span> <span class="title">parseCommaParts</span><span class="params">(str)</span> {</span>
  <span class="keyword">if</span> (!str)
    <span class="keyword">return</span> [<span class="string">''</span>];

  <span class="keyword">var</span> parts = [];
  <span class="keyword">var</span> m = balanced(<span class="string">'{'</span>, <span class="string">'}'</span>, str);

  <span class="keyword">if</span> (!m)
    <span class="keyword">return</span> str.split(<span class="string">','</span>);

  <span class="keyword">var</span> pre = m.pre;
  <span class="keyword">var</span> body = m.body;
  <span class="keyword">var</span> post = m.post;
  <span class="keyword">var</span> p = pre.split(<span class="string">','</span>);

  p[p.length-<span class="number">1</span>] += <span class="string">'{'</span> + body + <span class="string">'}'</span>;
  <span class="keyword">var</span> postParts = parseCommaParts(post);
  <span class="keyword">if</span> (post.length) {
    p[p.length-<span class="number">1</span>] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  <span class="keyword">return</span> parts;
}

<span class="function"><span class="keyword">function</span> <span class="title">expandTop</span><span class="params">(str)</span> {</span>
  <span class="keyword">if</span> (!str)
    <span class="keyword">return</span> [];

  <span class="comment">// I don't know why Bash 4.3 does this, but it does.</span>
  <span class="comment">// Anything starting with {} will have the first two bytes preserved</span>
  <span class="comment">// but *only* at the top level, so {},a}b will not expand to anything,</span>
  <span class="comment">// but a{},b}c will be expanded to [a}c,abc].</span>
  <span class="comment">// One could argue that this is a bug in Bash, but since the goal of</span>
  <span class="comment">// this module is to match Bash's rules, we escape a leading {}</span>
  <span class="keyword">if</span> (str.substr(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">'{}'</span>) {
    str = <span class="string">'\\{\\}'</span> + str.substr(<span class="number">2</span>);
  }

  <span class="keyword">return</span> expand(escapeBraces(str), <span class="literal">true</span>).map(unescapeBraces);
}

<span class="function"><span class="keyword">function</span> <span class="title">identity</span><span class="params">(e)</span> {</span>
  <span class="keyword">return</span> e;
}

<span class="function"><span class="keyword">function</span> <span class="title">embrace</span><span class="params">(str)</span> {</span>
  <span class="keyword">return</span> <span class="string">'{'</span> + str + <span class="string">'}'</span>;
}
<span class="function"><span class="keyword">function</span> <span class="title">isPadded</span><span class="params">(el)</span> {</span>
  <span class="keyword">return</span> <span class="regexp">/^-?0\d/</span>.test(el);
}

<span class="function"><span class="keyword">function</span> <span class="title">lte</span><span class="params">(i, y)</span> {</span>
  <span class="keyword">return</span> i &lt;= y;
}
<span class="function"><span class="keyword">function</span> <span class="title">gte</span><span class="params">(i, y)</span> {</span>
  <span class="keyword">return</span> i >= y;
}

<span class="function"><span class="keyword">function</span> <span class="title">expand</span><span class="params">(str, isTop)</span> {</span>
  <span class="keyword">var</span> expansions = [];

  <span class="keyword">var</span> m = balanced(<span class="string">'{'</span>, <span class="string">'}'</span>, str);
  <span class="keyword">if</span> (!m || <span class="regexp">/\$$/</span>.test(m.pre)) <span class="keyword">return</span> [str];

  <span class="keyword">var</span> isNumericSequence = <span class="regexp">/^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/</span>.test(m.body);
  <span class="keyword">var</span> isAlphaSequence = <span class="regexp">/^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/</span>.test(m.body);
  <span class="keyword">var</span> isSequence = isNumericSequence || isAlphaSequence;
  <span class="keyword">var</span> isOptions = m.body.indexOf(<span class="string">','</span>) >= <span class="number">0</span>;
  <span class="keyword">if</span> (!isSequence &amp;&amp; !isOptions) {
    <span class="comment">// {a},b}</span>
    <span class="keyword">if</span> (m.post.match(<span class="regexp">/,.*\}/</span>)) {
      str = m.pre + <span class="string">'{'</span> + m.body + escClose + m.post;
      <span class="keyword">return</span> expand(str);
    }
    <span class="keyword">return</span> [str];
  }

  <span class="keyword">var</span> n;
  <span class="keyword">if</span> (isSequence) {
    n = m.body.split(<span class="regexp">/\.\./</span>);
  } <span class="keyword">else</span> {
    n = parseCommaParts(m.body);
    <span class="keyword">if</span> (n.length === <span class="number">1</span>) {
      <span class="comment">// x{{a,b}}y ==> x{a}y x{b}y</span>
      n = expand(n[<span class="number">0</span>], <span class="literal">false</span>).map(embrace);
      <span class="keyword">if</span> (n.length === <span class="number">1</span>) {
        <span class="keyword">var</span> post = m.post.length
          ? expand(m.post, <span class="literal">false</span>)
          : [<span class="string">''</span>];
        <span class="keyword">return</span> post.map(<span class="keyword">function</span>(p) {
          <span class="keyword">return</span> m.pre + n[<span class="number">0</span>] + p;
        });
      }
    }
  }

  <span class="comment">// at this point, n is the parts, and we know it's not a comma set</span>
  <span class="comment">// with a single entry.</span>

  <span class="comment">// no need to expand pre, since it is guaranteed to be free of brace-sets</span>
  <span class="keyword">var</span> pre = m.pre;
  <span class="keyword">var</span> post = m.post.length
    ? expand(m.post, <span class="literal">false</span>)
    : [<span class="string">''</span>];

  <span class="keyword">var</span> N;

  <span class="keyword">if</span> (isSequence) {
    <span class="keyword">var</span> x = numeric(n[<span class="number">0</span>]);
    <span class="keyword">var</span> y = numeric(n[<span class="number">1</span>]);
    <span class="keyword">var</span> width = Math.max(n[<span class="number">0</span>].length, n[<span class="number">1</span>].length)
    <span class="keyword">var</span> incr = n.length == <span class="number">3</span>
      ? Math.abs(numeric(n[<span class="number">2</span>]))
      : <span class="number">1</span>;
    <span class="keyword">var</span> test = lte;
    <span class="keyword">var</span> reverse = y &lt; x;
    <span class="keyword">if</span> (reverse) {
      incr *= -<span class="number">1</span>;
      test = gte;
    }
    <span class="keyword">var</span> pad = n.some(isPadded);

    N = [];

    <span class="keyword">for</span> (<span class="keyword">var</span> i = x; test(i, y); i += incr) {
      <span class="keyword">var</span> c;
      <span class="keyword">if</span> (isAlphaSequence) {
        c = String.fromCharCode(i);
        <span class="keyword">if</span> (c === <span class="string">'\\'</span>)
          c = <span class="string">''</span>;
      } <span class="keyword">else</span> {
        c = String(i);
        <span class="keyword">if</span> (pad) {
          <span class="keyword">var</span> need = width - c.length;
          <span class="keyword">if</span> (need > <span class="number">0</span>) {
            <span class="keyword">var</span> z = <span class="keyword">new</span> Array(need + <span class="number">1</span>).join(<span class="string">'0'</span>);
            <span class="keyword">if</span> (i &lt; <span class="number">0</span>)
              c = <span class="string">'-'</span> + z + c.slice(<span class="number">1</span>);
            <span class="keyword">else</span>
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } <span class="keyword">else</span> {
    N = concatMap(n, <span class="keyword">function</span>(el) { <span class="keyword">return</span> expand(el, <span class="literal">false</span>) });
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; N.length; j++) {
    <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; post.length; k++) {
      <span class="keyword">var</span> expansion = pre + N[j] + post[k];
      <span class="keyword">if</span> (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  <span class="keyword">return</span> expansions;
}

</code></pre>