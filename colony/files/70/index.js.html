<h1>index.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * lodash 3.0.4 (Custom Build) &lt;https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation &lt;http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 &lt;http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors
 * Available under MIT license &lt;https://lodash.com/license>
 */</span>

<span class="comment">/** Used as the `TypeError` message for "Functions" methods. */</span>
<span class="keyword">var</span> FUNC_ERROR_TEXT = <span class="string">'Expected a function'</span>;

<span class="comment">/** Used for native method references. */</span>
<span class="keyword">var</span> objectProto = Object.prototype;

<span class="comment">/** Used to check objects for own properties. */</span>
<span class="keyword">var</span> hasOwnProperty = objectProto.hasOwnProperty;

<span class="comment">/**
 * Creates a cache object to store key/value pairs.
 *
 * @private
 * @static
 * @name Cache
 * @memberOf _.memoize
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">MapCache</span><span class="params">()</span> {</span>
  <span class="keyword">this</span>.__data__ = {};
}

<span class="comment">/**
 * Removes `key` and its value from the cache.
 *
 * @private
 * @name delete
 * @memberOf _.memoize.Cache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">mapDelete</span><span class="params">(key)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.has(key) &amp;&amp; <span class="keyword">delete</span> <span class="keyword">this</span>.__data__[key];
}

<span class="comment">/**
 * Gets the cached value for `key`.
 *
 * @private
 * @name get
 * @memberOf _.memoize.Cache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the cached value.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">mapGet</span><span class="params">(key)</span> {</span>
  <span class="keyword">return</span> key == <span class="string">'__proto__'</span> ? <span class="literal">undefined</span> : <span class="keyword">this</span>.__data__[key];
}

<span class="comment">/**
 * Checks if a cached value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf _.memoize.Cache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">mapHas</span><span class="params">(key)</span> {</span>
  <span class="keyword">return</span> key != <span class="string">'__proto__'</span> &amp;&amp; hasOwnProperty.call(<span class="keyword">this</span>.__data__, key);
}

<span class="comment">/**
 * Sets `value` to `key` of the cache.
 *
 * @private
 * @name set
 * @memberOf _.memoize.Cache
 * @param {string} key The key of the value to cache.
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache object.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">mapSet</span><span class="params">(key, value)</span> {</span>
  <span class="keyword">if</span> (key != <span class="string">'__proto__'</span>) {
    <span class="keyword">this</span>.__data__[key] = value;
  }
  <span class="keyword">return</span> <span class="keyword">this</span>;
}

<span class="comment">/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is coerced to a string and used as the
 * cache key. The `func` is invoked with the `this` binding of the memoized
 * function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the [`Map`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
 * method interface of `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoizing function.
 * @example
 *
 * var upperCase = _.memoize(function(string) {
 *   return string.toUpperCase();
 * });
 *
 * upperCase('fred');
 * // => 'FRED'
 *
 * // modifying the result cache
 * upperCase.cache.set('fred', 'BARNEY');
 * upperCase('fred');
 * // => 'BARNEY'
 *
 * // replacing `_.memoize.Cache`
 * var object = { 'user': 'fred' };
 * var other = { 'user': 'barney' };
 * var identity = _.memoize(_.identity);
 *
 * identity(object);
 * // => { 'user': 'fred' }
 * identity(other);
 * // => { 'user': 'fred' }
 *
 * _.memoize.Cache = WeakMap;
 * var identity = _.memoize(_.identity);
 *
 * identity(object);
 * // => { 'user': 'fred' }
 * identity(other);
 * // => { 'user': 'barney' }
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">memoize</span><span class="params">(func, resolver)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> func != <span class="string">'function'</span> || (resolver &amp;&amp; <span class="keyword">typeof</span> resolver != <span class="string">'function'</span>)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(FUNC_ERROR_TEXT);
  }
  <span class="keyword">var</span> memoized = <span class="keyword">function</span>() {
    <span class="keyword">var</span> args = arguments,
        key = resolver ? resolver.apply(<span class="keyword">this</span>, args) : args[<span class="number">0</span>],
        cache = memoized.cache;

    <span class="keyword">if</span> (cache.has(key)) {
      <span class="keyword">return</span> cache.get(key);
    }
    <span class="keyword">var</span> result = func.apply(<span class="keyword">this</span>, args);
    memoized.cache = cache.set(key, result);
    <span class="keyword">return</span> result;
  };
  memoized.cache = <span class="keyword">new</span> memoize.Cache;
  <span class="keyword">return</span> memoized;
}

<span class="comment">// Add functions to the `Map` cache.</span>
MapCache.prototype[<span class="string">'delete'</span>] = mapDelete;
MapCache.prototype.get = mapGet;
MapCache.prototype.has = mapHas;
MapCache.prototype.set = mapSet;

<span class="comment">// Assign cache to `_.memoize`.</span>
memoize.Cache = MapCache;

module.exports = memoize;
</code></pre>