<h1>main.js</h1>
<pre><code class="lang-js"><span class="keyword">var</span> nextTick = require(<span class="string">'process/browser.js'</span>).nextTick;
<span class="keyword">var</span> apply = Function.prototype.apply;
<span class="keyword">var</span> slice = Array.prototype.slice;
<span class="keyword">var</span> immediateIds = {};
<span class="keyword">var</span> nextImmediateId = <span class="number">0</span>;

<span class="comment">// DOM APIs, for completeness</span>

exports.setTimeout = <span class="keyword">function</span>() {
  <span class="keyword">return</span> <span class="keyword">new</span> Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = <span class="keyword">function</span>() {
  <span class="keyword">return</span> <span class="keyword">new</span> Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = <span class="keyword">function</span>(timeout) { timeout.close(); };

<span class="function"><span class="keyword">function</span> <span class="title">Timeout</span><span class="params">(id, clearFn)</span> {</span>
  <span class="keyword">this</span>._id = id;
  <span class="keyword">this</span>._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = <span class="keyword">function</span>() {};
Timeout.prototype.close = <span class="keyword">function</span>() {
  <span class="keyword">this</span>._clearFn.call(window, <span class="keyword">this</span>._id);
};

<span class="comment">// Does not start the time, just sets up the members needed.</span>
exports.enroll = <span class="keyword">function</span>(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = <span class="keyword">function</span>(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -<span class="number">1</span>;
};

exports._unrefActive = exports.active = <span class="keyword">function</span>(item) {
  clearTimeout(item._idleTimeoutId);

  <span class="keyword">var</span> msecs = item._idleTimeout;
  <span class="keyword">if</span> (msecs >= <span class="number">0</span>) {
    item._idleTimeoutId = setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">onTimeout</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

<span class="comment">// That's not how node.js implements it but the exposed api is the same.</span>
exports.setImmediate = <span class="keyword">typeof</span> setImmediate === <span class="string">"function"</span> ? setImmediate : <span class="keyword">function</span>(fn) {
  <span class="keyword">var</span> id = nextImmediateId++;
  <span class="keyword">var</span> args = arguments.length &lt; <span class="number">2</span> ? <span class="literal">false</span> : slice.call(arguments, <span class="number">1</span>);

  immediateIds[id] = <span class="literal">true</span>;

  nextTick(<span class="function"><span class="keyword">function</span> <span class="title">onNextTick</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (immediateIds[id]) {
      <span class="comment">// fn.call() is faster so we optimize for the common use-case</span>
      <span class="comment">// @see http://jsperf.com/call-apply-segu</span>
      <span class="keyword">if</span> (args) {
        fn.apply(<span class="literal">null</span>, args);
      } <span class="keyword">else</span> {
        fn.call(<span class="literal">null</span>);
      }
      <span class="comment">// Prevent ids from leaking</span>
      exports.clearImmediate(id);
    }
  });

  <span class="keyword">return</span> id;
};

exports.clearImmediate = <span class="keyword">typeof</span> clearImmediate === <span class="string">"function"</span> ? clearImmediate : <span class="keyword">function</span>(id) {
  <span class="keyword">delete</span> immediateIds[id];
};</code></pre>