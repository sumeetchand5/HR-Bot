<h1>minimatch.js</h1>
<pre><code class="lang-js">module.exports = minimatch
minimatch.Minimatch = Minimatch

<span class="keyword">var</span> path = { sep: <span class="string">'/'</span> }
<span class="keyword">try</span> {
  path = require(<span class="string">'path'</span>)
} <span class="keyword">catch</span> (er) {}

<span class="keyword">var</span> GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
<span class="keyword">var</span> expand = require(<span class="string">'brace-expansion'</span>)

<span class="keyword">var</span> plTypes = {
  <span class="string">'!'</span>: { open: <span class="string">'(?:(?!(?:'</span>, close: <span class="string">'))[^/]*?)'</span>},
  <span class="string">'?'</span>: { open: <span class="string">'(?:'</span>, close: <span class="string">')?'</span> },
  <span class="string">'+'</span>: { open: <span class="string">'(?:'</span>, close: <span class="string">')+'</span> },
  <span class="string">'*'</span>: { open: <span class="string">'(?:'</span>, close: <span class="string">')*'</span> },
  <span class="string">'@'</span>: { open: <span class="string">'(?:'</span>, close: <span class="string">')'</span> }
}

<span class="comment">// any single thing other than /</span>
<span class="comment">// don't need to escape / when using new RegExp()</span>
<span class="keyword">var</span> qmark = <span class="string">'[^/]'</span>

<span class="comment">// * => any number of characters</span>
<span class="keyword">var</span> star = qmark + <span class="string">'*?'</span>

<span class="comment">// ** when dots are allowed.  Anything goes, except .. and .</span>
<span class="comment">// not (^ or / followed by one or two dots followed by $ or /),</span>
<span class="comment">// followed by anything, any number of times.</span>
<span class="keyword">var</span> twoStarDot = <span class="string">'(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'</span>

<span class="comment">// not a ^ or / followed by a dot,</span>
<span class="comment">// followed by anything, any number of times.</span>
<span class="keyword">var</span> twoStarNoDot = <span class="string">'(?:(?!(?:\\\/|^)\\.).)*?'</span>

<span class="comment">// characters that need to be escaped in RegExp.</span>
<span class="keyword">var</span> reSpecials = charSet(<span class="string">'().*{}+?[]^$\\!'</span>)

<span class="comment">// "abc" -> { a:true, b:true, c:true }</span>
<span class="function"><span class="keyword">function</span> <span class="title">charSet</span> <span class="params">(s)</span> {</span>
  <span class="keyword">return</span> s.split(<span class="string">''</span>).reduce(<span class="function"><span class="keyword">function</span> <span class="params">(set, c)</span> {</span>
    set[c] = <span class="literal">true</span>
    <span class="keyword">return</span> set
  }, {})
}

<span class="comment">// normalizes slashes.</span>
<span class="keyword">var</span> slashSplit = <span class="regexp">/\/+/</span>

minimatch.filter = filter
<span class="function"><span class="keyword">function</span> <span class="title">filter</span> <span class="params">(pattern, options)</span> {</span>
  options = options || {}
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(p, i, list)</span> {</span>
    <span class="keyword">return</span> minimatch(p, pattern, options)
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">ext</span> <span class="params">(a, b)</span> {</span>
  a = a || {}
  b = b || {}
  <span class="keyword">var</span> t = {}
  Object.keys(b).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(k)</span> {</span>
    t[k] = b[k]
  })
  Object.keys(a).forEach(<span class="function"><span class="keyword">function</span> <span class="params">(k)</span> {</span>
    t[k] = a[k]
  })
  <span class="keyword">return</span> t
}

minimatch.defaults = <span class="function"><span class="keyword">function</span> <span class="params">(def)</span> {</span>
  <span class="keyword">if</span> (!def || !Object.keys(def).length) <span class="keyword">return</span> minimatch

  <span class="keyword">var</span> orig = minimatch

  <span class="keyword">var</span> m = <span class="function"><span class="keyword">function</span> <span class="title">minimatch</span> <span class="params">(p, pattern, options)</span> {</span>
    <span class="keyword">return</span> orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = <span class="function"><span class="keyword">function</span> <span class="title">Minimatch</span> <span class="params">(pattern, options)</span> {</span>
    <span class="keyword">return</span> <span class="keyword">new</span> orig.Minimatch(pattern, ext(def, options))
  }

  <span class="keyword">return</span> m
}

Minimatch.defaults = <span class="function"><span class="keyword">function</span> <span class="params">(def)</span> {</span>
  <span class="keyword">if</span> (!def || !Object.keys(def).length) <span class="keyword">return</span> Minimatch
  <span class="keyword">return</span> minimatch.defaults(def).Minimatch
}

<span class="function"><span class="keyword">function</span> <span class="title">minimatch</span> <span class="params">(p, pattern, options)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern !== <span class="string">'string'</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'glob pattern string required'</span>)
  }

  <span class="keyword">if</span> (!options) options = {}

  <span class="comment">// shortcut: comments match nothing.</span>
  <span class="keyword">if</span> (!options.nocomment &amp;&amp; pattern.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) {
    <span class="keyword">return</span> <span class="literal">false</span>
  }

  <span class="comment">// "" only matches ""</span>
  <span class="keyword">if</span> (pattern.trim() === <span class="string">''</span>) <span class="keyword">return</span> p === <span class="string">''</span>

  <span class="keyword">return</span> <span class="keyword">new</span> Minimatch(pattern, options).match(p)
}

<span class="function"><span class="keyword">function</span> <span class="title">Minimatch</span> <span class="params">(pattern, options)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Minimatch)) {
    <span class="keyword">return</span> <span class="keyword">new</span> Minimatch(pattern, options)
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern !== <span class="string">'string'</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'glob pattern string required'</span>)
  }

  <span class="keyword">if</span> (!options) options = {}
  pattern = pattern.trim()

  <span class="comment">// windows support: need to use /, not \</span>
  <span class="keyword">if</span> (path.sep !== <span class="string">'/'</span>) {
    pattern = pattern.split(path.sep).join(<span class="string">'/'</span>)
  }

  <span class="keyword">this</span>.options = options
  <span class="keyword">this</span>.set = []
  <span class="keyword">this</span>.pattern = pattern
  <span class="keyword">this</span>.regexp = <span class="literal">null</span>
  <span class="keyword">this</span>.negate = <span class="literal">false</span>
  <span class="keyword">this</span>.comment = <span class="literal">false</span>
  <span class="keyword">this</span>.empty = <span class="literal">false</span>

  <span class="comment">// make the set of regexps etc.</span>
  <span class="keyword">this</span>.make()
}

Minimatch.prototype.debug = <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>}

Minimatch.prototype.make = make
<span class="function"><span class="keyword">function</span> <span class="title">make</span> <span class="params">()</span> {</span>
  <span class="comment">// don't do it more than once.</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._made) <span class="keyword">return</span>

  <span class="keyword">var</span> pattern = <span class="keyword">this</span>.pattern
  <span class="keyword">var</span> options = <span class="keyword">this</span>.options

  <span class="comment">// empty patterns and comments match nothing.</span>
  <span class="keyword">if</span> (!options.nocomment &amp;&amp; pattern.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) {
    <span class="keyword">this</span>.comment = <span class="literal">true</span>
    <span class="keyword">return</span>
  }
  <span class="keyword">if</span> (!pattern) {
    <span class="keyword">this</span>.empty = <span class="literal">true</span>
    <span class="keyword">return</span>
  }

  <span class="comment">// step 1: figure out negation, etc.</span>
  <span class="keyword">this</span>.parseNegate()

  <span class="comment">// step 2: expand braces</span>
  <span class="keyword">var</span> set = <span class="keyword">this</span>.globSet = <span class="keyword">this</span>.braceExpand()

  <span class="keyword">if</span> (options.debug) <span class="keyword">this</span>.debug = console.error

  <span class="keyword">this</span>.debug(<span class="keyword">this</span>.pattern, set)

  <span class="comment">// step 3: now we have a set, so turn each one into a series of path-portion</span>
  <span class="comment">// matching patterns.</span>
  <span class="comment">// These will be regexps, except in the case of "**", which is</span>
  <span class="comment">// set to the GLOBSTAR object for globstar behavior,</span>
  <span class="comment">// and will not contain any / characters</span>
  set = <span class="keyword">this</span>.globParts = set.map(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
    <span class="keyword">return</span> s.split(slashSplit)
  })

  <span class="keyword">this</span>.debug(<span class="keyword">this</span>.pattern, set)

  <span class="comment">// glob --> regexps</span>
  set = set.map(<span class="function"><span class="keyword">function</span> <span class="params">(s, si, set)</span> {</span>
    <span class="keyword">return</span> s.map(<span class="keyword">this</span>.parse, <span class="keyword">this</span>)
  }, <span class="keyword">this</span>)

  <span class="keyword">this</span>.debug(<span class="keyword">this</span>.pattern, set)

  <span class="comment">// filter out everything that didn't compile properly.</span>
  set = set.filter(<span class="function"><span class="keyword">function</span> <span class="params">(s)</span> {</span>
    <span class="keyword">return</span> s.indexOf(<span class="literal">false</span>) === -<span class="number">1</span>
  })

  <span class="keyword">this</span>.debug(<span class="keyword">this</span>.pattern, set)

  <span class="keyword">this</span>.set = set
}

Minimatch.prototype.parseNegate = parseNegate
<span class="function"><span class="keyword">function</span> <span class="title">parseNegate</span> <span class="params">()</span> {</span>
  <span class="keyword">var</span> pattern = <span class="keyword">this</span>.pattern
  <span class="keyword">var</span> negate = <span class="literal">false</span>
  <span class="keyword">var</span> options = <span class="keyword">this</span>.options
  <span class="keyword">var</span> negateOffset = <span class="number">0</span>

  <span class="keyword">if</span> (options.nonegate) <span class="keyword">return</span>

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = pattern.length
    ; i &lt; l &amp;&amp; pattern.charAt(i) === <span class="string">'!'</span>
    ; i++) {
    negate = !negate
    negateOffset++
  }

  <span class="keyword">if</span> (negateOffset) <span class="keyword">this</span>.pattern = pattern.substr(negateOffset)
  <span class="keyword">this</span>.negate = negate
}

<span class="comment">// Brace expansion:</span>
<span class="comment">// a{b,c}d -> abd acd</span>
<span class="comment">// a{b,}c -> abc ac</span>
<span class="comment">// a{0..3}d -> a0d a1d a2d a3d</span>
<span class="comment">// a{b,c{d,e}f}g -> abg acdfg acefg</span>
<span class="comment">// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg</span>
<span class="comment">//</span>
<span class="comment">// Invalid sets are not expanded.</span>
<span class="comment">// a{2..}b -> a{2..}b</span>
<span class="comment">// a{b}c -> a{b}c</span>
minimatch.braceExpand = <span class="function"><span class="keyword">function</span> <span class="params">(pattern, options)</span> {</span>
  <span class="keyword">return</span> braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

<span class="function"><span class="keyword">function</span> <span class="title">braceExpand</span> <span class="params">(pattern, options)</span> {</span>
  <span class="keyword">if</span> (!options) {
    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Minimatch) {
      options = <span class="keyword">this</span>.options
    } <span class="keyword">else</span> {
      options = {}
    }
  }

  pattern = <span class="keyword">typeof</span> pattern === <span class="string">'undefined'</span>
    ? <span class="keyword">this</span>.pattern : pattern

  <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">'undefined'</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'undefined pattern'</span>)
  }

  <span class="keyword">if</span> (options.nobrace ||
    !pattern.match(<span class="regexp">/\{.*\}/</span>)) {
    <span class="comment">// shortcut. no need to expand.</span>
    <span class="keyword">return</span> [pattern]
  }

  <span class="keyword">return</span> expand(pattern)
}

<span class="comment">// parse a component of the expanded set.</span>
<span class="comment">// At this point, no pattern may contain "/" in it</span>
<span class="comment">// so we're going to return a 2d array, where each entry is the full</span>
<span class="comment">// pattern, split on '/', and then turned into a regular expression.</span>
<span class="comment">// A regexp is made at the end which joins each array with an</span>
<span class="comment">// escaped /, and another full one which joins each regexp with |.</span>
<span class="comment">//</span>
<span class="comment">// Following the lead of Bash 4.1, note that "**" only has special meaning</span>
<span class="comment">// when it is the *only* thing in a path portion.  Otherwise, any series</span>
<span class="comment">// of * is equivalent to a single *.  Globstar behavior is enabled by</span>
<span class="comment">// default, and can be disabled by setting options.noglobstar.</span>
Minimatch.prototype.parse = parse
<span class="keyword">var</span> SUBPARSE = {}
<span class="function"><span class="keyword">function</span> <span class="title">parse</span> <span class="params">(pattern, isSub)</span> {</span>
  <span class="keyword">if</span> (pattern.length > <span class="number">1024</span> * <span class="number">64</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'pattern is too long'</span>)
  }

  <span class="keyword">var</span> options = <span class="keyword">this</span>.options

  <span class="comment">// shortcuts</span>
  <span class="keyword">if</span> (!options.noglobstar &amp;&amp; pattern === <span class="string">'**'</span>) <span class="keyword">return</span> GLOBSTAR
  <span class="keyword">if</span> (pattern === <span class="string">''</span>) <span class="keyword">return</span> <span class="string">''</span>

  <span class="keyword">var</span> re = <span class="string">''</span>
  <span class="keyword">var</span> hasMagic = !!options.nocase
  <span class="keyword">var</span> escaping = <span class="literal">false</span>
  <span class="comment">// ? => one single character</span>
  <span class="keyword">var</span> patternListStack = []
  <span class="keyword">var</span> negativeLists = []
  <span class="keyword">var</span> stateChar
  <span class="keyword">var</span> inClass = <span class="literal">false</span>
  <span class="keyword">var</span> reClassStart = -<span class="number">1</span>
  <span class="keyword">var</span> classStart = -<span class="number">1</span>
  <span class="comment">// . and .. never match anything that doesn't start with .,</span>
  <span class="comment">// even when options.dot is set.</span>
  <span class="keyword">var</span> patternStart = pattern.charAt(<span class="number">0</span>) === <span class="string">'.'</span> ? <span class="string">''</span> <span class="comment">// anything</span>
  <span class="comment">// not (start or / followed by . or .. followed by / or end)</span>
  : options.dot ? <span class="string">'(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'</span>
  : <span class="string">'(?!\\.)'</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>

  <span class="function"><span class="keyword">function</span> <span class="title">clearStateChar</span> <span class="params">()</span> {</span>
    <span class="keyword">if</span> (stateChar) {
      <span class="comment">// we had some state-tracking character</span>
      <span class="comment">// that wasn't consumed by this pass.</span>
      <span class="keyword">switch</span> (stateChar) {
        <span class="keyword">case</span> <span class="string">'*'</span>:
          re += star
          hasMagic = <span class="literal">true</span>
        <span class="keyword">break</span>
        <span class="keyword">case</span> <span class="string">'?'</span>:
          re += qmark
          hasMagic = <span class="literal">true</span>
        <span class="keyword">break</span>
        <span class="keyword">default</span>:
          re += <span class="string">'\\'</span> + stateChar
        <span class="keyword">break</span>
      }
      self.debug(<span class="string">'clearStateChar %j %j'</span>, stateChar, re)
      stateChar = <span class="literal">false</span>
    }
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = pattern.length, c
    ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))
    ; i++) {
    <span class="keyword">this</span>.debug(<span class="string">'%s\t%s %s %j'</span>, pattern, i, re, c)

    <span class="comment">// skip over any that are escaped.</span>
    <span class="keyword">if</span> (escaping &amp;&amp; reSpecials[c]) {
      re += <span class="string">'\\'</span> + c
      escaping = <span class="literal">false</span>
      <span class="keyword">continue</span>
    }

    <span class="keyword">switch</span> (c) {
      <span class="keyword">case</span> <span class="string">'/'</span>:
        <span class="comment">// completely not allowed, even escaped.</span>
        <span class="comment">// Should already be path-split by now.</span>
        <span class="keyword">return</span> <span class="literal">false</span>

      <span class="keyword">case</span> <span class="string">'\\'</span>:
        clearStateChar()
        escaping = <span class="literal">true</span>
      <span class="keyword">continue</span>

      <span class="comment">// the various stateChar values</span>
      <span class="comment">// for the "extglob" stuff.</span>
      <span class="keyword">case</span> <span class="string">'?'</span>:
      <span class="keyword">case</span> <span class="string">'*'</span>:
      <span class="keyword">case</span> <span class="string">'+'</span>:
      <span class="keyword">case</span> <span class="string">'@'</span>:
      <span class="keyword">case</span> <span class="string">'!'</span>:
        <span class="keyword">this</span>.debug(<span class="string">'%s\t%s %s %j &lt;-- stateChar'</span>, pattern, i, re, c)

        <span class="comment">// all of those are literals inside a class, except that</span>
        <span class="comment">// the glob [!a] means [^a] in regexp</span>
        <span class="keyword">if</span> (inClass) {
          <span class="keyword">this</span>.debug(<span class="string">'  in class'</span>)
          <span class="keyword">if</span> (c === <span class="string">'!'</span> &amp;&amp; i === classStart + <span class="number">1</span>) c = <span class="string">'^'</span>
          re += c
          <span class="keyword">continue</span>
        }

        <span class="comment">// if we already have a stateChar, then it means</span>
        <span class="comment">// that there was something like ** or +? in there.</span>
        <span class="comment">// Handle the stateChar, then proceed with this one.</span>
        self.debug(<span class="string">'call clearStateChar %j'</span>, stateChar)
        clearStateChar()
        stateChar = c
        <span class="comment">// if extglob is disabled, then +(asdf|foo) isn't a thing.</span>
        <span class="comment">// just clear the statechar *now*, rather than even diving into</span>
        <span class="comment">// the patternList stuff.</span>
        <span class="keyword">if</span> (options.noext) clearStateChar()
      <span class="keyword">continue</span>

      <span class="keyword">case</span> <span class="string">'('</span>:
        <span class="keyword">if</span> (inClass) {
          re += <span class="string">'('</span>
          <span class="keyword">continue</span>
        }

        <span class="keyword">if</span> (!stateChar) {
          re += <span class="string">'\\('</span>
          <span class="keyword">continue</span>
        }

        patternListStack.push({
          type: stateChar,
          start: i - <span class="number">1</span>,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        <span class="comment">// negation is (?:(?!js)[^/]*)</span>
        re += stateChar === <span class="string">'!'</span> ? <span class="string">'(?:(?!(?:'</span> : <span class="string">'(?:'</span>
        <span class="keyword">this</span>.debug(<span class="string">'plType %j %j'</span>, stateChar, re)
        stateChar = <span class="literal">false</span>
      <span class="keyword">continue</span>

      <span class="keyword">case</span> <span class="string">')'</span>:
        <span class="keyword">if</span> (inClass || !patternListStack.length) {
          re += <span class="string">'\\)'</span>
          <span class="keyword">continue</span>
        }

        clearStateChar()
        hasMagic = <span class="literal">true</span>
        <span class="keyword">var</span> pl = patternListStack.pop()
        <span class="comment">// negation is (?:(?!js)[^/]*)</span>
        <span class="comment">// The others are (?:&lt;pattern>)&lt;type></span>
        re += pl.close
        <span class="keyword">if</span> (pl.type === <span class="string">'!'</span>) {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      <span class="keyword">continue</span>

      <span class="keyword">case</span> <span class="string">'|'</span>:
        <span class="keyword">if</span> (inClass || !patternListStack.length || escaping) {
          re += <span class="string">'\\|'</span>
          escaping = <span class="literal">false</span>
          <span class="keyword">continue</span>
        }

        clearStateChar()
        re += <span class="string">'|'</span>
      <span class="keyword">continue</span>

      <span class="comment">// these are mostly the same in regexp and glob</span>
      <span class="keyword">case</span> <span class="string">'['</span>:
        <span class="comment">// swallow any state-tracking char before the [</span>
        clearStateChar()

        <span class="keyword">if</span> (inClass) {
          re += <span class="string">'\\'</span> + c
          <span class="keyword">continue</span>
        }

        inClass = <span class="literal">true</span>
        classStart = i
        reClassStart = re.length
        re += c
      <span class="keyword">continue</span>

      <span class="keyword">case</span> <span class="string">']'</span>:
        <span class="comment">//  a right bracket shall lose its special</span>
        <span class="comment">//  meaning and represent itself in</span>
        <span class="comment">//  a bracket expression if it occurs</span>
        <span class="comment">//  first in the list.  -- POSIX.2 2.8.3.2</span>
        <span class="keyword">if</span> (i === classStart + <span class="number">1</span> || !inClass) {
          re += <span class="string">'\\'</span> + c
          escaping = <span class="literal">false</span>
          <span class="keyword">continue</span>
        }

        <span class="comment">// handle the case where we left a class open.</span>
        <span class="comment">// "[z-a]" is valid, equivalent to "\[z-a\]"</span>
        <span class="keyword">if</span> (inClass) {
          <span class="comment">// split where the last [ was, make sure we don't have</span>
          <span class="comment">// an invalid re. if so, re-walk the contents of the</span>
          <span class="comment">// would-be class to re-translate any characters that</span>
          <span class="comment">// were passed through as-is</span>
          <span class="comment">// TODO: It would probably be faster to determine this</span>
          <span class="comment">// without a try/catch and a new RegExp, but it's tricky</span>
          <span class="comment">// to do safely.  For now, this is safe and works.</span>
          <span class="keyword">var</span> cs = pattern.substring(classStart + <span class="number">1</span>, i)
          <span class="keyword">try</span> {
            RegExp(<span class="string">'['</span> + cs + <span class="string">']'</span>)
          } <span class="keyword">catch</span> (er) {
            <span class="comment">// not a valid class!</span>
            <span class="keyword">var</span> sp = <span class="keyword">this</span>.parse(cs, SUBPARSE)
            re = re.substr(<span class="number">0</span>, reClassStart) + <span class="string">'\\['</span> + sp[<span class="number">0</span>] + <span class="string">'\\]'</span>
            hasMagic = hasMagic || sp[<span class="number">1</span>]
            inClass = <span class="literal">false</span>
            <span class="keyword">continue</span>
          }
        }

        <span class="comment">// finish up the class.</span>
        hasMagic = <span class="literal">true</span>
        inClass = <span class="literal">false</span>
        re += c
      <span class="keyword">continue</span>

      <span class="keyword">default</span>:
        <span class="comment">// swallow any state char that wasn't consumed</span>
        clearStateChar()

        <span class="keyword">if</span> (escaping) {
          <span class="comment">// no need</span>
          escaping = <span class="literal">false</span>
        } <span class="keyword">else</span> <span class="keyword">if</span> (reSpecials[c]
          &amp;&amp; !(c === <span class="string">'^'</span> &amp;&amp; inClass)) {
          re += <span class="string">'\\'</span>
        }

        re += c

    } <span class="comment">// switch</span>
  } <span class="comment">// for</span>

  <span class="comment">// handle the case where we left a class open.</span>
  <span class="comment">// "[abc" is valid, equivalent to "\[abc"</span>
  <span class="keyword">if</span> (inClass) {
    <span class="comment">// split where the last [ was, and escape it</span>
    <span class="comment">// this is a huge pita.  We now have to re-walk</span>
    <span class="comment">// the contents of the would-be class to re-translate</span>
    <span class="comment">// any characters that were passed through as-is</span>
    cs = pattern.substr(classStart + <span class="number">1</span>)
    sp = <span class="keyword">this</span>.parse(cs, SUBPARSE)
    re = re.substr(<span class="number">0</span>, reClassStart) + <span class="string">'\\['</span> + sp[<span class="number">0</span>]
    hasMagic = hasMagic || sp[<span class="number">1</span>]
  }

  <span class="comment">// handle the case where we had a +( thing at the *end*</span>
  <span class="comment">// of the pattern.</span>
  <span class="comment">// each pattern list stack adds 3 chars, and we need to go through</span>
  <span class="comment">// and escape any | chars that were passed through as-is for the regexp.</span>
  <span class="comment">// Go through and escape them, taking care not to double-escape any</span>
  <span class="comment">// | chars that were already escaped.</span>
  <span class="keyword">for</span> (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    <span class="keyword">var</span> tail = re.slice(pl.reStart + pl.open.length)
    <span class="keyword">this</span>.debug(<span class="string">'setting tail'</span>, re, pl)
    <span class="comment">// maybe some even number of \, then maybe 1 \, followed by a |</span>
    tail = tail.replace(<span class="regexp">/((?:\\{2}){0,64})(\\?)\|/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(_, $1, $2)</span> {</span>
      <span class="keyword">if</span> (!$<span class="number">2</span>) {
        <span class="comment">// the | isn't already escaped, so escape it.</span>
        $<span class="number">2</span> = <span class="string">'\\'</span>
      }

      <span class="comment">// need to escape all those slashes *again*, without escaping the</span>
      <span class="comment">// one that we need for escaping the | character.  As it works out,</span>
      <span class="comment">// escaping an even number of slashes can be done by simply repeating</span>
      <span class="comment">// it exactly after itself.  That's why this trick works.</span>
      <span class="comment">//</span>
      <span class="comment">// I am sorry that you have to see this.</span>
      <span class="keyword">return</span> $<span class="number">1</span> + $<span class="number">1</span> + $<span class="number">2</span> + <span class="string">'|'</span>
    })

    <span class="keyword">this</span>.debug(<span class="string">'tail=%j\n   %s'</span>, tail, tail, pl, re)
    <span class="keyword">var</span> t = pl.type === <span class="string">'*'</span> ? star
      : pl.type === <span class="string">'?'</span> ? qmark
      : <span class="string">'\\'</span> + pl.type

    hasMagic = <span class="literal">true</span>
    re = re.slice(<span class="number">0</span>, pl.reStart) + t + <span class="string">'\\('</span> + tail
  }

  <span class="comment">// handle trailing things that only matter at the very end.</span>
  clearStateChar()
  <span class="keyword">if</span> (escaping) {
    <span class="comment">// trailing \\</span>
    re += <span class="string">'\\\\'</span>
  }

  <span class="comment">// only need to apply the nodot start if the re starts with</span>
  <span class="comment">// something that could conceivably capture a dot</span>
  <span class="keyword">var</span> addPatternStart = <span class="literal">false</span>
  <span class="keyword">switch</span> (re.charAt(<span class="number">0</span>)) {
    <span class="keyword">case</span> <span class="string">'.'</span>:
    <span class="keyword">case</span> <span class="string">'['</span>:
    <span class="keyword">case</span> <span class="string">'('</span>: addPatternStart = <span class="literal">true</span>
  }

  <span class="comment">// Hack to work around lack of negative lookbehind in JS</span>
  <span class="comment">// A pattern like: *.!(x).!(y|z) needs to ensure that a name</span>
  <span class="comment">// like 'a.xyz.yz' doesn't match.  So, the first negative</span>
  <span class="comment">// lookahead, has to look ALL the way ahead, to the end of</span>
  <span class="comment">// the pattern.</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> n = negativeLists.length - <span class="number">1</span>; n > -<span class="number">1</span>; n--) {
    <span class="keyword">var</span> nl = negativeLists[n]

    <span class="keyword">var</span> nlBefore = re.slice(<span class="number">0</span>, nl.reStart)
    <span class="keyword">var</span> nlFirst = re.slice(nl.reStart, nl.reEnd - <span class="number">8</span>)
    <span class="keyword">var</span> nlLast = re.slice(nl.reEnd - <span class="number">8</span>, nl.reEnd)
    <span class="keyword">var</span> nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    <span class="comment">// Handle nested stuff like *(*.js|!(*.json)), where open parens</span>
    <span class="comment">// mean that we should *not* include the ) in the bit that is considered</span>
    <span class="comment">// "after" the negated section.</span>
    <span class="keyword">var</span> openParensBefore = nlBefore.split(<span class="string">'('</span>).length - <span class="number">1</span>
    <span class="keyword">var</span> cleanAfter = nlAfter
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(<span class="regexp">/\)[+*?]?/</span>, <span class="string">''</span>)
    }
    nlAfter = cleanAfter

    <span class="keyword">var</span> dollar = <span class="string">''</span>
    <span class="keyword">if</span> (nlAfter === <span class="string">''</span> &amp;&amp; isSub !== SUBPARSE) {
      dollar = <span class="string">'$'</span>
    }
    <span class="keyword">var</span> newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  <span class="comment">// if the re is not "" at this point, then we need to make sure</span>
  <span class="comment">// it doesn't match against an empty path part.</span>
  <span class="comment">// Otherwise a/* will match a/, which it should not.</span>
  <span class="keyword">if</span> (re !== <span class="string">''</span> &amp;&amp; hasMagic) {
    re = <span class="string">'(?=.)'</span> + re
  }

  <span class="keyword">if</span> (addPatternStart) {
    re = patternStart + re
  }

  <span class="comment">// parsing just a piece of a larger pattern.</span>
  <span class="keyword">if</span> (isSub === SUBPARSE) {
    <span class="keyword">return</span> [re, hasMagic]
  }

  <span class="comment">// skip the regexp for non-magical patterns</span>
  <span class="comment">// unescape anything in it, though, so that it'll be</span>
  <span class="comment">// an exact match against a file etc.</span>
  <span class="keyword">if</span> (!hasMagic) {
    <span class="keyword">return</span> globUnescape(pattern)
  }

  <span class="keyword">var</span> flags = options.nocase ? <span class="string">'i'</span> : <span class="string">''</span>
  <span class="keyword">try</span> {
    <span class="keyword">var</span> regExp = <span class="keyword">new</span> RegExp(<span class="string">'^'</span> + re + <span class="string">'$'</span>, flags)
  } <span class="keyword">catch</span> (er) {
    <span class="comment">// If it was an invalid regular expression, then it can't match</span>
    <span class="comment">// anything.  This trick looks for a character after the end of</span>
    <span class="comment">// the string, which is of course impossible, except in multi-line</span>
    <span class="comment">// mode, but it's not a /m regex.</span>
    <span class="keyword">return</span> <span class="keyword">new</span> RegExp(<span class="string">'$.'</span>)
  }

  regExp._glob = pattern
  regExp._src = re

  <span class="keyword">return</span> regExp
}

minimatch.makeRe = <span class="function"><span class="keyword">function</span> <span class="params">(pattern, options)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
<span class="function"><span class="keyword">function</span> <span class="title">makeRe</span> <span class="params">()</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.regexp || <span class="keyword">this</span>.regexp === <span class="literal">false</span>) <span class="keyword">return</span> <span class="keyword">this</span>.regexp

  <span class="comment">// at this point, this.set is a 2d array of partial</span>
  <span class="comment">// pattern strings, or "**".</span>
  <span class="comment">//</span>
  <span class="comment">// It's better to use .match().  This function shouldn't</span>
  <span class="comment">// be used, really, but it's pretty convenient sometimes,</span>
  <span class="comment">// when you just want to work with a regex.</span>
  <span class="keyword">var</span> set = <span class="keyword">this</span>.set

  <span class="keyword">if</span> (!set.length) {
    <span class="keyword">this</span>.regexp = <span class="literal">false</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.regexp
  }
  <span class="keyword">var</span> options = <span class="keyword">this</span>.options

  <span class="keyword">var</span> twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  <span class="keyword">var</span> flags = options.nocase ? <span class="string">'i'</span> : <span class="string">''</span>

  <span class="keyword">var</span> re = set.map(<span class="function"><span class="keyword">function</span> <span class="params">(pattern)</span> {</span>
    <span class="keyword">return</span> pattern.map(<span class="function"><span class="keyword">function</span> <span class="params">(p)</span> {</span>
      <span class="keyword">return</span> (p === GLOBSTAR) ? twoStar
      : (<span class="keyword">typeof</span> p === <span class="string">'string'</span>) ? regExpEscape(p)
      : p._src
    }).join(<span class="string">'\\\/'</span>)
  }).join(<span class="string">'|'</span>)

  <span class="comment">// must match entire pattern</span>
  <span class="comment">// ending in a * or ** will make it less strict.</span>
  re = <span class="string">'^(?:'</span> + re + <span class="string">')$'</span>

  <span class="comment">// can match anything, as long as it's not this.</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.negate) re = <span class="string">'^(?!'</span> + re + <span class="string">').*$'</span>

  <span class="keyword">try</span> {
    <span class="keyword">this</span>.regexp = <span class="keyword">new</span> RegExp(re, flags)
  } <span class="keyword">catch</span> (ex) {
    <span class="keyword">this</span>.regexp = <span class="literal">false</span>
  }
  <span class="keyword">return</span> <span class="keyword">this</span>.regexp
}

minimatch.match = <span class="function"><span class="keyword">function</span> <span class="params">(list, pattern, options)</span> {</span>
  options = options || {}
  <span class="keyword">var</span> mm = <span class="keyword">new</span> Minimatch(pattern, options)
  list = list.filter(<span class="function"><span class="keyword">function</span> <span class="params">(f)</span> {</span>
    <span class="keyword">return</span> mm.match(f)
  })
  <span class="keyword">if</span> (mm.options.nonull &amp;&amp; !list.length) {
    list.push(pattern)
  }
  <span class="keyword">return</span> list
}

Minimatch.prototype.match = match
<span class="function"><span class="keyword">function</span> <span class="title">match</span> <span class="params">(f, partial)</span> {</span>
  <span class="keyword">this</span>.debug(<span class="string">'match'</span>, f, <span class="keyword">this</span>.pattern)
  <span class="comment">// short-circuit in the case of busted things.</span>
  <span class="comment">// comments, etc.</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.comment) <span class="keyword">return</span> <span class="literal">false</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.empty) <span class="keyword">return</span> f === <span class="string">''</span>

  <span class="keyword">if</span> (f === <span class="string">'/'</span> &amp;&amp; partial) <span class="keyword">return</span> <span class="literal">true</span>

  <span class="keyword">var</span> options = <span class="keyword">this</span>.options

  <span class="comment">// windows: need to use /, not \</span>
  <span class="keyword">if</span> (path.sep !== <span class="string">'/'</span>) {
    f = f.split(path.sep).join(<span class="string">'/'</span>)
  }

  <span class="comment">// treat the test path as a set of pathparts.</span>
  f = f.split(slashSplit)
  <span class="keyword">this</span>.debug(<span class="keyword">this</span>.pattern, <span class="string">'split'</span>, f)

  <span class="comment">// just ONE of the pattern sets in this.set needs to match</span>
  <span class="comment">// in order for it to be valid.  If negating, then just one</span>
  <span class="comment">// match means that we have failed.</span>
  <span class="comment">// Either way, return on the first hit.</span>

  <span class="keyword">var</span> set = <span class="keyword">this</span>.set
  <span class="keyword">this</span>.debug(<span class="keyword">this</span>.pattern, <span class="string">'set'</span>, set)

  <span class="comment">// Find the basename of the path by looking for the last non-empty segment</span>
  <span class="keyword">var</span> filename
  <span class="keyword">var</span> i
  <span class="keyword">for</span> (i = f.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
    filename = f[i]
    <span class="keyword">if</span> (filename) <span class="keyword">break</span>
  }

  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; set.length; i++) {
    <span class="keyword">var</span> pattern = set[i]
    <span class="keyword">var</span> file = f
    <span class="keyword">if</span> (options.matchBase &amp;&amp; pattern.length === <span class="number">1</span>) {
      file = [filename]
    }
    <span class="keyword">var</span> hit = <span class="keyword">this</span>.matchOne(file, pattern, partial)
    <span class="keyword">if</span> (hit) {
      <span class="keyword">if</span> (options.flipNegate) <span class="keyword">return</span> <span class="literal">true</span>
      <span class="keyword">return</span> !<span class="keyword">this</span>.negate
    }
  }

  <span class="comment">// didn't get any hits.  this is success if it's a negative</span>
  <span class="comment">// pattern, failure otherwise.</span>
  <span class="keyword">if</span> (options.flipNegate) <span class="keyword">return</span> <span class="literal">false</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.negate
}

<span class="comment">// set partial to true to test if, for example,</span>
<span class="comment">// "/a/b" matches the start of "/*/b/*/d"</span>
<span class="comment">// Partial means, if you run out of file before you run</span>
<span class="comment">// out of pattern, then that's fine, as long as all</span>
<span class="comment">// the parts match.</span>
Minimatch.prototype.matchOne = <span class="function"><span class="keyword">function</span> <span class="params">(file, pattern, partial)</span> {</span>
  <span class="keyword">var</span> options = <span class="keyword">this</span>.options

  <span class="keyword">this</span>.debug(<span class="string">'matchOne'</span>,
    { <span class="string">'this'</span>: <span class="keyword">this</span>, file: file, pattern: pattern })

  <span class="keyword">this</span>.debug(<span class="string">'matchOne'</span>, file.length, pattern.length)

  <span class="keyword">for</span> (<span class="keyword">var</span> fi = <span class="number">0</span>,
      pi = <span class="number">0</span>,
      fl = file.length,
      pl = pattern.length
      ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
      ; fi++, pi++) {
    <span class="keyword">this</span>.debug(<span class="string">'matchOne loop'</span>)
    <span class="keyword">var</span> p = pattern[pi]
    <span class="keyword">var</span> f = file[fi]

    <span class="keyword">this</span>.debug(pattern, p, f)

    <span class="comment">// should be impossible.</span>
    <span class="comment">// some invalid regexp stuff in the set.</span>
    <span class="keyword">if</span> (p === <span class="literal">false</span>) <span class="keyword">return</span> <span class="literal">false</span>

    <span class="keyword">if</span> (p === GLOBSTAR) {
      <span class="keyword">this</span>.debug(<span class="string">'GLOBSTAR'</span>, [pattern, p, f])

      <span class="comment">// "**"</span>
      <span class="comment">// a/**/b/**/c would match the following:</span>
      <span class="comment">// a/b/x/y/z/c</span>
      <span class="comment">// a/x/y/z/b/c</span>
      <span class="comment">// a/b/x/b/x/c</span>
      <span class="comment">// a/b/c</span>
      <span class="comment">// To do this, take the rest of the pattern after</span>
      <span class="comment">// the **, and see if it would match the file remainder.</span>
      <span class="comment">// If so, return success.</span>
      <span class="comment">// If not, the ** "swallows" a segment, and try again.</span>
      <span class="comment">// This is recursively awful.</span>
      <span class="comment">//</span>
      <span class="comment">// a/**/b/**/c matching a/b/x/y/z/c</span>
      <span class="comment">// - a matches a</span>
      <span class="comment">// - doublestar</span>
      <span class="comment">//   - matchOne(b/x/y/z/c, b/**/c)</span>
      <span class="comment">//     - b matches b</span>
      <span class="comment">//     - doublestar</span>
      <span class="comment">//       - matchOne(x/y/z/c, c) -> no</span>
      <span class="comment">//       - matchOne(y/z/c, c) -> no</span>
      <span class="comment">//       - matchOne(z/c, c) -> no</span>
      <span class="comment">//       - matchOne(c, c) yes, hit</span>
      <span class="keyword">var</span> fr = fi
      <span class="keyword">var</span> pr = pi + <span class="number">1</span>
      <span class="keyword">if</span> (pr === pl) {
        <span class="keyword">this</span>.debug(<span class="string">'** at the end'</span>)
        <span class="comment">// a ** at the end will just swallow the rest.</span>
        <span class="comment">// We have found a match.</span>
        <span class="comment">// however, it will not swallow /.x, unless</span>
        <span class="comment">// options.dot is set.</span>
        <span class="comment">// . and .. are *never* matched by **, for explosively</span>
        <span class="comment">// exponential reasons.</span>
        <span class="keyword">for</span> (; fi &lt; fl; fi++) {
          <span class="keyword">if</span> (file[fi] === <span class="string">'.'</span> || file[fi] === <span class="string">'..'</span> ||
            (!options.dot &amp;&amp; file[fi].charAt(<span class="number">0</span>) === <span class="string">'.'</span>)) <span class="keyword">return</span> <span class="literal">false</span>
        }
        <span class="keyword">return</span> <span class="literal">true</span>
      }

      <span class="comment">// ok, let's see if we can swallow whatever we can.</span>
      <span class="keyword">while</span> (fr &lt; fl) {
        <span class="keyword">var</span> swallowee = file[fr]

        <span class="keyword">this</span>.debug(<span class="string">'\nglobstar while'</span>, file, fr, pattern, pr, swallowee)

        <span class="comment">// XXX remove this slice.  Just pass the start index.</span>
        <span class="keyword">if</span> (<span class="keyword">this</span>.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          <span class="keyword">this</span>.debug(<span class="string">'globstar found match!'</span>, fr, fl, swallowee)
          <span class="comment">// found a match.</span>
          <span class="keyword">return</span> <span class="literal">true</span>
        } <span class="keyword">else</span> {
          <span class="comment">// can't swallow "." or ".." ever.</span>
          <span class="comment">// can only swallow ".foo" when explicitly asked.</span>
          <span class="keyword">if</span> (swallowee === <span class="string">'.'</span> || swallowee === <span class="string">'..'</span> ||
            (!options.dot &amp;&amp; swallowee.charAt(<span class="number">0</span>) === <span class="string">'.'</span>)) {
            <span class="keyword">this</span>.debug(<span class="string">'dot detected!'</span>, file, fr, pattern, pr)
            <span class="keyword">break</span>
          }

          <span class="comment">// ** swallows a segment, and continue.</span>
          <span class="keyword">this</span>.debug(<span class="string">'globstar swallow a segment, and continue'</span>)
          fr++
        }
      }

      <span class="comment">// no match was found.</span>
      <span class="comment">// However, in partial mode, we can't say this is necessarily over.</span>
      <span class="comment">// If there's more *pattern* left, then</span>
      <span class="keyword">if</span> (partial) {
        <span class="comment">// ran out of file</span>
        <span class="keyword">this</span>.debug(<span class="string">'\n>>> no match, partial?'</span>, file, fr, pattern, pr)
        <span class="keyword">if</span> (fr === fl) <span class="keyword">return</span> <span class="literal">true</span>
      }
      <span class="keyword">return</span> <span class="literal">false</span>
    }

    <span class="comment">// something other than **</span>
    <span class="comment">// non-magic patterns just have to match exactly</span>
    <span class="comment">// patterns with magic have been turned into regexps.</span>
    <span class="keyword">var</span> hit
    <span class="keyword">if</span> (<span class="keyword">typeof</span> p === <span class="string">'string'</span>) {
      <span class="keyword">if</span> (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } <span class="keyword">else</span> {
        hit = f === p
      }
      <span class="keyword">this</span>.debug(<span class="string">'string match'</span>, p, f, hit)
    } <span class="keyword">else</span> {
      hit = f.match(p)
      <span class="keyword">this</span>.debug(<span class="string">'pattern match'</span>, p, f, hit)
    }

    <span class="keyword">if</span> (!hit) <span class="keyword">return</span> <span class="literal">false</span>
  }

  <span class="comment">// Note: ending in / means that we'll get a final ""</span>
  <span class="comment">// at the end of the pattern.  This can only match a</span>
  <span class="comment">// corresponding "" at the end of the file.</span>
  <span class="comment">// If the file ends in /, then it can only match a</span>
  <span class="comment">// a pattern that ends in /, unless the pattern just</span>
  <span class="comment">// doesn't have any more for it. But, a/b/ should *not*</span>
  <span class="comment">// match "a/b/*", even though "" matches against the</span>
  <span class="comment">// [^/]*? pattern, except in partial mode, where it might</span>
  <span class="comment">// simply not be reached yet.</span>
  <span class="comment">// However, a/b/ should still satisfy a/*</span>

  <span class="comment">// now either we fell off the end of the pattern, or we're done.</span>
  <span class="keyword">if</span> (fi === fl &amp;&amp; pi === pl) {
    <span class="comment">// ran out of pattern and filename at the same time.</span>
    <span class="comment">// an exact hit!</span>
    <span class="keyword">return</span> <span class="literal">true</span>
  } <span class="keyword">else</span> <span class="keyword">if</span> (fi === fl) {
    <span class="comment">// ran out of file, but still had pattern left.</span>
    <span class="comment">// this is ok if we're doing the match as part of</span>
    <span class="comment">// a glob fs traversal.</span>
    <span class="keyword">return</span> partial
  } <span class="keyword">else</span> <span class="keyword">if</span> (pi === pl) {
    <span class="comment">// ran out of pattern, still have file left.</span>
    <span class="comment">// this is only acceptable if we're on the very last</span>
    <span class="comment">// empty segment of a file with a trailing slash.</span>
    <span class="comment">// a/* should match a/b/</span>
    <span class="keyword">var</span> emptyFileEnd = (fi === fl - <span class="number">1</span>) &amp;&amp; (file[fi] === <span class="string">''</span>)
    <span class="keyword">return</span> emptyFileEnd
  }

  <span class="comment">// should be unreachable.</span>
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'wtf?'</span>)
}

<span class="comment">// replace stuff like \* with *</span>
<span class="function"><span class="keyword">function</span> <span class="title">globUnescape</span> <span class="params">(s)</span> {</span>
  <span class="keyword">return</span> s.replace(<span class="regexp">/\\(.)/g</span>, <span class="string">'$1'</span>)
}

<span class="function"><span class="keyword">function</span> <span class="title">regExpEscape</span> <span class="params">(s)</span> {</span>
  <span class="keyword">return</span> s.replace(<span class="regexp">/[-[\]{}()*+?.,\\^$|#\s]/g</span>, <span class="string">'\\$&amp;'</span>)
}
</code></pre>